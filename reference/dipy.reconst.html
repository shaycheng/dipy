
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DIPY &#8212; dipy 0.15.0dev documentation</title>
    <link rel="stylesheet" href="../_static/dipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head><body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../index.html">
  <img src="../_static/dipy-banner.png" alt="DIPY logo"  border="0" />
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">API Reference</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Site Navigation </h4>
  <ul>
    <li><a href="../documentation.html">Documentation</a></li>
    <li><a href="../devel/index.html">Development</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.org/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.org/">NIPY Projects</a></li>
    <li><a class="reference external"
	href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing List</a></li>
    <li><a class="reference external"
	href="http://nipy.org/nipy/license.html">License</a></li>
  </ul>


  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">reconst</span></code></a><ul>
<li><a class="reference internal" href="#module-dipy.reconst.base">Module: <code class="docutils literal notranslate"><span class="pre">reconst.base</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks">Module: <code class="docutils literal notranslate"><span class="pre">reconst.benchmarks</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_bounding_box">Module: <code class="docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_bounding_box</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_csd">Module: <code class="docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_csd</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_peaks">Module: <code class="docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_peaks</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_squash">Module: <code class="docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_squash</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.benchmarks.bench_vec_val_sum">Module: <code class="docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_vec_val_sum</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.cache">Module: <code class="docutils literal notranslate"><span class="pre">reconst.cache</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.cross_validation">Module: <code class="docutils literal notranslate"><span class="pre">reconst.cross_validation</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.csdeconv">Module: <code class="docutils literal notranslate"><span class="pre">reconst.csdeconv</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.dki">Module: <code class="docutils literal notranslate"><span class="pre">reconst.dki</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.dki_micro">Module: <code class="docutils literal notranslate"><span class="pre">reconst.dki_micro</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.dsi">Module: <code class="docutils literal notranslate"><span class="pre">reconst.dsi</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.dti">Module: <code class="docutils literal notranslate"><span class="pre">reconst.dti</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.forecast">Module: <code class="docutils literal notranslate"><span class="pre">reconst.forecast</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.fwdti">Module: <code class="docutils literal notranslate"><span class="pre">reconst.fwdti</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.gqi">Module: <code class="docutils literal notranslate"><span class="pre">reconst.gqi</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.interpolate">Module: <code class="docutils literal notranslate"><span class="pre">reconst.interpolate</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.ivim">Module: <code class="docutils literal notranslate"><span class="pre">reconst.ivim</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.mapmri">Module: <code class="docutils literal notranslate"><span class="pre">reconst.mapmri</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.multi_voxel">Module: <code class="docutils literal notranslate"><span class="pre">reconst.multi_voxel</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.odf">Module: <code class="docutils literal notranslate"><span class="pre">reconst.odf</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.peaks">Module: <code class="docutils literal notranslate"><span class="pre">reconst.peaks</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.qtdmri">Module: <code class="docutils literal notranslate"><span class="pre">reconst.qtdmri</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.scratch">Module: <code class="docutils literal notranslate"><span class="pre">reconst.scratch</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.sfm">Module: <code class="docutils literal notranslate"><span class="pre">reconst.sfm</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.shm">Module: <code class="docutils literal notranslate"><span class="pre">reconst.shm</span></code></a><ul>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-dipy.reconst.shore">Module: <code class="docutils literal notranslate"><span class="pre">reconst.shore</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.reconst.utils">Module: <code class="docutils literal notranslate"><span class="pre">reconst.utils</span></code></a><ul>
<li><a class="reference internal" href="#bench">bench</a></li>
<li><a class="reference internal" href="#test">test</a></li>
<li><a class="reference internal" href="#reconstfit"><code class="docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></li>
<li><a class="reference internal" href="#reconstmodel"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></li>
<li><a class="reference internal" href="#bench-bounding-box">bench_bounding_box</a></li>
<li><a class="reference internal" href="#bounding-box">bounding_box</a></li>
<li><a class="reference internal" href="#measure">measure</a></li>
<li><a class="reference internal" href="#constrainedsphericaldeconvmodel"><code class="docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a></li>
<li><a class="reference internal" href="#gradienttable"><code class="docutils literal notranslate"><span class="pre">GradientTable</span></code></a></li>
<li><a class="reference internal" href="#bench-csdeconv">bench_csdeconv</a></li>
<li><a class="reference internal" href="#num-grad">num_grad</a></li>
<li><a class="reference internal" href="#read-stanford-labels">read_stanford_labels</a></li>
<li><a class="reference internal" href="#bench-local-maxima">bench_local_maxima</a></li>
<li><a class="reference internal" href="#get-sphere">get_sphere</a></li>
<li><a class="reference internal" href="#local-maxima">local_maxima</a></li>
<li><a class="reference internal" href="#id73">measure</a></li>
<li><a class="reference internal" href="#unique-edges">unique_edges</a></li>
<li><a class="reference internal" href="#bench-quick-squash">bench_quick_squash</a></li>
<li><a class="reference internal" href="#id74">measure</a></li>
<li><a class="reference internal" href="#ndindex">ndindex</a></li>
<li><a class="reference internal" href="#old-squash">old_squash</a></li>
<li><a class="reference internal" href="#quick-squash">quick_squash</a></li>
<li><a class="reference internal" href="#reduce">reduce</a></li>
<li><a class="reference internal" href="#bench-vec-val-vect">bench_vec_val_vect</a></li>
<li><a class="reference internal" href="#id75">measure</a></li>
<li><a class="reference internal" href="#randn">randn</a></li>
<li><a class="reference internal" href="#vec-val-vect">vec_val_vect</a></li>
<li><a class="reference internal" href="#with-einsum">with_einsum</a></li>
<li><a class="reference internal" href="#cache"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a></li>
<li><a class="reference internal" href="#auto-attr">auto_attr</a></li>
<li><a class="reference internal" href="#range"><code class="docutils literal notranslate"><span class="pre">range</span></code></a></li>
<li><a class="reference internal" href="#coeff-of-determination">coeff_of_determination</a></li>
<li><a class="reference internal" href="#kfold-xval">kfold_xval</a></li>
<li><a class="reference internal" href="#axsymshresponse"><code class="docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a></li>
<li><a class="reference internal" href="#constrainedsdtmodel"><code class="docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a></li>
<li><a class="reference internal" href="#id82"><code class="docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a></li>
<li><a class="reference internal" href="#sphharmfit"><code class="docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a></li>
<li><a class="reference internal" href="#sphharmmodel"><code class="docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></li>
<li><a class="reference internal" href="#tensormodel"><code class="docutils literal notranslate"><span class="pre">TensorModel</span></code></a></li>
<li><a class="reference internal" href="#id104"><code class="docutils literal notranslate"><span class="pre">range</span></code></a></li>
<li><a class="reference internal" href="#auto-response">auto_response</a></li>
<li><a class="reference internal" href="#cart2sphere">cart2sphere</a></li>
<li><a class="reference internal" href="#csdeconv">csdeconv</a></li>
<li><a class="reference internal" href="#estimate-response">estimate_response</a></li>
<li><a class="reference internal" href="#fa-inferior">fa_inferior</a></li>
<li><a class="reference internal" href="#fa-superior">fa_superior</a></li>
<li><a class="reference internal" href="#fa-trace-to-lambdas">fa_trace_to_lambdas</a></li>
<li><a class="reference internal" href="#forward-sdeconv-mat">forward_sdeconv_mat</a></li>
<li><a class="reference internal" href="#forward-sdt-deconv-mat">forward_sdt_deconv_mat</a></li>
<li><a class="reference internal" href="#fractional-anisotropy">fractional_anisotropy</a></li>
<li><a class="reference internal" href="#id112">get_sphere</a></li>
<li><a class="reference internal" href="#lazy-index">lazy_index</a></li>
<li><a class="reference internal" href="#lpn">lpn</a></li>
<li><a class="reference internal" href="#multi-voxel-fit">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#id114">ndindex</a></li>
<li><a class="reference internal" href="#odf-deconv">odf_deconv</a></li>
<li><a class="reference internal" href="#odf-sh-to-sharp">odf_sh_to_sharp</a></li>
<li><a class="reference internal" href="#peaks-from-model">peaks_from_model</a></li>
<li><a class="reference internal" href="#quad">quad</a></li>
<li><a class="reference internal" href="#real-sph-harm">real_sph_harm</a></li>
<li><a class="reference internal" href="#real-sym-sh-basis">real_sym_sh_basis</a></li>
<li><a class="reference internal" href="#recursive-response">recursive_response</a></li>
<li><a class="reference internal" href="#response-from-mask">response_from_mask</a></li>
<li><a class="reference internal" href="#sh-to-rh">sh_to_rh</a></li>
<li><a class="reference internal" href="#single-tensor">single_tensor</a></li>
<li><a class="reference internal" href="#sph-harm-ind-list">sph_harm_ind_list</a></li>
<li><a class="reference internal" href="#vec2vec-rotmat">vec2vec_rotmat</a></li>
<li><a class="reference internal" href="#diffusionkurtosisfit"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a></li>
<li><a class="reference internal" href="#diffusionkurtosismodel"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a></li>
<li><a class="reference internal" href="#id166"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></li>
<li><a class="reference internal" href="#tensorfit"><code class="docutils literal notranslate"><span class="pre">TensorFit</span></code></a></li>
<li><a class="reference internal" href="#id174"><code class="docutils literal notranslate"><span class="pre">range</span></code></a></li>
<li><a class="reference internal" href="#wcons">Wcons</a></li>
<li><a class="reference internal" href="#wrotate">Wrotate</a></li>
<li><a class="reference internal" href="#wrotate-element">Wrotate_element</a></li>
<li><a class="reference internal" href="#apparent-kurtosis-coef">apparent_kurtosis_coef</a></li>
<li><a class="reference internal" href="#axial-kurtosis">axial_kurtosis</a></li>
<li><a class="reference internal" href="#carlson-rd">carlson_rd</a></li>
<li><a class="reference internal" href="#carlson-rf">carlson_rf</a></li>
<li><a class="reference internal" href="#id183">cart2sphere</a></li>
<li><a class="reference internal" href="#check-multi-b">check_multi_b</a></li>
<li><a class="reference internal" href="#decompose-tensor">decompose_tensor</a></li>
<li><a class="reference internal" href="#design-matrix">design_matrix</a></li>
<li><a class="reference internal" href="#directional-diffusion">directional_diffusion</a></li>
<li><a class="reference internal" href="#directional-diffusion-variance">directional_diffusion_variance</a></li>
<li><a class="reference internal" href="#directional-kurtosis">directional_kurtosis</a></li>
<li><a class="reference internal" href="#dki-prediction">dki_prediction</a></li>
<li><a class="reference internal" href="#from-lower-triangular">from_lower_triangular</a></li>
<li><a class="reference internal" href="#id193">get_sphere</a></li>
<li><a class="reference internal" href="#kurtosis-maximum">kurtosis_maximum</a></li>
<li><a class="reference internal" href="#id194">local_maxima</a></li>
<li><a class="reference internal" href="#lower-triangular">lower_triangular</a></li>
<li><a class="reference internal" href="#mean-diffusivity">mean_diffusivity</a></li>
<li><a class="reference internal" href="#mean-kurtosis">mean_kurtosis</a></li>
<li><a class="reference internal" href="#id200">ndindex</a></li>
<li><a class="reference internal" href="#ols-fit-dki">ols_fit_dki</a></li>
<li><a class="reference internal" href="#radial-kurtosis">radial_kurtosis</a></li>
<li><a class="reference internal" href="#sphere2cart">sphere2cart</a></li>
<li><a class="reference internal" href="#split-dki-param">split_dki_param</a></li>
<li><a class="reference internal" href="#id208">vec_val_vect</a></li>
<li><a class="reference internal" href="#wls-fit-dki">wls_fit_dki</a></li>
<li><a class="reference internal" href="#id211"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a></li>
<li><a class="reference internal" href="#id226"><code class="docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a></li>
<li><a class="reference internal" href="#kurtosismicrostructuralfit"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a></li>
<li><a class="reference internal" href="#kurtosismicrostructuremodel"><code class="docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a></li>
<li><a class="reference internal" href="#axial-diffusivity">axial_diffusivity</a></li>
<li><a class="reference internal" href="#axonal-water-fraction">axonal_water_fraction</a></li>
<li><a class="reference internal" href="#id255">decompose_tensor</a></li>
<li><a class="reference internal" href="#diffusion-components">diffusion_components</a></li>
<li><a class="reference internal" href="#id258">directional_diffusion</a></li>
<li><a class="reference internal" href="#id261">directional_kurtosis</a></li>
<li><a class="reference internal" href="#dkimicro-prediction">dkimicro_prediction</a></li>
<li><a class="reference internal" href="#dti-design-matrix">dti_design_matrix</a></li>
<li><a class="reference internal" href="#id269">from_lower_triangular</a></li>
<li><a class="reference internal" href="#id270">get_sphere</a></li>
<li><a class="reference internal" href="#id271">kurtosis_maximum</a></li>
<li><a class="reference internal" href="#id272">lower_triangular</a></li>
<li><a class="reference internal" href="#id273">mean_diffusivity</a></li>
<li><a class="reference internal" href="#id274">ndindex</a></li>
<li><a class="reference internal" href="#radial-diffusivity">radial_diffusivity</a></li>
<li><a class="reference internal" href="#id275">split_dki_param</a></li>
<li><a class="reference internal" href="#tortuosity">tortuosity</a></li>
<li><a class="reference internal" href="#trace">trace</a></li>
<li><a class="reference internal" href="#id276">vec_val_vect</a></li>
<li><a class="reference internal" href="#id277"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a></li>
<li><a class="reference internal" href="#diffusionspectrumdeconvfit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a></li>
<li><a class="reference internal" href="#diffusionspectrumdeconvmodel"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a></li>
<li><a class="reference internal" href="#diffusionspectrumfit"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a></li>
<li><a class="reference internal" href="#diffusionspectrummodel"><code class="docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a></li>
<li><a class="reference internal" href="#odffit"><code class="docutils literal notranslate"><span class="pre">OdfFit</span></code></a></li>
<li><a class="reference internal" href="#odfmodel"><code class="docutils literal notranslate"><span class="pre">OdfModel</span></code></a></li>
<li><a class="reference internal" href="#lr-deconv">LR_deconv</a></li>
<li><a class="reference internal" href="#create-qspace">create_qspace</a></li>
<li><a class="reference internal" href="#create-qtable">create_qtable</a></li>
<li><a class="reference internal" href="#fftn">fftn</a></li>
<li><a class="reference internal" href="#fftshift">fftshift</a></li>
<li><a class="reference internal" href="#gen-psf">gen_PSF</a></li>
<li><a class="reference internal" href="#half-to-full-qspace">half_to_full_qspace</a></li>
<li><a class="reference internal" href="#hanning-filter">hanning_filter</a></li>
<li><a class="reference internal" href="#ifftshift">ifftshift</a></li>
<li><a class="reference internal" href="#map-coordinates">map_coordinates</a></li>
<li><a class="reference internal" href="#id296">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#pdf-interp-coords">pdf_interp_coords</a></li>
<li><a class="reference internal" href="#pdf-odf">pdf_odf</a></li>
<li><a class="reference internal" href="#project-hemisph-bvecs">project_hemisph_bvecs</a></li>
<li><a class="reference internal" href="#setup-test">setup_test</a></li>
<li><a class="reference internal" href="#threshold-propagator">threshold_propagator</a></li>
<li><a class="reference internal" href="#id297"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></li>
<li><a class="reference internal" href="#id298"><code class="docutils literal notranslate"><span class="pre">TensorFit</span></code></a></li>
<li><a class="reference internal" href="#id306"><code class="docutils literal notranslate"><span class="pre">TensorModel</span></code></a></li>
<li><a class="reference internal" href="#id317"><code class="docutils literal notranslate"><span class="pre">range</span></code></a></li>
<li><a class="reference internal" href="#apparent-diffusion-coef">apparent_diffusion_coef</a></li>
<li><a class="reference internal" href="#id318">auto_attr</a></li>
<li><a class="reference internal" href="#id319">axial_diffusivity</a></li>
<li><a class="reference internal" href="#color-fa">color_fa</a></li>
<li><a class="reference internal" href="#id320">decompose_tensor</a></li>
<li><a class="reference internal" href="#id321">design_matrix</a></li>
<li><a class="reference internal" href="#determinant">determinant</a></li>
<li><a class="reference internal" href="#deviatoric">deviatoric</a></li>
<li><a class="reference internal" href="#eig-from-lo-tri">eig_from_lo_tri</a></li>
<li><a class="reference internal" href="#eigh">eigh</a></li>
<li><a class="reference internal" href="#id325">fractional_anisotropy</a></li>
<li><a class="reference internal" href="#id326">from_lower_triangular</a></li>
<li><a class="reference internal" href="#geodesic-anisotropy">geodesic_anisotropy</a></li>
<li><a class="reference internal" href="#id334">get_sphere</a></li>
<li><a class="reference internal" href="#gradient-table">gradient_table</a></li>
<li><a class="reference internal" href="#isotropic">isotropic</a></li>
<li><a class="reference internal" href="#iter-fit-tensor">iter_fit_tensor</a></li>
<li><a class="reference internal" href="#linearity">linearity</a></li>
<li><a class="reference internal" href="#id337">lower_triangular</a></li>
<li><a class="reference internal" href="#id338">mean_diffusivity</a></li>
<li><a class="reference internal" href="#mode">mode</a></li>
<li><a class="reference internal" href="#nlls-fit-tensor">nlls_fit_tensor</a></li>
<li><a class="reference internal" href="#norm">norm</a></li>
<li><a class="reference internal" href="#ols-fit-tensor">ols_fit_tensor</a></li>
<li><a class="reference internal" href="#pinv">pinv</a></li>
<li><a class="reference internal" href="#planarity">planarity</a></li>
<li><a class="reference internal" href="#quantize-evecs">quantize_evecs</a></li>
<li><a class="reference internal" href="#id346">radial_diffusivity</a></li>
<li><a class="reference internal" href="#restore-fit-tensor">restore_fit_tensor</a></li>
<li><a class="reference internal" href="#sphericity">sphericity</a></li>
<li><a class="reference internal" href="#tensor-prediction">tensor_prediction</a></li>
<li><a class="reference internal" href="#id350">trace</a></li>
<li><a class="reference internal" href="#id351">vec_val_vect</a></li>
<li><a class="reference internal" href="#vector-norm">vector_norm</a></li>
<li><a class="reference internal" href="#wls-fit-tensor">wls_fit_tensor</a></li>
<li><a class="reference internal" href="#id354"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a></li>
<li><a class="reference internal" href="#forecastfit"><code class="docutils literal notranslate"><span class="pre">ForecastFit</span></code></a></li>
<li><a class="reference internal" href="#forecastmodel"><code class="docutils literal notranslate"><span class="pre">ForecastModel</span></code></a></li>
<li><a class="reference internal" href="#id363"><code class="docutils literal notranslate"><span class="pre">OdfFit</span></code></a></li>
<li><a class="reference internal" href="#id364"><code class="docutils literal notranslate"><span class="pre">OdfModel</span></code></a></li>
<li><a class="reference internal" href="#id365">cart2sphere</a></li>
<li><a class="reference internal" href="#id366">csdeconv</a></li>
<li><a class="reference internal" href="#find-signal-means">find_signal_means</a></li>
<li><a class="reference internal" href="#forecast-error-func">forecast_error_func</a></li>
<li><a class="reference internal" href="#forecast-matrix">forecast_matrix</a></li>
<li><a class="reference internal" href="#id369">get_sphere</a></li>
<li><a class="reference internal" href="#lb-forecast">lb_forecast</a></li>
<li><a class="reference internal" href="#leastsq">leastsq</a></li>
<li><a class="reference internal" href="#id370">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#optional-package">optional_package</a></li>
<li><a class="reference internal" href="#psi-l">psi_l</a></li>
<li><a class="reference internal" href="#id371">real_sph_harm</a></li>
<li><a class="reference internal" href="#rho-matrix">rho_matrix</a></li>
<li><a class="reference internal" href="#warn">warn</a></li>
<li><a class="reference internal" href="#freewatertensorfit"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a></li>
<li><a class="reference internal" href="#freewatertensormodel"><code class="docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a></li>
<li><a class="reference internal" href="#id380"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></li>
<li><a class="reference internal" href="#id381"><code class="docutils literal notranslate"><span class="pre">TensorFit</span></code></a></li>
<li><a class="reference internal" href="#cholesky-to-lower-triangular">cholesky_to_lower_triangular</a></li>
<li><a class="reference internal" href="#id391">decompose_tensor</a></li>
<li><a class="reference internal" href="#id392">design_matrix</a></li>
<li><a class="reference internal" href="#id393">from_lower_triangular</a></li>
<li><a class="reference internal" href="#fwdti-prediction">fwdti_prediction</a></li>
<li><a class="reference internal" href="#id396">lower_triangular</a></li>
<li><a class="reference internal" href="#lower-triangular-to-cholesky">lower_triangular_to_cholesky</a></li>
<li><a class="reference internal" href="#id399">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#id400">ndindex</a></li>
<li><a class="reference internal" href="#nls-fit-tensor">nls_fit_tensor</a></li>
<li><a class="reference internal" href="#nls-iter">nls_iter</a></li>
<li><a class="reference internal" href="#id403">vec_val_vect</a></li>
<li><a class="reference internal" href="#id404">wls_fit_tensor</a></li>
<li><a class="reference internal" href="#wls-iter">wls_iter</a></li>
<li><a class="reference internal" href="#id407"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a></li>
<li><a class="reference internal" href="#generalizedqsamplingfit"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a></li>
<li><a class="reference internal" href="#generalizedqsamplingmodel"><code class="docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a></li>
<li><a class="reference internal" href="#id415"><code class="docutils literal notranslate"><span class="pre">OdfFit</span></code></a></li>
<li><a class="reference internal" href="#id416"><code class="docutils literal notranslate"><span class="pre">OdfModel</span></code></a></li>
<li><a class="reference internal" href="#equatorial-maximum">equatorial_maximum</a></li>
<li><a class="reference internal" href="#equatorial-zone-vertices">equatorial_zone_vertices</a></li>
<li><a class="reference internal" href="#gfa">gfa</a></li>
<li><a class="reference internal" href="#id418">local_maxima</a></li>
<li><a class="reference internal" href="#id419">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#normalize-qa">normalize_qa</a></li>
<li><a class="reference internal" href="#npa">npa</a></li>
<li><a class="reference internal" href="#odf-sum">odf_sum</a></li>
<li><a class="reference internal" href="#patch-maximum">patch_maximum</a></li>
<li><a class="reference internal" href="#patch-sum">patch_sum</a></li>
<li><a class="reference internal" href="#patch-vertices">patch_vertices</a></li>
<li><a class="reference internal" href="#polar-zone-vertices">polar_zone_vertices</a></li>
<li><a class="reference internal" href="#remove-similar-vertices">remove_similar_vertices</a></li>
<li><a class="reference internal" href="#squared-radial-component">squared_radial_component</a></li>
<li><a class="reference internal" href="#triple-odf-maxima">triple_odf_maxima</a></li>
<li><a class="reference internal" href="#upper-hemi-map">upper_hemi_map</a></li>
<li><a class="reference internal" href="#interpolator"><code class="docutils literal notranslate"><span class="pre">Interpolator</span></code></a></li>
<li><a class="reference internal" href="#nearestneighborinterpolator"><code class="docutils literal notranslate"><span class="pre">NearestNeighborInterpolator</span></code></a></li>
<li><a class="reference internal" href="#outsideimage"><code class="docutils literal notranslate"><span class="pre">OutsideImage</span></code></a></li>
<li><a class="reference internal" href="#trilinearinterpolator"><code class="docutils literal notranslate"><span class="pre">TriLinearInterpolator</span></code></a></li>
<li><a class="reference internal" href="#array">array</a></li>
<li><a class="reference internal" href="#trilinear-interp">trilinear_interp</a></li>
<li><a class="reference internal" href="#ivimfit"><code class="docutils literal notranslate"><span class="pre">IvimFit</span></code></a></li>
<li><a class="reference internal" href="#ivimmodel"><code class="docutils literal notranslate"><span class="pre">IvimModel</span></code></a></li>
<li><a class="reference internal" href="#looseversion"><code class="docutils literal notranslate"><span class="pre">LooseVersion</span></code></a></li>
<li><a class="reference internal" href="#id422"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></li>
<li><a class="reference internal" href="#f-d-star-error">f_D_star_error</a></li>
<li><a class="reference internal" href="#f-d-star-prediction">f_D_star_prediction</a></li>
<li><a class="reference internal" href="#ivim-prediction">ivim_prediction</a></li>
<li><a class="reference internal" href="#least-squares">least_squares</a></li>
<li><a class="reference internal" href="#id444">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#id445"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a></li>
<li><a class="reference internal" href="#mapmrifit"><code class="docutils literal notranslate"><span class="pre">MapmriFit</span></code></a></li>
<li><a class="reference internal" href="#mapmrimodel"><code class="docutils literal notranslate"><span class="pre">MapmriModel</span></code></a></li>
<li><a class="reference internal" href="#optimizer"><code class="docutils literal notranslate"><span class="pre">Optimizer</span></code></a></li>
<li><a class="reference internal" href="#id521"><code class="docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></li>
<li><a class="reference internal" href="#id522"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></li>
<li><a class="reference internal" href="#b-mat">b_mat</a></li>
<li><a class="reference internal" href="#b-mat-isotropic">b_mat_isotropic</a></li>
<li><a class="reference internal" href="#binomialfloat">binomialfloat</a></li>
<li><a class="reference internal" href="#id527">cart2sphere</a></li>
<li><a class="reference internal" href="#create-rspace">create_rspace</a></li>
<li><a class="reference internal" href="#delta">delta</a></li>
<li><a class="reference internal" href="#factorial2">factorial2</a></li>
<li><a class="reference internal" href="#gcv-cost-function">gcv_cost_function</a></li>
<li><a class="reference internal" href="#generalized-crossvalidation">generalized_crossvalidation</a></li>
<li><a class="reference internal" href="#generalized-crossvalidation-array">generalized_crossvalidation_array</a></li>
<li><a class="reference internal" href="#genlaguerre">genlaguerre</a></li>
<li><a class="reference internal" href="#id531">gradient_table</a></li>
<li><a class="reference internal" href="#hermite">hermite</a></li>
<li><a class="reference internal" href="#isotropic-scale-factor">isotropic_scale_factor</a></li>
<li><a class="reference internal" href="#map-laplace-s">map_laplace_s</a></li>
<li><a class="reference internal" href="#map-laplace-t">map_laplace_t</a></li>
<li><a class="reference internal" href="#map-laplace-u">map_laplace_u</a></li>
<li><a class="reference internal" href="#mapmri-stu-reg-matrices">mapmri_STU_reg_matrices</a></li>
<li><a class="reference internal" href="#mapmri-index-matrix">mapmri_index_matrix</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-k-mu-dependent">mapmri_isotropic_K_mu_dependent</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-k-mu-independent">mapmri_isotropic_K_mu_independent</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-m-mu-dependent">mapmri_isotropic_M_mu_dependent</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-m-mu-independent">mapmri_isotropic_M_mu_independent</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-index-matrix">mapmri_isotropic_index_matrix</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-laplacian-reg-matrix">mapmri_isotropic_laplacian_reg_matrix</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-laplacian-reg-matrix-from-index-matrix">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-odf-matrix">mapmri_isotropic_odf_matrix</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-odf-sh-matrix">mapmri_isotropic_odf_sh_matrix</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-phi-matrix">mapmri_isotropic_phi_matrix</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-psi-matrix">mapmri_isotropic_psi_matrix</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-radial-pdf-basis">mapmri_isotropic_radial_pdf_basis</a></li>
<li><a class="reference internal" href="#mapmri-isotropic-radial-signal-basis">mapmri_isotropic_radial_signal_basis</a></li>
<li><a class="reference internal" href="#mapmri-laplacian-reg-matrix">mapmri_laplacian_reg_matrix</a></li>
<li><a class="reference internal" href="#mapmri-odf-matrix">mapmri_odf_matrix</a></li>
<li><a class="reference internal" href="#mapmri-phi-1d">mapmri_phi_1d</a></li>
<li><a class="reference internal" href="#mapmri-phi-matrix">mapmri_phi_matrix</a></li>
<li><a class="reference internal" href="#mapmri-psi-1d">mapmri_psi_1d</a></li>
<li><a class="reference internal" href="#mapmri-psi-matrix">mapmri_psi_matrix</a></li>
<li><a class="reference internal" href="#mfactorial">mfactorial</a></li>
<li><a class="reference internal" href="#id579">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#id580">optional_package</a></li>
<li><a class="reference internal" href="#id581">real_sph_harm</a></li>
<li><a class="reference internal" href="#sfactorial">sfactorial</a></li>
<li><a class="reference internal" href="#id582">sph_harm_ind_list</a></li>
<li><a class="reference internal" href="#id583">warn</a></li>
<li><a class="reference internal" href="#callablearray"><code class="docutils literal notranslate"><span class="pre">CallableArray</span></code></a></li>
<li><a class="reference internal" href="#multivoxelfit"><code class="docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a></li>
<li><a class="reference internal" href="#id584"><code class="docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></li>
<li><a class="reference internal" href="#as-strided">as_strided</a></li>
<li><a class="reference internal" href="#id585">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#id586">ndindex</a></li>
<li><a class="reference internal" href="#id587"><code class="docutils literal notranslate"><span class="pre">OdfFit</span></code></a></li>
<li><a class="reference internal" href="#id588"><code class="docutils literal notranslate"><span class="pre">OdfModel</span></code></a></li>
<li><a class="reference internal" href="#id589"><code class="docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></li>
<li><a class="reference internal" href="#id590"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></li>
<li><a class="reference internal" href="#id591">gfa</a></li>
<li><a class="reference internal" href="#minmax-normalize">minmax_normalize</a></li>
<li><a class="reference internal" href="#intemporarydirectory"><code class="docutils literal notranslate"><span class="pre">InTemporaryDirectory</span></code></a></li>
<li><a class="reference internal" href="#peaksandmetrics"><code class="docutils literal notranslate"><span class="pre">PeaksAndMetrics</span></code></a></li>
<li><a class="reference internal" href="#peaksandmetricsdirectiongetter"><code class="docutils literal notranslate"><span class="pre">PeaksAndMetricsDirectionGetter</span></code></a></li>
<li><a class="reference internal" href="#sphere"><code class="docutils literal notranslate"><span class="pre">Sphere</span></code></a></li>
<li><a class="reference internal" href="#repeat"><code class="docutils literal notranslate"><span class="pre">repeat</span></code></a></li>
<li><a class="reference internal" href="#xrange"><code class="docutils literal notranslate"><span class="pre">xrange</span></code></a></li>
<li><a class="reference internal" href="#pool">Pool</a></li>
<li><a class="reference internal" href="#cpu-count">cpu_count</a></li>
<li><a class="reference internal" href="#id593">gfa</a></li>
<li><a class="reference internal" href="#id595">local_maxima</a></li>
<li><a class="reference internal" href="#id596">ndindex</a></li>
<li><a class="reference internal" href="#peak-directions">peak_directions</a></li>
<li><a class="reference internal" href="#peak-directions-nl">peak_directions_nl</a></li>
<li><a class="reference internal" href="#id597">peaks_from_model</a></li>
<li><a class="reference internal" href="#id602">remove_similar_vertices</a></li>
<li><a class="reference internal" href="#reshape-peaks-for-visualization">reshape_peaks_for_visualization</a></li>
<li><a class="reference internal" href="#search-descending">search_descending</a></li>
<li><a class="reference internal" href="#sh-to-sf-matrix">sh_to_sf_matrix</a></li>
<li><a class="reference internal" href="#id607">warn</a></li>
<li><a class="reference internal" href="#id608"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a></li>
<li><a class="reference internal" href="#qtdmrifit"><code class="docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a></li>
<li><a class="reference internal" href="#qtdmrimodel"><code class="docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a></li>
<li><a class="reference internal" href="#id657">GCV_cost_function</a></li>
<li><a class="reference internal" href="#h">H</a></li>
<li><a class="reference internal" href="#angular-basis-eap-opt">angular_basis_EAP_opt</a></li>
<li><a class="reference internal" href="#angular-basis-opt">angular_basis_opt</a></li>
<li><a class="reference internal" href="#id659">cart2sphere</a></li>
<li><a class="reference internal" href="#create-rt-space-grid">create_rt_space_grid</a></li>
<li><a class="reference internal" href="#design-matrix-spatial">design_matrix_spatial</a></li>
<li><a class="reference internal" href="#elastic-crossvalidation">elastic_crossvalidation</a></li>
<li><a class="reference internal" href="#factorial">factorial</a></li>
<li><a class="reference internal" href="#id660">factorial2</a></li>
<li><a class="reference internal" href="#fmin-l-bfgs-b">fmin_l_bfgs_b</a></li>
<li><a class="reference internal" href="#id661">generalized_crossvalidation</a></li>
<li><a class="reference internal" href="#id663">genlaguerre</a></li>
<li><a class="reference internal" href="#gradient-table-from-gradient-strength-bvecs">gradient_table_from_gradient_strength_bvecs</a></li>
<li><a class="reference internal" href="#l1-crossvalidation">l1_crossvalidation</a></li>
<li><a class="reference internal" href="#id664">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#id665">optional_package</a></li>
<li><a class="reference internal" href="#part1-reg-matrix-tau">part1_reg_matrix_tau</a></li>
<li><a class="reference internal" href="#part23-iso-reg-matrix-q">part23_iso_reg_matrix_q</a></li>
<li><a class="reference internal" href="#part23-reg-matrix-q">part23_reg_matrix_q</a></li>
<li><a class="reference internal" href="#part23-reg-matrix-tau">part23_reg_matrix_tau</a></li>
<li><a class="reference internal" href="#part4-iso-reg-matrix-q">part4_iso_reg_matrix_q</a></li>
<li><a class="reference internal" href="#part4-reg-matrix-q">part4_reg_matrix_q</a></li>
<li><a class="reference internal" href="#part4-reg-matrix-tau">part4_reg_matrix_tau</a></li>
<li><a class="reference internal" href="#qtdmri-anisotropic-scaling">qtdmri_anisotropic_scaling</a></li>
<li><a class="reference internal" href="#qtdmri-eap-matrix">qtdmri_eap_matrix</a></li>
<li><a class="reference internal" href="#id673">qtdmri_eap_matrix_</a></li>
<li><a class="reference internal" href="#qtdmri-index-matrix">qtdmri_index_matrix</a></li>
<li><a class="reference internal" href="#qtdmri-isotropic-eap-matrix">qtdmri_isotropic_eap_matrix</a></li>
<li><a class="reference internal" href="#id674">qtdmri_isotropic_eap_matrix_</a></li>
<li><a class="reference internal" href="#qtdmri-isotropic-index-matrix">qtdmri_isotropic_index_matrix</a></li>
<li><a class="reference internal" href="#qtdmri-isotropic-laplacian-reg-matrix">qtdmri_isotropic_laplacian_reg_matrix</a></li>
<li><a class="reference internal" href="#qtdmri-isotropic-scaling">qtdmri_isotropic_scaling</a></li>
<li><a class="reference internal" href="#qtdmri-isotropic-signal-matrix">qtdmri_isotropic_signal_matrix</a></li>
<li><a class="reference internal" href="#id676">qtdmri_isotropic_signal_matrix_</a></li>
<li><a class="reference internal" href="#qtdmri-isotropic-to-mapmri-matrix">qtdmri_isotropic_to_mapmri_matrix</a></li>
<li><a class="reference internal" href="#qtdmri-laplacian-reg-matrix">qtdmri_laplacian_reg_matrix</a></li>
<li><a class="reference internal" href="#qtdmri-mapmri-isotropic-normalization">qtdmri_mapmri_isotropic_normalization</a></li>
<li><a class="reference internal" href="#qtdmri-mapmri-normalization">qtdmri_mapmri_normalization</a></li>
<li><a class="reference internal" href="#qtdmri-number-of-coefficients">qtdmri_number_of_coefficients</a></li>
<li><a class="reference internal" href="#qtdmri-signal-matrix">qtdmri_signal_matrix</a></li>
<li><a class="reference internal" href="#id680">qtdmri_signal_matrix_</a></li>
<li><a class="reference internal" href="#qtdmri-temporal-normalization">qtdmri_temporal_normalization</a></li>
<li><a class="reference internal" href="#qtdmri-to-mapmri-matrix">qtdmri_to_mapmri_matrix</a></li>
<li><a class="reference internal" href="#radial-basis-eap-opt">radial_basis_EAP_opt</a></li>
<li><a class="reference internal" href="#radial-basis-opt">radial_basis_opt</a></li>
<li><a class="reference internal" href="#id682">real_sph_harm</a></li>
<li><a class="reference internal" href="#temporal-basis">temporal_basis</a></li>
<li><a class="reference internal" href="#visualise-gradient-table-g-delta-rainbow">visualise_gradient_table_G_Delta_rainbow</a></li>
<li><a class="reference internal" href="#id683">warn</a></li>
<li><a class="reference internal" href="#id684"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a></li>
<li><a class="reference internal" href="#exponentialisotropicfit"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a></li>
<li><a class="reference internal" href="#exponentialisotropicmodel"><code class="docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a></li>
<li><a class="reference internal" href="#isotropicfit"><code class="docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a></li>
<li><a class="reference internal" href="#isotropicmodel"><code class="docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a></li>
<li><a class="reference internal" href="#id685"><code class="docutils literal notranslate"><span class="pre">ReconstFit</span></code></a></li>
<li><a class="reference internal" href="#id686"><code class="docutils literal notranslate"><span class="pre">ReconstModel</span></code></a></li>
<li><a class="reference internal" href="#sparsefasciclefit"><code class="docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a></li>
<li><a class="reference internal" href="#sparsefasciclemodel"><code class="docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a></li>
<li><a class="reference internal" href="#id690">auto_attr</a></li>
<li><a class="reference internal" href="#nanmean">nanmean</a></li>
<li><a class="reference internal" href="#id691">optional_package</a></li>
<li><a class="reference internal" href="#sfm-design-matrix">sfm_design_matrix</a></li>
<li><a class="reference internal" href="#id694"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a></li>
<li><a class="reference internal" href="#csaodfmodel"><code class="docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a></li>
<li><a class="reference internal" href="#id696"><code class="docutils literal notranslate"><span class="pre">LooseVersion</span></code></a></li>
<li><a class="reference internal" href="#id697"><code class="docutils literal notranslate"><span class="pre">OdfFit</span></code></a></li>
<li><a class="reference internal" href="#id698"><code class="docutils literal notranslate"><span class="pre">OdfModel</span></code></a></li>
<li><a class="reference internal" href="#opdtmodel"><code class="docutils literal notranslate"><span class="pre">OpdtModel</span></code></a></li>
<li><a class="reference internal" href="#qballbasemodel"><code class="docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a></li>
<li><a class="reference internal" href="#qballmodel"><code class="docutils literal notranslate"><span class="pre">QballModel</span></code></a></li>
<li><a class="reference internal" href="#residualbootstrapwrapper"><code class="docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a></li>
<li><a class="reference internal" href="#id702"><code class="docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a></li>
<li><a class="reference internal" href="#id703"><code class="docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a></li>
<li><a class="reference internal" href="#anisotropic-power">anisotropic_power</a></li>
<li><a class="reference internal" href="#id706">auto_attr</a></li>
<li><a class="reference internal" href="#bootstrap-data-array">bootstrap_data_array</a></li>
<li><a class="reference internal" href="#bootstrap-data-voxel">bootstrap_data_voxel</a></li>
<li><a class="reference internal" href="#calculate-max-order">calculate_max_order</a></li>
<li><a class="reference internal" href="#id710">cart2sphere</a></li>
<li><a class="reference internal" href="#concatenate">concatenate</a></li>
<li><a class="reference internal" href="#diag">diag</a></li>
<li><a class="reference internal" href="#diff">diff</a></li>
<li><a class="reference internal" href="#dot">dot</a></li>
<li><a class="reference internal" href="#empty">empty</a></li>
<li><a class="reference internal" href="#eye">eye</a></li>
<li><a class="reference internal" href="#id711">forward_sdeconv_mat</a></li>
<li><a class="reference internal" href="#gen-dirac">gen_dirac</a></li>
<li><a class="reference internal" href="#hat">hat</a></li>
<li><a class="reference internal" href="#id712">lazy_index</a></li>
<li><a class="reference internal" href="#lcr-matrix">lcr_matrix</a></li>
<li><a class="reference internal" href="#id713">lpn</a></li>
<li><a class="reference internal" href="#normalize-data">normalize_data</a></li>
<li><a class="reference internal" href="#order-from-ncoef">order_from_ncoef</a></li>
<li><a class="reference internal" href="#id715">pinv</a></li>
<li><a class="reference internal" href="#randint">randint</a></li>
<li><a class="reference internal" href="#id718">real_sph_harm</a></li>
<li><a class="reference internal" href="#id719">real_sym_sh_basis</a></li>
<li><a class="reference internal" href="#real-sym-sh-mrtrix">real_sym_sh_mrtrix</a></li>
<li><a class="reference internal" href="#sf-to-sh">sf_to_sh</a></li>
<li><a class="reference internal" href="#id731">sh_to_rh</a></li>
<li><a class="reference internal" href="#sh-to-sf">sh_to_sf</a></li>
<li><a class="reference internal" href="#id737">sh_to_sf_matrix</a></li>
<li><a class="reference internal" href="#smooth-pinv">smooth_pinv</a></li>
<li><a class="reference internal" href="#id742">sph_harm_ind_list</a></li>
<li><a class="reference internal" href="#spherical-harmonics">spherical_harmonics</a></li>
<li><a class="reference internal" href="#svd">svd</a></li>
<li><a class="reference internal" href="#unique">unique</a></li>
<li><a class="reference internal" href="#id743"><code class="docutils literal notranslate"><span class="pre">Cache</span></code></a></li>
<li><a class="reference internal" href="#shorefit"><code class="docutils literal notranslate"><span class="pre">ShoreFit</span></code></a></li>
<li><a class="reference internal" href="#shoremodel"><code class="docutils literal notranslate"><span class="pre">ShoreModel</span></code></a></li>
<li><a class="reference internal" href="#id765">cart2sphere</a></li>
<li><a class="reference internal" href="#id766">create_rspace</a></li>
<li><a class="reference internal" href="#id767">factorial</a></li>
<li><a class="reference internal" href="#id768">genlaguerre</a></li>
<li><a class="reference internal" href="#l-shore">l_shore</a></li>
<li><a class="reference internal" href="#id769">multi_voxel_fit</a></li>
<li><a class="reference internal" href="#n-shore">n_shore</a></li>
<li><a class="reference internal" href="#id770">optional_package</a></li>
<li><a class="reference internal" href="#id771">real_sph_harm</a></li>
<li><a class="reference internal" href="#shore-indices">shore_indices</a></li>
<li><a class="reference internal" href="#shore-matrix">shore_matrix</a></li>
<li><a class="reference internal" href="#shore-matrix-odf">shore_matrix_odf</a></li>
<li><a class="reference internal" href="#shore-matrix-pdf">shore_matrix_pdf</a></li>
<li><a class="reference internal" href="#shore-order">shore_order</a></li>
<li><a class="reference internal" href="#id778">warn</a></li>
<li><a class="reference internal" href="#dki-design-matrix">dki_design_matrix</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/dipy.reconst.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dipy.reconst">
<span id="reconst"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst</span></code><a class="headerlink" href="#module-dipy.reconst" title="Permalink to this headline"></a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.bench" title="dipy.reconst.bench"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench</span></code></a></td>
<td>Run benchmarks for module using nose.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.test" title="dipy.reconst.test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test</span></code></a></td>
<td>Run tests for module using nose.</td>
</tr>
</tbody>
</table>
<div class="section" id="module-dipy.reconst.base">
<span id="module-reconst-base"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.base</span></code><a class="headerlink" href="#module-dipy.reconst.base" title="Permalink to this headline"></a></h2>
<p>Base-classes for reconstruction models and reconstruction fits.</p>
<p>All the models in the reconst module follow the same template: a Model object
is used to represent the abstract properties of the model, that are independent
of the specifics of the data . These properties are reused whenver fitting a
particular set of data (different voxels, for example).</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstFit</span></code></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks">
<span id="module-reconst-benchmarks"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_bounding_box">
<span id="module-reconst-benchmarks-bench-bounding-box"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_bounding_box</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_bounding_box" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box" title="dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_bounding_box</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_bounding_box.bounding_box" title="dipy.reconst.benchmarks.bench_bounding_box.bounding_box"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></a>(vol)</td>
<td>Compute the bounding box of nonzero intensity voxels in the volume.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_bounding_box.measure" title="dipy.reconst.benchmarks.bench_bounding_box.measure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">measure</span></code></a>(code_str[,&nbsp;times,&nbsp;label])</td>
<td>Return elapsed time for executing code in the namespace of the caller.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_csd">
<span id="module-reconst-benchmarks-bench-csd"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_csd</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_csd" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel" title="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a>(gtab,&nbsp;response)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable" title="dipy.reconst.benchmarks.bench_csd.GradientTable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GradientTable</span></code></a>(gradients[,&nbsp;big_delta,&nbsp;])</td>
<td>Diffusion gradient information</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.bench_csdeconv" title="dipy.reconst.benchmarks.bench_csd.bench_csdeconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_csdeconv</span></code></a>([center,&nbsp;width])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.num_grad" title="dipy.reconst.benchmarks.bench_csd.num_grad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_grad</span></code></a>(gtab)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.read_stanford_labels" title="dipy.reconst.benchmarks.bench_csd.read_stanford_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_stanford_labels</span></code></a>()</td>
<td>Read stanford hardi data and label map</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_peaks">
<span id="module-reconst-benchmarks-bench-peaks"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_peaks</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_peaks" title="Permalink to this headline"></a></h2>
<p>Benchmarks for peak finding</p>
<p>Run all benchmarks with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="k">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>If you have doctests enabled by default in nose (with a noserc file or
environment variable), and you have a numpy version &lt;= 1.6.1, this will also
run the doctests, lets hope they pass.</p>
<p>Run this benchmark with:</p>
<blockquote>
<div>nosetests -s match (?:^|[b_.//-])[Bb]ench /path/to/bench_peaks.py</div></blockquote>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.bench_local_maxima" title="dipy.reconst.benchmarks.bench_peaks.bench_local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_local_maxima</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.get_sphere" title="dipy.reconst.benchmarks.bench_peaks.get_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sphere</span></code></a>([name])</td>
<td>provide triangulated spheres</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.local_maxima" title="dipy.reconst.benchmarks.bench_peaks.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">local_maxima</span></code></a></td>
<td>Local maxima of a function evaluated on a discrete set of points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.measure" title="dipy.reconst.benchmarks.bench_peaks.measure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">measure</span></code></a>(code_str[,&nbsp;times,&nbsp;label])</td>
<td>Return elapsed time for executing code in the namespace of the caller.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_peaks.unique_edges" title="dipy.reconst.benchmarks.bench_peaks.unique_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique_edges</span></code></a>(faces[,&nbsp;return_mapping])</td>
<td>Extract all unique edges from given triangular faces.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_squash">
<span id="module-reconst-benchmarks-bench-squash"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_squash</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_squash" title="Permalink to this headline"></a></h2>
<p>Benchmarks for fast squashing</p>
<p>Run all benchmarks with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="k">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>If you have doctests enabled by default in nose (with a noserc file or
environment variable), and you have a numpy version &lt;= 1.6.1, this will also
run the doctests, lets hope they pass.</p>
<p>Run this benchmark with:</p>
<blockquote>
<div>nosetests -s match (?:^|[b_.//-])[Bb]ench /path/to/bench_squash.py</div></blockquote>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.bench_quick_squash" title="dipy.reconst.benchmarks.bench_squash.bench_quick_squash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_quick_squash</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.measure" title="dipy.reconst.benchmarks.bench_squash.measure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">measure</span></code></a>(code_str[,&nbsp;times,&nbsp;label])</td>
<td>Return elapsed time for executing code in the namespace of the caller.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.ndindex" title="dipy.reconst.benchmarks.bench_squash.ndindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex</span></code></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.old_squash" title="dipy.reconst.benchmarks.bench_squash.old_squash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">old_squash</span></code></a>(arr[,&nbsp;mask,&nbsp;fill])</td>
<td>Try and make a standard array from an object array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.quick_squash" title="dipy.reconst.benchmarks.bench_squash.quick_squash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quick_squash</span></code></a></td>
<td>Try and make a standard array from an object array</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_squash.reduce" title="dipy.reconst.benchmarks.bench_squash.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce</span></code></a>(function,&nbsp;sequence[,&nbsp;initial])</td>
<td>Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.benchmarks.bench_vec_val_sum">
<span id="module-reconst-benchmarks-bench-vec-val-sum"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.benchmarks.bench_vec_val_sum</span></code><a class="headerlink" href="#module-dipy.reconst.benchmarks.bench_vec_val_sum" title="Permalink to this headline"></a></h2>
<p>Benchmarks for vec / val summation routine</p>
<p>Run benchmarks with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dipy.reconst</span> <span class="k">as</span> <span class="nn">dire</span>
<span class="n">dire</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span>
</pre></div>
</div>
<p>If you have doctests enabled by default in nose (with a noserc file or
environment variable), and you have a numpy version &lt;= 1.6.1, this will also
run the doctests, lets hope they pass.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect" title="dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench_vec_val_vect</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.measure" title="dipy.reconst.benchmarks.bench_vec_val_sum.measure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">measure</span></code></a>(code_str[,&nbsp;times,&nbsp;label])</td>
<td>Return elapsed time for executing code in the namespace of the caller.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.randn" title="dipy.reconst.benchmarks.bench_vec_val_sum.randn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randn</span></code></a>(d0,&nbsp;d1,&nbsp;,&nbsp;dn)</td>
<td>Return a sample (or samples) from the standard normal distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect" title="dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vec_val_vect</span></code></a></td>
<td>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_vec_val_sum.with_einsum" title="dipy.reconst.benchmarks.bench_vec_val_sum.with_einsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">with_einsum</span></code></a>(f)</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.cache">
<span id="module-reconst-cache"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cache</span></code><a class="headerlink" href="#module-dipy.reconst.cache" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.cache.auto_attr" title="dipy.reconst.cache.auto_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_attr</span></code></a>(func)</td>
<td>Decorator to create OneTimeProperty attributes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.cross_validation">
<span id="module-reconst-cross-validation"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.cross_validation</span></code><a class="headerlink" href="#module-dipy.reconst.cross_validation" title="Permalink to this headline"></a></h2>
<p>Cross-validation analysis of diffusion models</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cross_validation.range" title="dipy.reconst.cross_validation.range"><code class="xref py py-obj docutils literal notranslate"><span class="pre">range</span></code></a>(stop)</td>
<td>range(start, stop[, step]) -&gt; range object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.cross_validation.coeff_of_determination" title="dipy.reconst.cross_validation.coeff_of_determination"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coeff_of_determination</span></code></a>(data,&nbsp;model[,&nbsp;axis])</td>
<td>Calculate the coefficient of determination for a model prediction, relative</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cross_validation.kfold_xval" title="dipy.reconst.cross_validation.kfold_xval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kfold_xval</span></code></a>(model,&nbsp;data,&nbsp;folds,&nbsp;*model_args,&nbsp;)</td>
<td>Perform k-fold cross-validation to generate out-of-sample predictions for each measurement.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.csdeconv">
<span id="module-reconst-csdeconv"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.csdeconv</span></code><a class="headerlink" href="#module-dipy.reconst.csdeconv" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse" title="dipy.reconst.csdeconv.AxSymShResponse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a>(S0,&nbsp;dwi_response[,&nbsp;bvalue])</td>
<td>A simple wrapper for response functions represented using only axially symmetric, even spherical harmonic functions (ie, m == 0 and n even).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="dipy.reconst.csdeconv.ConstrainedSDTModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a>(gtab,&nbsp;ratio[,&nbsp;])</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a>(gtab,&nbsp;response)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit" title="dipy.reconst.csdeconv.SphHarmFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a>(model,&nbsp;shm_coef,&nbsp;mask)</td>
<td>Diffusion data fit to a spherical harmonic model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmModel" title="dipy.reconst.csdeconv.SphHarmModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a>(gtab)</td>
<td>To be subclassed by all models that return a SphHarmFit when fit.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.TensorModel" title="dipy.reconst.csdeconv.TensorModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorModel</span></code></a>(gtab[,&nbsp;fit_method,&nbsp;return_S0_hat])</td>
<td>Diffusion Tensor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.range" title="dipy.reconst.csdeconv.range"><code class="xref py py-obj docutils literal notranslate"><span class="pre">range</span></code></a>(stop)</td>
<td>range(start, stop[, step]) -&gt; range object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.auto_response" title="dipy.reconst.csdeconv.auto_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_response</span></code></a>(gtab,&nbsp;data[,&nbsp;roi_center,&nbsp;])</td>
<td>Automatic estimation of response function using FA.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.cart2sphere" title="dipy.reconst.csdeconv.cart2sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart2sphere</span></code></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.csdeconv" title="dipy.reconst.csdeconv.csdeconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csdeconv</span></code></a>(dwsignal,&nbsp;X,&nbsp;B_reg[,&nbsp;tau,&nbsp;])</td>
<td>Constrained-regularized spherical deconvolution (CSD) <a class="reference internal" href="#r537fd66f8bb4-1" id="id1">[1]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.estimate_response" title="dipy.reconst.csdeconv.estimate_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_response</span></code></a>(gtab,&nbsp;evals,&nbsp;S0)</td>
<td>Estimate single fiber response function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.fa_inferior" title="dipy.reconst.csdeconv.fa_inferior"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa_inferior</span></code></a>(FA,&nbsp;fa_thr)</td>
<td>Check that the FA is lower than the FA threshold</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.fa_superior" title="dipy.reconst.csdeconv.fa_superior"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa_superior</span></code></a>(FA,&nbsp;fa_thr)</td>
<td>Check that the FA is greater than the FA threshold</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas" title="dipy.reconst.csdeconv.fa_trace_to_lambdas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa_trace_to_lambdas</span></code></a>([fa,&nbsp;trace])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.forward_sdeconv_mat" title="dipy.reconst.csdeconv.forward_sdeconv_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward_sdeconv_mat</span></code></a>(r_rh,&nbsp;n)</td>
<td>Build forward spherical deconvolution matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat" title="dipy.reconst.csdeconv.forward_sdt_deconv_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward_sdt_deconv_mat</span></code></a>(ratio,&nbsp;n[,&nbsp;r2_term])</td>
<td>Build forward sharpening deconvolution transform (SDT) matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.fractional_anisotropy" title="dipy.reconst.csdeconv.fractional_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractional_anisotropy</span></code></a>(evals[,&nbsp;axis])</td>
<td>Fractional anisotropy (FA) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.get_sphere" title="dipy.reconst.csdeconv.get_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sphere</span></code></a>([name])</td>
<td>provide triangulated spheres</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.lazy_index" title="dipy.reconst.csdeconv.lazy_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lazy_index</span></code></a>(index)</td>
<td>Produces a lazy index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.lpn" title="dipy.reconst.csdeconv.lpn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lpn</span></code></a>(n,&nbsp;z)</td>
<td>Legendre function of the first kind.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.multi_voxel_fit" title="dipy.reconst.csdeconv.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ndindex" title="dipy.reconst.csdeconv.ndindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex</span></code></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.odf_deconv" title="dipy.reconst.csdeconv.odf_deconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_deconv</span></code></a>(odf_sh,&nbsp;R,&nbsp;B_reg[,&nbsp;lambda_,&nbsp;tau,&nbsp;])</td>
<td>ODF constrained-regularized spherical deconvolution using the Sharpening Deconvolution Transform (SDT) <a class="reference internal" href="#ra707a2933099-1" id="id2">[1]</a>, <a class="reference internal" href="#ra707a2933099-2" id="id3">[2]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.odf_sh_to_sharp" title="dipy.reconst.csdeconv.odf_sh_to_sharp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sh_to_sharp</span></code></a>(odfs_sh,&nbsp;sphere[,&nbsp;basis,&nbsp;])</td>
<td>Sharpen odfs using the sharpening deconvolution transform <a class="reference internal" href="#rc713c9e45b9d-2" id="id4">[2]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.peaks_from_model" title="dipy.reconst.csdeconv.peaks_from_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">peaks_from_model</span></code></a>(model,&nbsp;data,&nbsp;sphere,&nbsp;[,&nbsp;])</td>
<td>Fit the model to data and computes peaks and metrics</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.quad" title="dipy.reconst.csdeconv.quad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quad</span></code></a>(func,&nbsp;a,&nbsp;b[,&nbsp;args,&nbsp;full_output,&nbsp;])</td>
<td>Compute a definite integral.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.real_sph_harm" title="dipy.reconst.csdeconv.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.real_sym_sh_basis" title="dipy.reconst.csdeconv.real_sym_sh_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sym_sh_basis</span></code></a>(sh_order,&nbsp;theta,&nbsp;phi)</td>
<td>Samples a real symmetric spherical harmonic basis at point on the sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.recursive_response" title="dipy.reconst.csdeconv.recursive_response"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recursive_response</span></code></a>(gtab,&nbsp;data[,&nbsp;mask,&nbsp;])</td>
<td>Recursive calibration of response function using peak threshold</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.response_from_mask" title="dipy.reconst.csdeconv.response_from_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">response_from_mask</span></code></a>(gtab,&nbsp;data,&nbsp;mask)</td>
<td>Estimate the response function from a given mask.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.sh_to_rh" title="dipy.reconst.csdeconv.sh_to_rh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_rh</span></code></a>(r_sh,&nbsp;m,&nbsp;n)</td>
<td>Spherical harmonics (SH) to rotational harmonics (RH)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.single_tensor" title="dipy.reconst.csdeconv.single_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">single_tensor</span></code></a>(gtab[,&nbsp;S0,&nbsp;evals,&nbsp;evecs,&nbsp;snr])</td>
<td>Simulated Q-space signal with a single tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.sph_harm_ind_list" title="dipy.reconst.csdeconv.sph_harm_ind_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sph_harm_ind_list</span></code></a>(sh_order)</td>
<td>Returns the degree (n) and order (m) of all the symmetric spherical harmonics of degree less then or equal to <cite>sh_order</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.vec2vec_rotmat" title="dipy.reconst.csdeconv.vec2vec_rotmat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vec2vec_rotmat</span></code></a>(u,&nbsp;v)</td>
<td>rotation matrix from 2 unit vectors</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.dki">
<span id="module-reconst-dki"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki</span></code><a class="headerlink" href="#module-dipy.reconst.dki" title="Permalink to this headline"></a></h2>
<p>Classes and functions for fitting the diffusion kurtosis model</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a>(model,&nbsp;model_params)</td>
<td>Class for fitting the Diffusion Kurtosis Model</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="dipy.reconst.dki.DiffusionKurtosisModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a>(gtab[,&nbsp;fit_method])</td>
<td>Class for the Diffusion Kurtosis Model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.ReconstModel" title="dipy.reconst.dki.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit" title="dipy.reconst.dki.TensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorFit</span></code></a>(model,&nbsp;model_params[,&nbsp;model_S0])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.range" title="dipy.reconst.dki.range"><code class="xref py py-obj docutils literal notranslate"><span class="pre">range</span></code></a>(stop)</td>
<td>range(start, stop[, step]) -&gt; range object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.Wcons" title="dipy.reconst.dki.Wcons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wcons</span></code></a>(k_elements)</td>
<td>Construct the full 4D kurtosis tensors from its 15 independent elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.Wrotate" title="dipy.reconst.dki.Wrotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wrotate</span></code></a>(kt,&nbsp;Basis)</td>
<td>Rotate a kurtosis tensor from the standard Cartesian coordinate system to another coordinate system basis</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.Wrotate_element" title="dipy.reconst.dki.Wrotate_element"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Wrotate_element</span></code></a>(kt,&nbsp;indi,&nbsp;indj,&nbsp;indk,&nbsp;indl,&nbsp;B)</td>
<td>Computes the the specified index element of a kurtosis tensor rotated to the coordinate system basis B.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.apparent_kurtosis_coef" title="dipy.reconst.dki.apparent_kurtosis_coef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apparent_kurtosis_coef</span></code></a>(dki_params,&nbsp;sphere[,&nbsp;])</td>
<td>Calculates the apparent kurtosis coefficient (AKC) in each direction of a sphere <a class="reference internal" href="#r1b3e9922dec3-1" id="id5">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.axial_kurtosis" title="dipy.reconst.dki.axial_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axial_kurtosis</span></code></a>(dki_params[,&nbsp;min_kurtosis,&nbsp;])</td>
<td>Computes axial Kurtosis (AK) from the kurtosis tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.carlson_rd" title="dipy.reconst.dki.carlson_rd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">carlson_rd</span></code></a>(x,&nbsp;y,&nbsp;z[,&nbsp;errtol])</td>
<td>Computes the Carlsons incomplete elliptic integral of the second kind defined as:</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.carlson_rf" title="dipy.reconst.dki.carlson_rf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">carlson_rf</span></code></a>(x,&nbsp;y,&nbsp;z[,&nbsp;errtol])</td>
<td>Computes the Carlsons incomplete elliptic integral of the first kind defined as:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.cart2sphere" title="dipy.reconst.dki.cart2sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart2sphere</span></code></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.check_multi_b" title="dipy.reconst.dki.check_multi_b"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_multi_b</span></code></a>(gtab,&nbsp;n_bvals[,&nbsp;non_zero,&nbsp;bmag])</td>
<td>Check if you have enough different b-values in your gradient table</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.decompose_tensor" title="dipy.reconst.dki.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a>(tensor[,&nbsp;min_diffusivity])</td>
<td>Returns eigenvalues and eigenvectors given a diffusion tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.design_matrix" title="dipy.reconst.dki.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>(gtab)</td>
<td>Constructs B design matrix for DKI</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.directional_diffusion" title="dipy.reconst.dki.directional_diffusion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_diffusion</span></code></a>(dt,&nbsp;V[,&nbsp;min_diffusivity])</td>
<td>Calculates the apparent diffusion coefficient (adc) in each direction of a sphere for a single voxel <a class="reference internal" href="#r62a8a421f533-1" id="id6">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.directional_diffusion_variance" title="dipy.reconst.dki.directional_diffusion_variance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_diffusion_variance</span></code></a>(kt,&nbsp;V[,&nbsp;])</td>
<td>Calculates the apparent diffusion variance (adv) in each direction of a sphere for a single voxel <a class="reference internal" href="#r87e53edeef9c-1" id="id7">[1]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.directional_kurtosis" title="dipy.reconst.dki.directional_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_kurtosis</span></code></a>(dt,&nbsp;md,&nbsp;kt,&nbsp;V[,&nbsp;])</td>
<td>Calculates the apparent kurtosis coefficient (akc) in each direction of a sphere for a single voxel <a class="reference internal" href="#ra6181896282f-1" id="id8">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.dki_prediction" title="dipy.reconst.dki.dki_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dki_prediction</span></code></a>(dki_params,&nbsp;gtab[,&nbsp;S0])</td>
<td>Predict a signal given diffusion kurtosis imaging parameters.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.from_lower_triangular" title="dipy.reconst.dki.from_lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_lower_triangular</span></code></a>(D)</td>
<td>Returns a tensor given the six unique tensor elements</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.get_sphere" title="dipy.reconst.dki.get_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sphere</span></code></a>([name])</td>
<td>provide triangulated spheres</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.kurtosis_maximum" title="dipy.reconst.dki.kurtosis_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis_maximum</span></code></a>(dki_params[,&nbsp;sphere,&nbsp;gtol,&nbsp;])</td>
<td>Computes kurtosis maximum value</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.local_maxima" title="dipy.reconst.dki.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">local_maxima</span></code></a></td>
<td>Local maxima of a function evaluated on a discrete set of points.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.lower_triangular" title="dipy.reconst.dki.lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_triangular</span></code></a>(tensor[,&nbsp;b0])</td>
<td>Returns the six lower triangular values of the tensor and a dummy variable if b0 is not None</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.mean_diffusivity" title="dipy.reconst.dki.mean_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_diffusivity</span></code></a>(evals[,&nbsp;axis])</td>
<td>Mean Diffusivity (MD) of a diffusion tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.mean_kurtosis" title="dipy.reconst.dki.mean_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_kurtosis</span></code></a>(dki_params[,&nbsp;min_kurtosis,&nbsp;])</td>
<td>Computes mean Kurtosis (MK) from the kurtosis tensor <a class="reference internal" href="#r953e26c55b6a-1" id="id9">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.ndindex" title="dipy.reconst.dki.ndindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex</span></code></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.ols_fit_dki" title="dipy.reconst.dki.ols_fit_dki"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ols_fit_dki</span></code></a>(design_matrix,&nbsp;data)</td>
<td>Computes ordinary least squares (OLS) fit to calculate the diffusion tensor and kurtosis tensor using a linear regression diffusion kurtosis model <a class="footnote-reference" href="#id344" id="id10">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.radial_kurtosis" title="dipy.reconst.dki.radial_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_kurtosis</span></code></a>(dki_params[,&nbsp;min_kurtosis,&nbsp;])</td>
<td>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class="reference internal" href="#r7cf9df14e56e-1" id="id11">[1]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.sphere2cart" title="dipy.reconst.dki.sphere2cart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphere2cart</span></code></a>(r,&nbsp;theta,&nbsp;phi)</td>
<td>Spherical to Cartesian coordinates</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.split_dki_param" title="dipy.reconst.dki.split_dki_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_dki_param</span></code></a>(dki_params)</td>
<td>Extract the diffusion tensor eigenvalues, the diffusion tensor eigenvector matrix, and the 15 independent elements of the kurtosis tensor from the model parameters estimated from the DKI model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.vec_val_vect" title="dipy.reconst.dki.vec_val_vect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vec_val_vect</span></code></a></td>
<td>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.wls_fit_dki" title="dipy.reconst.dki.wls_fit_dki"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_dki</span></code></a>(design_matrix,&nbsp;data)</td>
<td>Computes weighted linear least squares (WLS) fit to calculate the diffusion tensor and kurtosis tensor using a weighted linear regression diffusion kurtosis model <a class="footnote-reference" href="#id344" id="id12">[1]</a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.dki_micro">
<span id="module-reconst-dki-micro"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dki_micro</span></code><a class="headerlink" href="#module-dipy.reconst.dki_micro" title="Permalink to this headline"></a></h2>
<p>Classes and functions for fitting the DKI-based microstructural model</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit" title="dipy.reconst.dki_micro.DiffusionKurtosisFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a>(model,&nbsp;model_params)</td>
<td>Class for fitting the Diffusion Kurtosis Model</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisModel" title="dipy.reconst.dki_micro.DiffusionKurtosisModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a>(gtab[,&nbsp;fit_method])</td>
<td>Class for the Diffusion Kurtosis Model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a>(model,&nbsp;model_params)</td>
<td>Class for fitting the Diffusion Kurtosis Microstructural Model</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a>(gtab[,&nbsp;fit_method])</td>
<td>Class for the Diffusion Kurtosis Microstructural Model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.axial_diffusivity" title="dipy.reconst.dki_micro.axial_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axial_diffusivity</span></code></a>(evals[,&nbsp;axis])</td>
<td>Axial Diffusivity (AD) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.axonal_water_fraction" title="dipy.reconst.dki_micro.axonal_water_fraction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axonal_water_fraction</span></code></a>(dki_params[,&nbsp;sphere,&nbsp;])</td>
<td>Computes the axonal water fraction from DKI <a class="reference internal" href="#r48388d37c81b-1" id="id13">[1]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.decompose_tensor" title="dipy.reconst.dki_micro.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a>(tensor[,&nbsp;min_diffusivity])</td>
<td>Returns eigenvalues and eigenvectors given a diffusion tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.diffusion_components" title="dipy.reconst.dki_micro.diffusion_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diffusion_components</span></code></a>(dki_params[,&nbsp;sphere,&nbsp;])</td>
<td>Extracts the restricted and hindered diffusion tensors of well aligned fibers from diffusion kurtosis imaging parameters <a class="reference internal" href="#rfba5c976a30b-1" id="id14">[1]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.directional_diffusion" title="dipy.reconst.dki_micro.directional_diffusion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_diffusion</span></code></a>(dt,&nbsp;V[,&nbsp;min_diffusivity])</td>
<td>Calculates the apparent diffusion coefficient (adc) in each direction of a sphere for a single voxel <a class="reference internal" href="#r1dff1a553580-1" id="id15">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.directional_kurtosis" title="dipy.reconst.dki_micro.directional_kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directional_kurtosis</span></code></a>(dt,&nbsp;md,&nbsp;kt,&nbsp;V[,&nbsp;])</td>
<td>Calculates the apparent kurtosis coefficient (akc) in each direction of a sphere for a single voxel <a class="reference internal" href="#r014624b5ce79-1" id="id16">[1]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.dkimicro_prediction" title="dipy.reconst.dki_micro.dkimicro_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dkimicro_prediction</span></code></a>(params,&nbsp;gtab[,&nbsp;S0])</td>
<td>Signal prediction given the DKI microstructure model parameters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.dti_design_matrix" title="dipy.reconst.dki_micro.dti_design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dti_design_matrix</span></code></a>(gtab[,&nbsp;dtype])</td>
<td>Constructs design matrix for DTI weighted least squares or least squares fitting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.from_lower_triangular" title="dipy.reconst.dki_micro.from_lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_lower_triangular</span></code></a>(D)</td>
<td>Returns a tensor given the six unique tensor elements</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.get_sphere" title="dipy.reconst.dki_micro.get_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sphere</span></code></a>([name])</td>
<td>provide triangulated spheres</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.kurtosis_maximum" title="dipy.reconst.dki_micro.kurtosis_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis_maximum</span></code></a>(dki_params[,&nbsp;sphere,&nbsp;gtol,&nbsp;])</td>
<td>Computes kurtosis maximum value</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.lower_triangular" title="dipy.reconst.dki_micro.lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_triangular</span></code></a>(tensor[,&nbsp;b0])</td>
<td>Returns the six lower triangular values of the tensor and a dummy variable if b0 is not None</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.mean_diffusivity" title="dipy.reconst.dki_micro.mean_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_diffusivity</span></code></a>(evals[,&nbsp;axis])</td>
<td>Mean Diffusivity (MD) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.ndindex" title="dipy.reconst.dki_micro.ndindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex</span></code></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.radial_diffusivity" title="dipy.reconst.dki_micro.radial_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_diffusivity</span></code></a>(evals[,&nbsp;axis])</td>
<td>Radial Diffusivity (RD) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.split_dki_param" title="dipy.reconst.dki_micro.split_dki_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_dki_param</span></code></a>(dki_params)</td>
<td>Extract the diffusion tensor eigenvalues, the diffusion tensor eigenvector matrix, and the 15 independent elements of the kurtosis tensor from the model parameters estimated from the DKI model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.tortuosity" title="dipy.reconst.dki_micro.tortuosity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tortuosity</span></code></a>(hindered_ad,&nbsp;hindered_rd)</td>
<td>Computes the tortuosity of the hindered diffusion compartment given its axial and radial diffusivities</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.trace" title="dipy.reconst.dki_micro.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>(evals[,&nbsp;axis])</td>
<td>Trace of a diffusion tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.vec_val_vect" title="dipy.reconst.dki_micro.vec_val_vect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vec_val_vect</span></code></a></td>
<td>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.dsi">
<span id="module-reconst-dsi"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dsi</span></code><a class="headerlink" href="#module-dipy.reconst.dsi" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.Cache" title="dipy.reconst.dsi.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a>(model,&nbsp;data)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a>(gtab[,&nbsp;])</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a>(model,&nbsp;data)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a>(gtab[,&nbsp;qgrid_size,&nbsp;])</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.OdfFit" title="dipy.reconst.dsi.OdfFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfFit</span></code></a>(model,&nbsp;data)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.OdfModel" title="dipy.reconst.dsi.OdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfModel</span></code></a>(gtab)</td>
<td>An abstract class to be sub-classed by specific odf models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.LR_deconv" title="dipy.reconst.dsi.LR_deconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LR_deconv</span></code></a>(prop,&nbsp;psf[,&nbsp;numit,&nbsp;acc_factor])</td>
<td>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.create_qspace" title="dipy.reconst.dsi.create_qspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_qspace</span></code></a>(gtab,&nbsp;origin)</td>
<td>create the 3D grid which holds the signal values (q-space)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.create_qtable" title="dipy.reconst.dsi.create_qtable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_qtable</span></code></a>(gtab,&nbsp;origin)</td>
<td>create a normalized version of gradients</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.fftn" title="dipy.reconst.dsi.fftn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftn</span></code></a>(x[,&nbsp;shape,&nbsp;axes,&nbsp;overwrite_x])</td>
<td>Return multidimensional discrete Fourier transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.fftshift" title="dipy.reconst.dsi.fftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftshift</span></code></a>(x[,&nbsp;axes])</td>
<td>Shift the zero-frequency component to the center of the spectrum.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.gen_PSF" title="dipy.reconst.dsi.gen_PSF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_PSF</span></code></a>(qgrid_sampling,&nbsp;siz_x,&nbsp;siz_y,&nbsp;siz_z)</td>
<td>Generate a PSF for DSI Deconvolution by taking the ifft of the binary q-space sampling mask and truncating it to keep only the center.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.half_to_full_qspace" title="dipy.reconst.dsi.half_to_full_qspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">half_to_full_qspace</span></code></a>(data,&nbsp;gtab)</td>
<td>Half to full Cartesian grid mapping</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.hanning_filter" title="dipy.reconst.dsi.hanning_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hanning_filter</span></code></a>(gtab,&nbsp;filter_width,&nbsp;origin)</td>
<td>create a hanning window</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.ifftshift" title="dipy.reconst.dsi.ifftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifftshift</span></code></a>(x[,&nbsp;axes])</td>
<td>The inverse of <cite>fftshift</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.map_coordinates" title="dipy.reconst.dsi.map_coordinates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_coordinates</span></code></a>(input,&nbsp;coordinates[,&nbsp;])</td>
<td>Map the input array to new coordinates by interpolation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.multi_voxel_fit" title="dipy.reconst.dsi.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.pdf_interp_coords" title="dipy.reconst.dsi.pdf_interp_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf_interp_coords</span></code></a>(sphere,&nbsp;rradius,&nbsp;origin)</td>
<td>Precompute coordinates for ODF calculation from the PDF</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.pdf_odf" title="dipy.reconst.dsi.pdf_odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf_odf</span></code></a>(Pr,&nbsp;rradius,&nbsp;interp_coords)</td>
<td>Calculates the real ODF from the diffusion propagator(PDF) Pr</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.project_hemisph_bvecs" title="dipy.reconst.dsi.project_hemisph_bvecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project_hemisph_bvecs</span></code></a>(gtab)</td>
<td>Project any near identical bvecs to the other hemisphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.setup_test" title="dipy.reconst.dsi.setup_test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setup_test</span></code></a>()</td>
<td>Set numpy print options to legacy for new versions of numpy</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.threshold_propagator" title="dipy.reconst.dsi.threshold_propagator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold_propagator</span></code></a>(P[,&nbsp;estimated_snr])</td>
<td>Applies hard threshold on the propagator to remove background noise for the deconvolution.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.dti">
<span id="module-reconst-dti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.dti</span></code><a class="headerlink" href="#module-dipy.reconst.dti" title="Permalink to this headline"></a></h2>
<p>Classes and functions for fitting tensors</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.ReconstModel" title="dipy.reconst.dti.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorFit</span></code></a>(model,&nbsp;model_params[,&nbsp;model_S0])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorModel" title="dipy.reconst.dti.TensorModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorModel</span></code></a>(gtab[,&nbsp;fit_method,&nbsp;return_S0_hat])</td>
<td>Diffusion Tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.range" title="dipy.reconst.dti.range"><code class="xref py py-obj docutils literal notranslate"><span class="pre">range</span></code></a>(stop)</td>
<td>range(start, stop[, step]) -&gt; range object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.apparent_diffusion_coef" title="dipy.reconst.dti.apparent_diffusion_coef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apparent_diffusion_coef</span></code></a>(q_form,&nbsp;sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction of a</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.auto_attr" title="dipy.reconst.dti.auto_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_attr</span></code></a>(func)</td>
<td>Decorator to create OneTimeProperty attributes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.axial_diffusivity" title="dipy.reconst.dti.axial_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axial_diffusivity</span></code></a>(evals[,&nbsp;axis])</td>
<td>Axial Diffusivity (AD) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.color_fa" title="dipy.reconst.dti.color_fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code></a>(fa,&nbsp;evecs)</td>
<td>Color fractional anisotropy of diffusion tensor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a>(tensor[,&nbsp;min_diffusivity])</td>
<td>Returns eigenvalues and eigenvectors given a diffusion tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.design_matrix" title="dipy.reconst.dti.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>(gtab[,&nbsp;dtype])</td>
<td>Constructs design matrix for DTI weighted least squares or least squares fitting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.determinant" title="dipy.reconst.dti.determinant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">determinant</span></code></a>(q_form)</td>
<td>The determinant of a tensor, given in quadratic form</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.deviatoric" title="dipy.reconst.dti.deviatoric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deviatoric</span></code></a>(q_form)</td>
<td>Calculate the deviatoric (anisotropic) part of the tensor <a class="reference internal" href="#rfe2215338679-1" id="id17">[1]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.eig_from_lo_tri" title="dipy.reconst.dti.eig_from_lo_tri"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eig_from_lo_tri</span></code></a>(data[,&nbsp;min_diffusivity])</td>
<td>Calculates tensor eigenvalues/eigenvectors from an array containing the lower diagonal form of the six unique tensor elements.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.eigh" title="dipy.reconst.dti.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a>(a[,&nbsp;UPLO])</td>
<td>Iterate over <cite>np.linalg.eigh</cite> if it doesnt support vectorized operation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.fractional_anisotropy" title="dipy.reconst.dti.fractional_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractional_anisotropy</span></code></a>(evals[,&nbsp;axis])</td>
<td>Fractional anisotropy (FA) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.from_lower_triangular" title="dipy.reconst.dti.from_lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_lower_triangular</span></code></a>(D)</td>
<td>Returns a tensor given the six unique tensor elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.geodesic_anisotropy" title="dipy.reconst.dti.geodesic_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geodesic_anisotropy</span></code></a>(evals[,&nbsp;axis])</td>
<td>Geodesic anisotropy (GA) of a diffusion tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.get_sphere" title="dipy.reconst.dti.get_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sphere</span></code></a>([name])</td>
<td>provide triangulated spheres</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.gradient_table" title="dipy.reconst.dti.gradient_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table</span></code></a>(bvals[,&nbsp;bvecs,&nbsp;big_delta,&nbsp;])</td>
<td>A general function for creating diffusion MR gradients.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.isotropic" title="dipy.reconst.dti.isotropic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isotropic</span></code></a>(q_form)</td>
<td>Calculate the isotropic part of the tensor [Rd0568a744381-1].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.iter_fit_tensor" title="dipy.reconst.dti.iter_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_fit_tensor</span></code></a>([step])</td>
<td>Wrap a fit_tensor func and iterate over chunks of data with given length</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.linearity" title="dipy.reconst.dti.linearity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code></a>(evals[,&nbsp;axis])</td>
<td>The linearity of the tensor <a class="footnote-reference" href="#id344" id="id19">[1]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.lower_triangular" title="dipy.reconst.dti.lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_triangular</span></code></a>(tensor[,&nbsp;b0])</td>
<td>Returns the six lower triangular values of the tensor and a dummy variable if b0 is not None</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.mean_diffusivity" title="dipy.reconst.dti.mean_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_diffusivity</span></code></a>(evals[,&nbsp;axis])</td>
<td>Mean Diffusivity (MD) of a diffusion tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.mode" title="dipy.reconst.dti.mode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code></a>(q_form)</td>
<td>Mode (MO) of a diffusion tensor <a class="reference internal" href="#rae241588dfcd-1" id="id20">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.nlls_fit_tensor" title="dipy.reconst.dti.nlls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlls_fit_tensor</span></code></a>(design_matrix,&nbsp;data[,&nbsp;])</td>
<td>Fit the tensor params using non-linear least-squares.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.norm" title="dipy.reconst.dti.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>(q_form)</td>
<td>Calculate the Frobenius norm of a tensor quadratic form</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.ols_fit_tensor" title="dipy.reconst.dti.ols_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ols_fit_tensor</span></code></a>(design_matrix,&nbsp;data[,&nbsp;])</td>
<td>Computes ordinary least squares (OLS) fit to calculate self-diffusion tensor using a linear regression model <a class="footnote-reference" href="#id344" id="id21">[1]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.pinv" title="dipy.reconst.dti.pinv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pinv</span></code></a>(a[,&nbsp;rcond])</td>
<td>Vectorized version of <cite>numpy.linalg.pinv</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.planarity" title="dipy.reconst.dti.planarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code></a>(evals[,&nbsp;axis])</td>
<td>The planarity of the tensor <a class="footnote-reference" href="#id344" id="id22">[1]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.quantize_evecs" title="dipy.reconst.dti.quantize_evecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantize_evecs</span></code></a>(evecs[,&nbsp;odf_vertices])</td>
<td>Find the closest orientation of an evenly distributed sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.radial_diffusivity" title="dipy.reconst.dti.radial_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_diffusivity</span></code></a>(evals[,&nbsp;axis])</td>
<td>Radial Diffusivity (RD) of a diffusion tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.restore_fit_tensor" title="dipy.reconst.dti.restore_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">restore_fit_tensor</span></code></a>(design_matrix,&nbsp;data[,&nbsp;])</td>
<td>Use the RESTORE algorithm <a class="reference internal" href="../examples_built/restore_dti.html#chang2005" id="id23">[Chang2005]</a> to calculate a robust tensor fit</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.sphericity" title="dipy.reconst.dti.sphericity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code></a>(evals[,&nbsp;axis])</td>
<td>The sphericity of the tensor <a class="footnote-reference" href="#id344" id="id24">[1]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.tensor_prediction" title="dipy.reconst.dti.tensor_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_prediction</span></code></a>(dti_params,&nbsp;gtab,&nbsp;S0)</td>
<td>Predict a signal given tensor parameters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.trace" title="dipy.reconst.dti.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>(evals[,&nbsp;axis])</td>
<td>Trace of a diffusion tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.vec_val_vect" title="dipy.reconst.dti.vec_val_vect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vec_val_vect</span></code></a></td>
<td>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.vector_norm" title="dipy.reconst.dti.vector_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_norm</span></code></a>(vec[,&nbsp;axis,&nbsp;keepdims])</td>
<td>Return vector Euclidean (L2) norm</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.wls_fit_tensor" title="dipy.reconst.dti.wls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_tensor</span></code></a>(design_matrix,&nbsp;data[,&nbsp;])</td>
<td>Computes weighted least squares (WLS) fit to calculate self-diffusion tensor using a linear regression model <a class="reference internal" href="#rba397ddf7dbd-1" id="id25">[1]</a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.forecast">
<span id="module-reconst-forecast"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.forecast</span></code><a class="headerlink" href="#module-dipy.reconst.forecast" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.Cache" title="dipy.reconst.forecast.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit" title="dipy.reconst.forecast.ForecastFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForecastFit</span></code></a>(model,&nbsp;data,&nbsp;sh_coef,&nbsp;d_par,&nbsp;d_perp)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.ForecastModel" title="dipy.reconst.forecast.ForecastModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForecastModel</span></code></a>(gtab[,&nbsp;sh_order,&nbsp;lambda_lb,&nbsp;])</td>
<td>Fiber ORientation Estimated using Continuous Axially Symmetric Tensors (FORECAST) [1,2,3]_.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.OdfFit" title="dipy.reconst.forecast.OdfFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfFit</span></code></a>(model,&nbsp;data)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.OdfModel" title="dipy.reconst.forecast.OdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfModel</span></code></a>(gtab)</td>
<td>An abstract class to be sub-classed by specific odf models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.cart2sphere" title="dipy.reconst.forecast.cart2sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart2sphere</span></code></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.csdeconv" title="dipy.reconst.forecast.csdeconv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csdeconv</span></code></a>(dwsignal,&nbsp;X,&nbsp;B_reg[,&nbsp;tau,&nbsp;])</td>
<td>Constrained-regularized spherical deconvolution (CSD) <a class="reference internal" href="#r89c481eb6cb9-1" id="id26">[1]</a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.find_signal_means" title="dipy.reconst.forecast.find_signal_means"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_signal_means</span></code></a>(b_unique,&nbsp;data_norm,&nbsp;)</td>
<td>Calculate the mean signal for each shell.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.forecast_error_func" title="dipy.reconst.forecast.forecast_error_func"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forecast_error_func</span></code></a>(x,&nbsp;b_unique,&nbsp;E)</td>
<td>Calculates the difference between the mean signal calculated using  the parameter vector x and the average signal E using FORECAST and SMT</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.forecast_matrix" title="dipy.reconst.forecast.forecast_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forecast_matrix</span></code></a>(sh_order,&nbsp;d_par,&nbsp;d_perp,&nbsp;bvals)</td>
<td>Compute the FORECAST radial matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.get_sphere" title="dipy.reconst.forecast.get_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sphere</span></code></a>([name])</td>
<td>provide triangulated spheres</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.lb_forecast" title="dipy.reconst.forecast.lb_forecast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lb_forecast</span></code></a>(sh_order)</td>
<td>Returns the Laplace-Beltrami regularization matrix for FORECAST</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.leastsq" title="dipy.reconst.forecast.leastsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">leastsq</span></code></a>(func,&nbsp;x0[,&nbsp;args,&nbsp;Dfun,&nbsp;full_output,&nbsp;])</td>
<td>Minimize the sum of squares of a set of equations.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.multi_voxel_fit" title="dipy.reconst.forecast.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.optional_package" title="dipy.reconst.forecast.optional_package"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optional_package</span></code></a>(name[,&nbsp;trip_msg])</td>
<td>Return package-like thing and module setup for package <cite>name</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.psi_l" title="dipy.reconst.forecast.psi_l"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psi_l</span></code></a>(l,&nbsp;b)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.real_sph_harm" title="dipy.reconst.forecast.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.rho_matrix" title="dipy.reconst.forecast.rho_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rho_matrix</span></code></a>(sh_order,&nbsp;vecs)</td>
<td>Compute the SH matrix <span class="math notranslate nohighlight">\(\rho\)</span></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.warn" title="dipy.reconst.forecast.warn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warn</span></code></a></td>
<td>Issue a warning, or maybe ignore it or raise an exception.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.fwdti">
<span id="module-reconst-fwdti"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.fwdti</span></code><a class="headerlink" href="#module-dipy.reconst.fwdti" title="Permalink to this headline"></a></h2>
<p>Classes and functions for fitting tensors without free water
contamination</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit" title="dipy.reconst.fwdti.FreeWaterTensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a>(model,&nbsp;model_params)</td>
<td>Class for fitting the Free Water Tensor Model</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel" title="dipy.reconst.fwdti.FreeWaterTensorModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a>(gtab[,&nbsp;fit_method])</td>
<td>Class for the Free Water Elimination Diffusion Tensor Model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.ReconstModel" title="dipy.reconst.fwdti.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit" title="dipy.reconst.fwdti.TensorFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorFit</span></code></a>(model,&nbsp;model_params[,&nbsp;model_S0])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.cholesky_to_lower_triangular" title="dipy.reconst.fwdti.cholesky_to_lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cholesky_to_lower_triangular</span></code></a>(R)</td>
<td>Convert Cholesky decompostion elements to the diffusion tensor elements</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.decompose_tensor" title="dipy.reconst.fwdti.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a>(tensor[,&nbsp;min_diffusivity])</td>
<td>Returns eigenvalues and eigenvectors given a diffusion tensor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.design_matrix" title="dipy.reconst.fwdti.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>(gtab[,&nbsp;dtype])</td>
<td>Constructs design matrix for DTI weighted least squares or least squares fitting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.from_lower_triangular" title="dipy.reconst.fwdti.from_lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_lower_triangular</span></code></a>(D)</td>
<td>Returns a tensor given the six unique tensor elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.fwdti_prediction" title="dipy.reconst.fwdti.fwdti_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fwdti_prediction</span></code></a>(params,&nbsp;gtab[,&nbsp;S0,&nbsp;Diso])</td>
<td>Signal prediction given the free water DTI model parameters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.lower_triangular" title="dipy.reconst.fwdti.lower_triangular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_triangular</span></code></a>(tensor[,&nbsp;b0])</td>
<td>Returns the six lower triangular values of the tensor and a dummy variable if b0 is not None</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.lower_triangular_to_cholesky" title="dipy.reconst.fwdti.lower_triangular_to_cholesky"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_triangular_to_cholesky</span></code></a>(tensor_elements)</td>
<td>Perfoms Cholesky decomposition of the diffusion tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.multi_voxel_fit" title="dipy.reconst.fwdti.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.ndindex" title="dipy.reconst.fwdti.ndindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex</span></code></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.nls_fit_tensor" title="dipy.reconst.fwdti.nls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nls_fit_tensor</span></code></a>(gtab,&nbsp;data[,&nbsp;mask,&nbsp;Diso,&nbsp;])</td>
<td>Fit the water elimination tensor model using the non-linear least-squares.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.nls_iter" title="dipy.reconst.fwdti.nls_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nls_iter</span></code></a>(design_matrix,&nbsp;sig,&nbsp;S0[,&nbsp;Diso,&nbsp;])</td>
<td>Applies non linear least squares fit of the water free elimination model to single voxel signals.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.vec_val_vect" title="dipy.reconst.fwdti.vec_val_vect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vec_val_vect</span></code></a></td>
<td>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.wls_fit_tensor" title="dipy.reconst.fwdti.wls_fit_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_tensor</span></code></a>(gtab,&nbsp;data[,&nbsp;Diso,&nbsp;mask,&nbsp;])</td>
<td>Computes weighted least squares (WLS) fit to calculate self-diffusion tensor using a linear regression model <a class="reference internal" href="#r78c063b823b9-1" id="id27">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.wls_iter" title="dipy.reconst.fwdti.wls_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_iter</span></code></a>(design_matrix,&nbsp;sig,&nbsp;S0[,&nbsp;Diso,&nbsp;])</td>
<td>Applies weighted linear least squares fit of the water free elimination model to single voxel signals.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.gqi">
<span id="module-reconst-gqi"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.gqi</span></code><a class="headerlink" href="#module-dipy.reconst.gqi" title="Permalink to this headline"></a></h2>
<p>Classes and functions for generalized q-sampling</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.Cache" title="dipy.reconst.gqi.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="dipy.reconst.gqi.GeneralizedQSamplingFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a>(model,&nbsp;data)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="dipy.reconst.gqi.GeneralizedQSamplingModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a>(gtab[,&nbsp;method,&nbsp;])</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.OdfFit" title="dipy.reconst.gqi.OdfFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfFit</span></code></a>(model,&nbsp;data)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.OdfModel" title="dipy.reconst.gqi.OdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfModel</span></code></a>(gtab)</td>
<td>An abstract class to be sub-classed by specific odf models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.equatorial_maximum" title="dipy.reconst.gqi.equatorial_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equatorial_maximum</span></code></a>(vertices,&nbsp;odf,&nbsp;pole,&nbsp;width)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.equatorial_zone_vertices" title="dipy.reconst.gqi.equatorial_zone_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equatorial_zone_vertices</span></code></a>(vertices,&nbsp;pole[,&nbsp;width])</td>
<td>finds the vertices in the equatorial zone conjugate to pole with width half width degrees</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.gfa" title="dipy.reconst.gqi.gfa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gfa</span></code></a>(samples)</td>
<td>The general fractional anisotropy of a function evaluated on the unit sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.local_maxima" title="dipy.reconst.gqi.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">local_maxima</span></code></a></td>
<td>Local maxima of a function evaluated on a discrete set of points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.multi_voxel_fit" title="dipy.reconst.gqi.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.normalize_qa" title="dipy.reconst.gqi.normalize_qa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_qa</span></code></a>(qa[,&nbsp;max_qa])</td>
<td>Normalize quantitative anisotropy.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.npa" title="dipy.reconst.gqi.npa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">npa</span></code></a>(self,&nbsp;odf[,&nbsp;width])</td>
<td>non-parametric anisotropy</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.odf_sum" title="dipy.reconst.gqi.odf_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sum</span></code></a>(odf)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.patch_maximum" title="dipy.reconst.gqi.patch_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">patch_maximum</span></code></a>(vertices,&nbsp;odf,&nbsp;pole,&nbsp;width)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.patch_sum" title="dipy.reconst.gqi.patch_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">patch_sum</span></code></a>(vertices,&nbsp;odf,&nbsp;pole,&nbsp;width)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.patch_vertices" title="dipy.reconst.gqi.patch_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">patch_vertices</span></code></a>(vertices,&nbsp;pole,&nbsp;width)</td>
<td>find vertices within the cone of width degrees around pole</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.polar_zone_vertices" title="dipy.reconst.gqi.polar_zone_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polar_zone_vertices</span></code></a>(vertices,&nbsp;pole[,&nbsp;width])</td>
<td>finds the vertices in the equatorial band around the pole of radius width degrees</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.remove_similar_vertices" title="dipy.reconst.gqi.remove_similar_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_similar_vertices</span></code></a></td>
<td>Remove vertices that are less than <cite>theta</cite> degrees from any other</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.squared_radial_component" title="dipy.reconst.gqi.squared_radial_component"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squared_radial_component</span></code></a>(x[,&nbsp;tol])</td>
<td>Part of the GQI2 integral</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.triple_odf_maxima" title="dipy.reconst.gqi.triple_odf_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triple_odf_maxima</span></code></a>(vertices,&nbsp;odf,&nbsp;width)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.upper_hemi_map" title="dipy.reconst.gqi.upper_hemi_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper_hemi_map</span></code></a>(v)</td>
<td>maps a 3-vector into the z-upper hemisphere</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.interpolate">
<span id="module-reconst-interpolate"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.interpolate</span></code><a class="headerlink" href="#module-dipy.reconst.interpolate" title="Permalink to this headline"></a></h2>
<p>Interpolators wrap arrays to allow the array to be indexed in
continuous coordinates</p>
<p>This module uses the trackvis coordinate system, for more information about
this coordinate system please see dipy.tracking.utils
The following modules also use this coordinate system:
dipy.tracking.utils
dipy.tracking.integration
dipy.reconst.interpolate</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.interpolate.Interpolator" title="dipy.reconst.interpolate.Interpolator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Interpolator</span></code></a>(data,&nbsp;voxel_size)</td>
<td>Class to be subclassed by different interpolator types</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.interpolate.NearestNeighborInterpolator" title="dipy.reconst.interpolate.NearestNeighborInterpolator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NearestNeighborInterpolator</span></code></a>(data,&nbsp;voxel_size)</td>
<td>Interpolates data using nearest neighbor interpolation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.interpolate.OutsideImage" title="dipy.reconst.interpolate.OutsideImage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OutsideImage</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.interpolate.TriLinearInterpolator" title="dipy.reconst.interpolate.TriLinearInterpolator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TriLinearInterpolator</span></code></a>(data,&nbsp;voxel_size)</td>
<td>Interpolates data using trilinear interpolation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.interpolate.array" title="dipy.reconst.interpolate.array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">array</span></code></a>(object[,&nbsp;dtype,&nbsp;copy,&nbsp;order,&nbsp;subok,&nbsp;ndmin])</td>
<td>Create an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.interpolate.trilinear_interp" title="dipy.reconst.interpolate.trilinear_interp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trilinear_interp</span></code></a></td>
<td>Interpolates vector from 4D <cite>data</cite> at 3D point given by <cite>index</cite></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.ivim">
<span id="module-reconst-ivim"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.ivim</span></code><a class="headerlink" href="#module-dipy.reconst.ivim" title="Permalink to this headline"></a></h2>
<p>Classes and functions for fitting ivim model</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.ivim.IvimFit" title="dipy.reconst.ivim.IvimFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IvimFit</span></code></a>(model,&nbsp;model_params)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.ivim.IvimModel" title="dipy.reconst.ivim.IvimModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IvimModel</span></code></a>(gtab[,&nbsp;split_b_D,&nbsp;split_b_S0,&nbsp;])</td>
<td>Ivim model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.ivim.LooseVersion" title="dipy.reconst.ivim.LooseVersion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LooseVersion</span></code></a>([vstring])</td>
<td>Version numbering for anarchists and software realists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.ivim.ReconstModel" title="dipy.reconst.ivim.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.ivim.f_D_star_error" title="dipy.reconst.ivim.f_D_star_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_D_star_error</span></code></a>(params,&nbsp;gtab,&nbsp;signal,&nbsp;S0,&nbsp;D)</td>
<td>Error function used to fit f and D_star keeping S0 and D fixed</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.ivim.f_D_star_prediction" title="dipy.reconst.ivim.f_D_star_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f_D_star_prediction</span></code></a>(params,&nbsp;gtab,&nbsp;S0,&nbsp;D)</td>
<td>Function used to predict IVIM signal when S0 and D are known by considering f and D_star as the unknown parameters.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.ivim.ivim_prediction" title="dipy.reconst.ivim.ivim_prediction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ivim_prediction</span></code></a>(params,&nbsp;gtab[,&nbsp;S0])</td>
<td>The Intravoxel incoherent motion (IVIM) model function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.ivim.least_squares" title="dipy.reconst.ivim.least_squares"><code class="xref py py-obj docutils literal notranslate"><span class="pre">least_squares</span></code></a>(fun,&nbsp;x0[,&nbsp;jac,&nbsp;bounds,&nbsp;])</td>
<td>Solve a nonlinear least-squares problem with bounds on the variables.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.ivim.multi_voxel_fit" title="dipy.reconst.ivim.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.mapmri">
<span id="module-reconst-mapmri"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.mapmri</span></code><a class="headerlink" href="#module-dipy.reconst.mapmri" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.Cache" title="dipy.reconst.mapmri.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit" title="dipy.reconst.mapmri.MapmriFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MapmriFit</span></code></a>(model,&nbsp;mapmri_coef,&nbsp;mu,&nbsp;R,&nbsp;lopt[,&nbsp;])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriModel" title="dipy.reconst.mapmri.MapmriModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MapmriModel</span></code></a>(gtab[,&nbsp;radial_order,&nbsp;])</td>
<td>Mean Apparent Propagator MRI (MAPMRI) <a class="reference internal" href="#rb71d87403e8f-1" id="id28">[1]</a> of the diffusion signal.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.Optimizer" title="dipy.reconst.mapmri.Optimizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Optimizer</span></code></a>(fun,&nbsp;x0[,&nbsp;args,&nbsp;method,&nbsp;jac,&nbsp;])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.ReconstFit" title="dipy.reconst.mapmri.ReconstFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstFit</span></code></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.ReconstModel" title="dipy.reconst.mapmri.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.b_mat" title="dipy.reconst.mapmri.b_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b_mat</span></code></a>(index_matrix)</td>
<td>Calculates the B coefficients from <a class="reference internal" href="#rcb3260c94f80-1" id="id29">[1]</a> Eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.b_mat_isotropic" title="dipy.reconst.mapmri.b_mat_isotropic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">b_mat_isotropic</span></code></a>(index_matrix)</td>
<td>Calculates the isotropic B coefficients from <a class="reference internal" href="#r21c472b0c767-1" id="id30">[1]</a> Fig 8.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.binomialfloat" title="dipy.reconst.mapmri.binomialfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">binomialfloat</span></code></a>(n,&nbsp;k)</td>
<td>Custom Binomial function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.cart2sphere" title="dipy.reconst.mapmri.cart2sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart2sphere</span></code></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.create_rspace" title="dipy.reconst.mapmri.create_rspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_rspace</span></code></a>(gridsize,&nbsp;radius_max)</td>
<td>Create the real space table, that contains the points in which to compute the pdf.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.delta" title="dipy.reconst.mapmri.delta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delta</span></code></a>(n,&nbsp;m)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.factorial2" title="dipy.reconst.mapmri.factorial2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorial2</span></code></a>(n[,&nbsp;exact])</td>
<td>Double factorial.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.gcv_cost_function" title="dipy.reconst.mapmri.gcv_cost_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gcv_cost_function</span></code></a>(weight,&nbsp;args)</td>
<td>The GCV cost function that is iterated [4]</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.generalized_crossvalidation" title="dipy.reconst.mapmri.generalized_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generalized_crossvalidation</span></code></a>(data,&nbsp;M,&nbsp;LR[,&nbsp;])</td>
<td>Generalized Cross Validation Function [Rb690cd738504-1] eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.generalized_crossvalidation_array" title="dipy.reconst.mapmri.generalized_crossvalidation_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generalized_crossvalidation_array</span></code></a>(data,&nbsp;M,&nbsp;LR)</td>
<td>Generalized Cross Validation Function <a class="footnote-reference" href="#id344" id="id32">[1]</a> eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.genlaguerre" title="dipy.reconst.mapmri.genlaguerre"><code class="xref py py-obj docutils literal notranslate"><span class="pre">genlaguerre</span></code></a>(n,&nbsp;alpha[,&nbsp;monic])</td>
<td>Generalized (associated) Laguerre polynomial.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.gradient_table" title="dipy.reconst.mapmri.gradient_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table</span></code></a>(bvals[,&nbsp;bvecs,&nbsp;big_delta,&nbsp;])</td>
<td>A general function for creating diffusion MR gradients.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.hermite" title="dipy.reconst.mapmri.hermite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hermite</span></code></a>(n[,&nbsp;monic])</td>
<td>Physicists Hermite polynomial.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.isotropic_scale_factor" title="dipy.reconst.mapmri.isotropic_scale_factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isotropic_scale_factor</span></code></a>(mu_squared)</td>
<td>Estimated isotropic scaling factor _[1] Eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.map_laplace_s" title="dipy.reconst.mapmri.map_laplace_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_laplace_s</span></code></a>(n,&nbsp;m)</td>
<td>R(m,n) static matrix for Laplacian regularization [R932dd40ca52e-1] eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.map_laplace_t" title="dipy.reconst.mapmri.map_laplace_t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_laplace_t</span></code></a>(n,&nbsp;m)</td>
<td>L(m, n) static matrix for Laplacian regularization [Reb78d789d6c4-1] eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.map_laplace_u" title="dipy.reconst.mapmri.map_laplace_u"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_laplace_u</span></code></a>(n,&nbsp;m)</td>
<td>S(n, m) static matrix for Laplacian regularization [Rb93dd9dab8c9-1] eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_STU_reg_matrices" title="dipy.reconst.mapmri.mapmri_STU_reg_matrices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_STU_reg_matrices</span></code></a>(radial_order)</td>
<td>Generates the static portions of the Laplacian regularization matrix according to [R1d585103467a-1] eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_index_matrix" title="dipy.reconst.mapmri.mapmri_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_index_matrix</span></code></a>(radial_order)</td>
<td>Calculates the indices for the MAPMRI <a class="reference internal" href="#rb85ba44932df-1" id="id37">[1]</a> basis in x, y and z.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent" title="dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_dependent</span></code></a>()</td>
<td>Computes mu dependent part of M.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent" title="dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_K_mu_independent</span></code></a>()</td>
<td>Computes mu independent part of K.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent" title="dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_dependent</span></code></a>()</td>
<td>Computed the mu dependent part of the signal design matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent" title="dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_M_mu_independent</span></code></a>()</td>
<td>Computed the mu independent part of the signal design matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_index_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_index_matrix</span></code></a>(radial_order)</td>
<td>Calculates the indices for the isotropic MAPMRI basis <a class="reference internal" href="#rc015c0dc1977-1" id="id38">[1]</a> Fig 8.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix</span></code></a>()</td>
<td>Computes the Laplacian regularization matrix for MAP-MRIs isotropic implementation [R156f27ca005f-1] eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</span></code></a>()</td>
<td>Computes the Laplacian regularization matrix for MAP-MRIs isotropic implementation [Rdcc29394f577-1] eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_odf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_matrix</span></code></a>(radial_order,&nbsp;)</td>
<td>Compute the isotropic MAPMRI ODF matrix <a class="reference internal" href="#rf7e027186c88-1" id="id41">[1]</a> Eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_odf_sh_matrix</span></code></a>(radial_order,&nbsp;)</td>
<td>Compute the isotropic MAPMRI ODF matrix <a class="reference internal" href="#r18e181ea8d0c-1" id="id42">[1]</a> Eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_phi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_phi_matrix</span></code></a>(radial_order,&nbsp;mu,&nbsp;q)</td>
<td>Three dimensional isotropic MAPMRI signal basis function from <a class="reference internal" href="#r7485962ae8ea-1" id="id43">[1]</a> Eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix" title="dipy.reconst.mapmri.mapmri_isotropic_psi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_psi_matrix</span></code></a>(radial_order,&nbsp;)</td>
<td>Three dimensional isotropic MAPMRI propagator basis function from <a class="reference internal" href="#r77a51da75e29-1" id="id44">[1]</a> Eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis" title="dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_pdf_basis</span></code></a>(j,&nbsp;l,&nbsp;mu,&nbsp;r)</td>
<td>Radial part of the isotropic 1D-SHORE propagator basis <a class="reference internal" href="#r889cbb1a52b7-1" id="id45">[1]</a> eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis" title="dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_isotropic_radial_signal_basis</span></code></a>(j,&nbsp;l,&nbsp;)</td>
<td>Radial part of the isotropic 1D-SHORE signal basis <a class="reference internal" href="#r87b99f9c6ca2-1" id="id46">[1]</a> eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix" title="dipy.reconst.mapmri.mapmri_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_laplacian_reg_matrix</span></code></a>(ind_mat,&nbsp;mu,&nbsp;)</td>
<td>Puts the Laplacian regularization matrix together [Rc66aaccd07c1-1] eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_odf_matrix" title="dipy.reconst.mapmri.mapmri_odf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_odf_matrix</span></code></a>(radial_order,&nbsp;mu,&nbsp;s,&nbsp;vertices)</td>
<td>Compute the MAPMRI ODF matrix <a class="reference internal" href="#re26b9b8173e7-1" id="id48">[1]</a>  Eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_phi_1d" title="dipy.reconst.mapmri.mapmri_phi_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_phi_1d</span></code></a>(n,&nbsp;q,&nbsp;mu)</td>
<td>One dimensional MAPMRI basis function from <a class="reference internal" href="#r76e82749e6a0-1" id="id49">[1]</a> Eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_phi_matrix" title="dipy.reconst.mapmri.mapmri_phi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_phi_matrix</span></code></a>(radial_order,&nbsp;mu,&nbsp;q_gradients)</td>
<td>Compute the MAPMRI phi matrix for the signal <a class="reference internal" href="#r3a5a50d36842-1" id="id50">[1]</a> eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_psi_1d" title="dipy.reconst.mapmri.mapmri_psi_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_psi_1d</span></code></a>(n,&nbsp;x,&nbsp;mu)</td>
<td>One dimensional MAPMRI propagator basis function from <a class="reference internal" href="#rb9b07bc1eb95-1" id="id51">[1]</a> Eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.mapmri_psi_matrix" title="dipy.reconst.mapmri.mapmri_psi_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_psi_matrix</span></code></a>(radial_order,&nbsp;mu,&nbsp;rgrad)</td>
<td>Compute the MAPMRI psi matrix for the propagator <a class="reference internal" href="#rf11279199519-1" id="id52">[1]</a> eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.mfactorial" title="dipy.reconst.mapmri.mfactorial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mfactorial</span></code></a></td>
<td>factorial(x) -&gt; Integral</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.multi_voxel_fit" title="dipy.reconst.mapmri.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.optional_package" title="dipy.reconst.mapmri.optional_package"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optional_package</span></code></a>(name[,&nbsp;trip_msg])</td>
<td>Return package-like thing and module setup for package <cite>name</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.real_sph_harm" title="dipy.reconst.mapmri.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.sfactorial" title="dipy.reconst.mapmri.sfactorial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sfactorial</span></code></a>(n[,&nbsp;exact])</td>
<td>The factorial of a number or array of numbers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.sph_harm_ind_list" title="dipy.reconst.mapmri.sph_harm_ind_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sph_harm_ind_list</span></code></a>(sh_order)</td>
<td>Returns the degree (n) and order (m) of all the symmetric spherical harmonics of degree less then or equal to <cite>sh_order</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.warn" title="dipy.reconst.mapmri.warn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warn</span></code></a></td>
<td>Issue a warning, or maybe ignore it or raise an exception.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.multi_voxel">
<span id="module-reconst-multi-voxel"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.multi_voxel</span></code><a class="headerlink" href="#module-dipy.reconst.multi_voxel" title="Permalink to this headline"></a></h2>
<p>Tools to easily make multi voxel models</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.CallableArray" title="dipy.reconst.multi_voxel.CallableArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CallableArray</span></code></a></td>
<td>An array which can be called like a function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="dipy.reconst.multi_voxel.MultiVoxelFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a>(model,&nbsp;fit_array,&nbsp;mask)</td>
<td>Holds an array of fits and allows access to their attributes and methods</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.ReconstFit" title="dipy.reconst.multi_voxel.ReconstFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstFit</span></code></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.as_strided" title="dipy.reconst.multi_voxel.as_strided"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_strided</span></code></a>(x[,&nbsp;shape,&nbsp;strides,&nbsp;subok,&nbsp;writeable])</td>
<td>Create a view into the array with the given shape and strides.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.multi_voxel_fit" title="dipy.reconst.multi_voxel.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.ndindex" title="dipy.reconst.multi_voxel.ndindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex</span></code></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.odf">
<span id="module-reconst-odf"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.odf</span></code><a class="headerlink" href="#module-dipy.reconst.odf" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfFit</span></code></a>(model,&nbsp;data)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfModel</span></code></a>(gtab)</td>
<td>An abstract class to be sub-classed by specific odf models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.ReconstFit" title="dipy.reconst.odf.ReconstFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstFit</span></code></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.odf.ReconstModel" title="dipy.reconst.odf.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.gfa" title="dipy.reconst.odf.gfa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gfa</span></code></a>(samples)</td>
<td>The general fractional anisotropy of a function evaluated on the unit sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.odf.minmax_normalize" title="dipy.reconst.odf.minmax_normalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minmax_normalize</span></code></a>(samples[,&nbsp;out])</td>
<td>Min-max normalization of a function evaluated on the unit sphere</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.peaks">
<span id="module-reconst-peaks"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.peaks</span></code><a class="headerlink" href="#module-dipy.reconst.peaks" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.InTemporaryDirectory" title="dipy.reconst.peaks.InTemporaryDirectory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">InTemporaryDirectory</span></code></a>([suffix,&nbsp;prefix,&nbsp;dir])</td>
<td>Create, return, and change directory to a temporary directory</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetrics" title="dipy.reconst.peaks.PeaksAndMetrics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PeaksAndMetrics</span></code></a></td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter" title="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PeaksAndMetricsDirectionGetter</span></code></a></td>
<td>Deterministic Direction Getter based on peak directions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.Sphere" title="dipy.reconst.peaks.Sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sphere</span></code></a>([x,&nbsp;y,&nbsp;z,&nbsp;theta,&nbsp;phi,&nbsp;xyz,&nbsp;faces,&nbsp;edges])</td>
<td>Points on the unit sphere.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.repeat" title="dipy.reconst.peaks.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>(object&nbsp;[,times])</td>
<td>for the specified number of times.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.xrange" title="dipy.reconst.peaks.xrange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrange</span></code></a></td>
<td>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.range</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.Pool" title="dipy.reconst.peaks.Pool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pool</span></code></a></td>
<td>Returns a process pool object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.cpu_count" title="dipy.reconst.peaks.cpu_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cpu_count</span></code></a></td>
<td>Returns the number of CPUs in the system</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.gfa" title="dipy.reconst.peaks.gfa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gfa</span></code></a>(samples)</td>
<td>The general fractional anisotropy of a function evaluated on the unit sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.local_maxima" title="dipy.reconst.peaks.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">local_maxima</span></code></a></td>
<td>Local maxima of a function evaluated on a discrete set of points.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.ndindex" title="dipy.reconst.peaks.ndindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndindex</span></code></a>(shape)</td>
<td>An N-dimensional iterator object to index arrays.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.peak_directions" title="dipy.reconst.peaks.peak_directions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">peak_directions</span></code></a>(odf,&nbsp;sphere[,&nbsp;])</td>
<td>Get the directions of odf peaks.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.peak_directions_nl" title="dipy.reconst.peaks.peak_directions_nl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">peak_directions_nl</span></code></a>(sphere_eval[,&nbsp;])</td>
<td>Non Linear Direction Finder.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.peaks_from_model" title="dipy.reconst.peaks.peaks_from_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">peaks_from_model</span></code></a>(model,&nbsp;data,&nbsp;sphere,&nbsp;[,&nbsp;])</td>
<td>Fit the model to data and computes peaks and metrics</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.remove_similar_vertices" title="dipy.reconst.peaks.remove_similar_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_similar_vertices</span></code></a></td>
<td>Remove vertices that are less than <cite>theta</cite> degrees from any other</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.reshape_peaks_for_visualization" title="dipy.reconst.peaks.reshape_peaks_for_visualization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape_peaks_for_visualization</span></code></a>(peaks)</td>
<td>Reshape peaks for visualization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.search_descending" title="dipy.reconst.peaks.search_descending"><code class="xref py py-obj docutils literal notranslate"><span class="pre">search_descending</span></code></a></td>
<td><cite>i</cite> in descending array <cite>a</cite> so <cite>a[i] &lt; a[0] * relative_threshold</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.sh_to_sf_matrix" title="dipy.reconst.peaks.sh_to_sf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_sf_matrix</span></code></a>(sphere,&nbsp;sh_order[,&nbsp;])</td>
<td>Matrix that transforms Spherical harmonics (SH) to spherical function (SF).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.warn" title="dipy.reconst.peaks.warn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warn</span></code></a></td>
<td>Issue a warning, or maybe ignore it or raise an exception.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.qtdmri">
<span id="module-reconst-qtdmri"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.qtdmri</span></code><a class="headerlink" href="#module-dipy.reconst.qtdmri" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.Cache" title="dipy.reconst.qtdmri.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit" title="dipy.reconst.qtdmri.QtdmriFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a>(model,&nbsp;qtdmri_coef,&nbsp;us,&nbsp;ut,&nbsp;)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriModel" title="dipy.reconst.qtdmri.QtdmriModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a>(gtab[,&nbsp;radial_order,&nbsp;])</td>
<td>The q:math:<cite>tau</cite>-dMRI model [1] to analytically and continuously represent the q:math:<cite>tau</cite> diffusion signal attenuation over diffusion sensitization q and diffusion time <span class="math notranslate nohighlight">\(\tau\)</span>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.GCV_cost_function" title="dipy.reconst.qtdmri.GCV_cost_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GCV_cost_function</span></code></a>(weight,&nbsp;arguments)</td>
<td>Generalized Cross Validation Function that is iterated [1].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.H" title="dipy.reconst.qtdmri.H"><code class="xref py py-obj docutils literal notranslate"><span class="pre">H</span></code></a>(value)</td>
<td>Step function of H(x)=1 if x&gt;=0 and zero otherwise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.angular_basis_EAP_opt" title="dipy.reconst.qtdmri.angular_basis_EAP_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angular_basis_EAP_opt</span></code></a>(j,&nbsp;l,&nbsp;m,&nbsp;r,&nbsp;theta,&nbsp;phi)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.angular_basis_opt" title="dipy.reconst.qtdmri.angular_basis_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angular_basis_opt</span></code></a>(l,&nbsp;m,&nbsp;q,&nbsp;theta,&nbsp;phi)</td>
<td>Angular basis independent of spatial scaling factor us.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.cart2sphere" title="dipy.reconst.qtdmri.cart2sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart2sphere</span></code></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.create_rt_space_grid" title="dipy.reconst.qtdmri.create_rt_space_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_rt_space_grid</span></code></a>(grid_size_r,&nbsp;)</td>
<td>Generates EAP grid (for potential positivity constraint).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.design_matrix_spatial" title="dipy.reconst.qtdmri.design_matrix_spatial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix_spatial</span></code></a>(bvecs,&nbsp;qvals[,&nbsp;dtype])</td>
<td>Constructs design matrix for DTI weighted least squares or least squares fitting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.elastic_crossvalidation" title="dipy.reconst.qtdmri.elastic_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">elastic_crossvalidation</span></code></a>(b0s_mask,&nbsp;E,&nbsp;M,&nbsp;L,&nbsp;lopt)</td>
<td>cross-validation function to find the optimal weight of alpha for sparsity regularization when also Laplacian regularization is used.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.factorial" title="dipy.reconst.qtdmri.factorial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorial</span></code></a>(n[,&nbsp;exact])</td>
<td>The factorial of a number or array of numbers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.factorial2" title="dipy.reconst.qtdmri.factorial2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorial2</span></code></a>(n[,&nbsp;exact])</td>
<td>Double factorial.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.fmin_l_bfgs_b" title="dipy.reconst.qtdmri.fmin_l_bfgs_b"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmin_l_bfgs_b</span></code></a>(func,&nbsp;x0[,&nbsp;fprime,&nbsp;args,&nbsp;])</td>
<td>Minimize a function func using the L-BFGS-B algorithm.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.generalized_crossvalidation" title="dipy.reconst.qtdmri.generalized_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generalized_crossvalidation</span></code></a>(data,&nbsp;M,&nbsp;LR[,&nbsp;])</td>
<td>Generalized Cross Validation Function [1].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.genlaguerre" title="dipy.reconst.qtdmri.genlaguerre"><code class="xref py py-obj docutils literal notranslate"><span class="pre">genlaguerre</span></code></a>(n,&nbsp;alpha[,&nbsp;monic])</td>
<td>Generalized (associated) Laguerre polynomial.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.gradient_table_from_gradient_strength_bvecs" title="dipy.reconst.qtdmri.gradient_table_from_gradient_strength_bvecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table_from_gradient_strength_bvecs</span></code></a>()</td>
<td>A general function for creating diffusion MR gradients.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.l1_crossvalidation" title="dipy.reconst.qtdmri.l1_crossvalidation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">l1_crossvalidation</span></code></a>(b0s_mask,&nbsp;E,&nbsp;M[,&nbsp;])</td>
<td>cross-validation function to find the optimal weight of alpha for sparsity regularization</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.multi_voxel_fit" title="dipy.reconst.qtdmri.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.optional_package" title="dipy.reconst.qtdmri.optional_package"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optional_package</span></code></a>(name[,&nbsp;trip_msg])</td>
<td>Return package-like thing and module setup for package <cite>name</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.part1_reg_matrix_tau" title="dipy.reconst.qtdmri.part1_reg_matrix_tau"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part1_reg_matrix_tau</span></code></a>(ind_mat,&nbsp;ut)</td>
<td>Partial temporal Laplacian regularization matrix following Appendix B in [1].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.part23_iso_reg_matrix_q" title="dipy.reconst.qtdmri.part23_iso_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part23_iso_reg_matrix_q</span></code></a>(ind_mat,&nbsp;us)</td>
<td>Partial spherical spatial Laplacian regularization matrix following the equation below Eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.part23_reg_matrix_q" title="dipy.reconst.qtdmri.part23_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part23_reg_matrix_q</span></code></a>(ind_mat,&nbsp;U_mat,&nbsp;T_mat,&nbsp;us)</td>
<td>Partial cartesian spatial Laplacian regularization matrix following second line of Eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.part23_reg_matrix_tau" title="dipy.reconst.qtdmri.part23_reg_matrix_tau"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part23_reg_matrix_tau</span></code></a>(ind_mat,&nbsp;ut)</td>
<td>Partial temporal Laplacian regularization matrix following Appendix B in [1].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.part4_iso_reg_matrix_q" title="dipy.reconst.qtdmri.part4_iso_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part4_iso_reg_matrix_q</span></code></a>(ind_mat,&nbsp;us)</td>
<td>Partial spherical spatial Laplacian regularization matrix following the equation below Eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.part4_reg_matrix_q" title="dipy.reconst.qtdmri.part4_reg_matrix_q"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part4_reg_matrix_q</span></code></a>(ind_mat,&nbsp;U_mat,&nbsp;us)</td>
<td>Partial cartesian spatial Laplacian regularization matrix following equation Eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.part4_reg_matrix_tau" title="dipy.reconst.qtdmri.part4_reg_matrix_tau"><code class="xref py py-obj docutils literal notranslate"><span class="pre">part4_reg_matrix_tau</span></code></a>(ind_mat,&nbsp;ut)</td>
<td>Partial temporal Laplacian regularization matrix following Appendix B in [1].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling" title="dipy.reconst.qtdmri.qtdmri_anisotropic_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_anisotropic_scaling</span></code></a>(data,&nbsp;q,&nbsp;bvecs,&nbsp;tau)</td>
<td>Constructs design matrix for fitting an exponential to the diffusion time points.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix" title="dipy.reconst.qtdmri.qtdmri_eap_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_eap_matrix</span></code></a>(radial_order,&nbsp;time_order,&nbsp;)</td>
<td>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix_" title="dipy.reconst.qtdmri.qtdmri_eap_matrix_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_eap_matrix_</span></code></a>(radial_order,&nbsp;time_order,&nbsp;)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_index_matrix" title="dipy.reconst.qtdmri.qtdmri_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_index_matrix</span></code></a>(radial_order,&nbsp;time_order)</td>
<td>Computes the SHORE basis order indices according to [1].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_eap_matrix</span></code></a>(radial_order,&nbsp;)</td>
<td>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_" title="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_eap_matrix_</span></code></a>(radial_order,&nbsp;)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_index_matrix</span></code></a>(radial_order,&nbsp;)</td>
<td>Computes the SHORE basis order indices according to [1].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_laplacian_reg_matrix</span></code></a>([,&nbsp;])</td>
<td>Computes the spherical qt-dMRI Laplacian regularization matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_scaling" title="dipy.reconst.qtdmri.qtdmri_isotropic_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_scaling</span></code></a>(data,&nbsp;q,&nbsp;tau)</td>
<td>Constructs design matrix for fitting an exponential to the diffusion time points.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_signal_matrix</span></code></a>(radial_order,&nbsp;)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_" title="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_signal_matrix_</span></code></a>([,&nbsp;])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix" title="dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_isotropic_to_mapmri_matrix</span></code></a>()</td>
<td>Generates the matrix that maps the spherical qtdmri coefficients to MAP-MRI coefficients.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix" title="dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_laplacian_reg_matrix</span></code></a>(ind_mat,&nbsp;us,&nbsp;ut)</td>
<td>Computes the cartesian qt-dMRI Laplacian regularization matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization" title="dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_mapmri_isotropic_normalization</span></code></a>(j,&nbsp;l,&nbsp;u0)</td>
<td>Normalization factor for Spherical MAP-MRI basis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_mapmri_normalization" title="dipy.reconst.qtdmri.qtdmri_mapmri_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_mapmri_normalization</span></code></a>(mu)</td>
<td>Normalization factor for Cartesian MAP-MRI basis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_number_of_coefficients" title="dipy.reconst.qtdmri.qtdmri_number_of_coefficients"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_number_of_coefficients</span></code></a>(radial_order,&nbsp;)</td>
<td>Computes the total number of coefficients of the qtdmri basis given a radial and temporal order.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix" title="dipy.reconst.qtdmri.qtdmri_signal_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_signal_matrix</span></code></a>(radial_order,&nbsp;)</td>
<td>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix_" title="dipy.reconst.qtdmri.qtdmri_signal_matrix_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_signal_matrix_</span></code></a>(radial_order,&nbsp;[,&nbsp;])</td>
<td>Function to generate the qtdmri signal basis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_temporal_normalization" title="dipy.reconst.qtdmri.qtdmri_temporal_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_temporal_normalization</span></code></a>(ut)</td>
<td>Normalization factor for the temporal basis</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix" title="dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_to_mapmri_matrix</span></code></a>(radial_order,&nbsp;)</td>
<td>Generates the matrix that maps the qtdmri coefficients to MAP-MRI coefficients.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.radial_basis_EAP_opt" title="dipy.reconst.qtdmri.radial_basis_EAP_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_basis_EAP_opt</span></code></a>(j,&nbsp;l,&nbsp;us,&nbsp;r)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.radial_basis_opt" title="dipy.reconst.qtdmri.radial_basis_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radial_basis_opt</span></code></a>(j,&nbsp;l,&nbsp;us,&nbsp;q)</td>
<td>Spatial basis dependent on spatial scaling factor us</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.real_sph_harm" title="dipy.reconst.qtdmri.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.temporal_basis" title="dipy.reconst.qtdmri.temporal_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">temporal_basis</span></code></a>(o,&nbsp;ut,&nbsp;tau)</td>
<td>Temporal basis dependent on temporal scaling factor ut</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow" title="dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualise_gradient_table_G_Delta_rainbow</span></code></a>(gtab)</td>
<td>This function visualizes a q-tau acquisition scheme as a function of gradient strength and pulse separation (big_delta).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.warn" title="dipy.reconst.qtdmri.warn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warn</span></code></a></td>
<td>Issue a warning, or maybe ignore it or raise an exception.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.scratch">
<span id="module-reconst-scratch"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.scratch</span></code><a class="headerlink" href="#module-dipy.reconst.scratch" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.sfm">
<span id="module-reconst-sfm"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.sfm</span></code><a class="headerlink" href="#module-dipy.reconst.sfm" title="Permalink to this headline"></a></h2>
<p>The Sparse Fascicle Model.</p>
<p>This is an implementation of the sparse fascicle model described in
<a class="reference internal" href="#r204bb22f26e5-rokem2015" id="id53">[R204bb22f26e5-Rokem2015]</a>. The multi b-value version of this model is described in
<a class="reference internal" href="#r204bb22f26e5-rokem2014" id="id54">[R204bb22f26e5-Rokem2014]</a>.</p>
<table class="docutils citation" frame="void" id="r204bb22f26e5-rokem2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id53">[R204bb22f26e5-Rokem2015]</a></td><td>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick
N. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell
(2015). Evaluating the accuracy of diffusion MRI models in white
matter. PLoS ONE 10(4): e0123272. doi:10.1371/journal.pone.0123272</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r204bb22f26e5-rokem2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id54">[R204bb22f26e5-Rokem2014]</a></td><td>Ariel Rokem, Kimberly L. Chan, Jason D. Yeatman, Franco
Pestilli,  Brian A. Wandell (2014). Evaluating the accuracy of diffusion
models at multiple b-values with cross-validation. ISMRM 2014.</td></tr>
</tbody>
</table>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.Cache" title="dipy.reconst.sfm.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="dipy.reconst.sfm.ExponentialIsotropicFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a>(model,&nbsp;params)</td>
<td>A fit to the ExponentialIsotropicModel object, based on data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="dipy.reconst.sfm.ExponentialIsotropicModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a>(gtab)</td>
<td>Representing the isotropic signal as a fit to an exponential decay function with b-values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a>(model,&nbsp;params)</td>
<td>A fit object for representing the isotropic signal as the mean of the diffusion-weighted signal.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a>(gtab)</td>
<td>A base-class for the representation of isotropic signals.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.ReconstFit" title="dipy.reconst.sfm.ReconstFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstFit</span></code></a>(model,&nbsp;data)</td>
<td>Abstract class which holds the fit result of ReconstModel</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.ReconstModel" title="dipy.reconst.sfm.ReconstModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReconstModel</span></code></a>(gtab)</td>
<td>Abstract class for signal reconstruction models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit" title="dipy.reconst.sfm.SparseFascicleFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a>(model,&nbsp;beta,&nbsp;S0,&nbsp;iso)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel" title="dipy.reconst.sfm.SparseFascicleModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a>(gtab[,&nbsp;sphere,&nbsp;])</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.auto_attr" title="dipy.reconst.sfm.auto_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_attr</span></code></a>(func)</td>
<td>Decorator to create OneTimeProperty attributes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.nanmean" title="dipy.reconst.sfm.nanmean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nanmean</span></code></a>(a[,&nbsp;axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Compute the arithmetic mean along the specified axis, ignoring NaNs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.optional_package" title="dipy.reconst.sfm.optional_package"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optional_package</span></code></a>(name[,&nbsp;trip_msg])</td>
<td>Return package-like thing and module setup for package <cite>name</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.sfm_design_matrix" title="dipy.reconst.sfm.sfm_design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sfm_design_matrix</span></code></a>(gtab,&nbsp;sphere,&nbsp;response[,&nbsp;mode])</td>
<td>Construct the SFM design matrix</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.shm">
<span id="module-reconst-shm"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shm</span></code><a class="headerlink" href="#module-dipy.reconst.shm" title="Permalink to this headline"></a></h2>
<p>Tools for using spherical harmonic models to fit diffusion data</p>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h3>
<dl class="docutils">
<dt>Aganj, I., et al. 2009. ODF Reconstruction in Q-Ball Imaging With Solid</dt>
<dd>Angle Consideration.</dd>
<dt>Descoteaux, M., et al. 2007. Regularized, fast, and robust analytical</dt>
<dd>Q-ball imaging.</dd>
<dt>Tristan-Vega, A., et al. 2010. A new methodology for estimation of fiber</dt>
<dd>populations in white matter of the brain with Funk-Radon transform.</dd>
<dt>Tristan-Vega, A., et al. 2009. Estimation of fiber orientation probability</dt>
<dd>density functions in high angular resolution diffusion imaging.</dd>
</dl>
<p>Note about the Transpose:
In the literature the matrix representation of these methods is often written
as Y = Bx where B is some design matrix and Y and x are column vectors. In our
case the input data, a dwi stored as a nifti file for example, is stored as row
vectors (ndarrays) of the form (x, y, z, n), where n is the number of diffusion
directions. We could transpose and reshape the data to be (n, x*y*z), so that
we could directly plug it into the above equation. However, I have chosen to
keep the data as is and implement the relevant equations rewritten in the
following form: Y.T = x.T B.T, or in python syntax data = np.dot(sh_coef, B.T)
where data is Y.T and sh_coef is x.T.</p>
</div>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.Cache" title="dipy.reconst.shm.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.CsaOdfModel" title="dipy.reconst.shm.CsaOdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a>(gtab,&nbsp;sh_order[,&nbsp;smooth,&nbsp;])</td>
<td>Implementation of Constant Solid Angle reconstruction method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.LooseVersion" title="dipy.reconst.shm.LooseVersion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LooseVersion</span></code></a>([vstring])</td>
<td>Version numbering for anarchists and software realists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.OdfFit" title="dipy.reconst.shm.OdfFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfFit</span></code></a>(model,&nbsp;data)</td>
<td><p class="rubric">Methods</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.OdfModel" title="dipy.reconst.shm.OdfModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OdfModel</span></code></a>(gtab)</td>
<td>An abstract class to be sub-classed by specific odf models</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.OpdtModel" title="dipy.reconst.shm.OpdtModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OpdtModel</span></code></a>(gtab,&nbsp;sh_order[,&nbsp;smooth,&nbsp;])</td>
<td>Implementation of Orientation Probability Density Transform reconstruction method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a>(gtab,&nbsp;sh_order[,&nbsp;smooth,&nbsp;])</td>
<td>To be subclassed by Qball type models.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.QballModel" title="dipy.reconst.shm.QballModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QballModel</span></code></a>(gtab,&nbsp;sh_order[,&nbsp;smooth,&nbsp;])</td>
<td>Implementation of regularized Qball reconstruction method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="dipy.reconst.shm.ResidualBootstrapWrapper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a>(signal_object,&nbsp;B,&nbsp;)</td>
<td>Returns a residual bootstrap sample of the signal_object when indexed</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a>(model,&nbsp;shm_coef,&nbsp;mask)</td>
<td>Diffusion data fit to a spherical harmonic model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a>(gtab)</td>
<td>To be subclassed by all models that return a SphHarmFit when fit.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.anisotropic_power" title="dipy.reconst.shm.anisotropic_power"><code class="xref py py-obj docutils literal notranslate"><span class="pre">anisotropic_power</span></code></a>(sh_coeffs[,&nbsp;norm_factor,&nbsp;])</td>
<td>Calculates anisotropic power map with a given SH coefficient matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.auto_attr" title="dipy.reconst.shm.auto_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auto_attr</span></code></a>(func)</td>
<td>Decorator to create OneTimeProperty attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.bootstrap_data_array" title="dipy.reconst.shm.bootstrap_data_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bootstrap_data_array</span></code></a>(data,&nbsp;H,&nbsp;R[,&nbsp;permute])</td>
<td>Applies the Residual Bootstraps to the data given H and R</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.bootstrap_data_voxel" title="dipy.reconst.shm.bootstrap_data_voxel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bootstrap_data_voxel</span></code></a>(data,&nbsp;H,&nbsp;R[,&nbsp;permute])</td>
<td>Like bootstrap_data_array but faster when for a single voxel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.calculate_max_order" title="dipy.reconst.shm.calculate_max_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_max_order</span></code></a>(n_coeffs)</td>
<td>Calculate the maximal harmonic order, given that you know the</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.cart2sphere" title="dipy.reconst.shm.cart2sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart2sphere</span></code></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.concatenate" title="dipy.reconst.shm.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a>((a1,&nbsp;a2,&nbsp;)[,&nbsp;axis,&nbsp;out])</td>
<td>Join a sequence of arrays along an existing axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.diag" title="dipy.reconst.shm.diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diag</span></code></a>(v[,&nbsp;k])</td>
<td>Extract a diagonal or construct a diagonal array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.diff" title="dipy.reconst.shm.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a>(a[,&nbsp;n,&nbsp;axis])</td>
<td>Calculate the n-th discrete difference along the given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.dot" title="dipy.reconst.shm.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>(a,&nbsp;b[,&nbsp;out])</td>
<td>Dot product of two arrays.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.empty" title="dipy.reconst.shm.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a>(shape[,&nbsp;dtype,&nbsp;order])</td>
<td>Return a new array of given shape and type, without initializing entries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.eye" title="dipy.reconst.shm.eye"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eye</span></code></a>(N[,&nbsp;M,&nbsp;k,&nbsp;dtype,&nbsp;order])</td>
<td>Return a 2-D array with ones on the diagonal and zeros elsewhere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.forward_sdeconv_mat" title="dipy.reconst.shm.forward_sdeconv_mat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward_sdeconv_mat</span></code></a>(r_rh,&nbsp;n)</td>
<td>Build forward spherical deconvolution matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.gen_dirac" title="dipy.reconst.shm.gen_dirac"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_dirac</span></code></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Generate Dirac delta function orientated in (theta, phi) on the sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.hat" title="dipy.reconst.shm.hat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hat</span></code></a>(B)</td>
<td>Returns the hat matrix for the design matrix B</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.lazy_index" title="dipy.reconst.shm.lazy_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lazy_index</span></code></a>(index)</td>
<td>Produces a lazy index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.lcr_matrix" title="dipy.reconst.shm.lcr_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lcr_matrix</span></code></a>(H)</td>
<td>Returns a matrix for computing leveraged, centered residuals from data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.lpn" title="dipy.reconst.shm.lpn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lpn</span></code></a>(n,&nbsp;z)</td>
<td>Legendre function of the first kind.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_data</span></code></a>(data,&nbsp;where_b0[,&nbsp;min_signal,&nbsp;out])</td>
<td>Normalizes the data with respect to the mean b0</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.order_from_ncoef" title="dipy.reconst.shm.order_from_ncoef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order_from_ncoef</span></code></a>(ncoef)</td>
<td>Given a number n of coefficients, calculate back the sh_order</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.pinv" title="dipy.reconst.shm.pinv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pinv</span></code></a>(a[,&nbsp;rcond])</td>
<td>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.randint" title="dipy.reconst.shm.randint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randint</span></code></a>(low[,&nbsp;high,&nbsp;size,&nbsp;dtype])</td>
<td>Return random integers from <cite>low</cite> (inclusive) to <cite>high</cite> (exclusive).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.real_sph_harm" title="dipy.reconst.shm.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.real_sym_sh_basis" title="dipy.reconst.shm.real_sym_sh_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sym_sh_basis</span></code></a>(sh_order,&nbsp;theta,&nbsp;phi)</td>
<td>Samples a real symmetric spherical harmonic basis at point on the sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.real_sym_sh_mrtrix" title="dipy.reconst.shm.real_sym_sh_mrtrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sym_sh_mrtrix</span></code></a>(sh_order,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics as in Tournier 2007 <a class="reference internal" href="#r220a2be8a767-2" id="id55">[2]</a>, where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.sf_to_sh" title="dipy.reconst.shm.sf_to_sh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sf_to_sh</span></code></a>(sf,&nbsp;sphere[,&nbsp;sh_order,&nbsp;basis_type,&nbsp;])</td>
<td>Spherical function to spherical harmonics (SH).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.sh_to_rh" title="dipy.reconst.shm.sh_to_rh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_rh</span></code></a>(r_sh,&nbsp;m,&nbsp;n)</td>
<td>Spherical harmonics (SH) to rotational harmonics (RH)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.sh_to_sf" title="dipy.reconst.shm.sh_to_sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_sf</span></code></a>(sh,&nbsp;sphere,&nbsp;sh_order[,&nbsp;basis_type])</td>
<td>Spherical harmonics (SH) to spherical function (SF).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.sh_to_sf_matrix" title="dipy.reconst.shm.sh_to_sf_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_to_sf_matrix</span></code></a>(sphere,&nbsp;sh_order[,&nbsp;])</td>
<td>Matrix that transforms Spherical harmonics (SH) to spherical function (SF).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.smooth_pinv" title="dipy.reconst.shm.smooth_pinv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth_pinv</span></code></a>(B,&nbsp;L)</td>
<td>Regularized pseudo-inverse</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.sph_harm_ind_list" title="dipy.reconst.shm.sph_harm_ind_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sph_harm_ind_list</span></code></a>(sh_order)</td>
<td>Returns the degree (n) and order (m) of all the symmetric spherical harmonics of degree less then or equal to <cite>sh_order</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.spherical_harmonics" title="dipy.reconst.shm.spherical_harmonics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spherical_harmonics</span></code></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute spherical harmonics</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.svd" title="dipy.reconst.shm.svd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">svd</span></code></a>(a[,&nbsp;full_matrices,&nbsp;compute_uv])</td>
<td>Singular Value Decomposition.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.unique" title="dipy.reconst.shm.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>(ar[,&nbsp;return_index,&nbsp;return_inverse,&nbsp;])</td>
<td>Find the unique elements of an array.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.shore">
<span id="module-reconst-shore"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.shore</span></code><a class="headerlink" href="#module-dipy.reconst.shore" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.Cache" title="dipy.reconst.shore.Cache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cache</span></code></a></td>
<td>Cache values based on a key object (such as a sphere or gradient table).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit" title="dipy.reconst.shore.ShoreFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShoreFit</span></code></a>(model,&nbsp;shore_coef)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreModel" title="dipy.reconst.shore.ShoreModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShoreModel</span></code></a>(gtab[,&nbsp;radial_order,&nbsp;zeta,&nbsp;])</td>
<td>Simple Harmonic Oscillator based Reconstruction and Estimation (SHORE) <a class="reference internal" href="#rd47fc6332129-1" id="id56">[1]</a> of the diffusion signal.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.cart2sphere" title="dipy.reconst.shore.cart2sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart2sphere</span></code></a>(x,&nbsp;y,&nbsp;z)</td>
<td>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.create_rspace" title="dipy.reconst.shore.create_rspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_rspace</span></code></a>(gridsize,&nbsp;radius_max)</td>
<td>Create the real space table, that contains the points in which</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.factorial" title="dipy.reconst.shore.factorial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorial</span></code></a>(x)</td>
<td>Find x!.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.genlaguerre" title="dipy.reconst.shore.genlaguerre"><code class="xref py py-obj docutils literal notranslate"><span class="pre">genlaguerre</span></code></a>(n,&nbsp;alpha[,&nbsp;monic])</td>
<td>Generalized (associated) Laguerre polynomial.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.l_shore" title="dipy.reconst.shore.l_shore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">l_shore</span></code></a>(radial_order)</td>
<td>Returns the angular regularisation matrix for SHORE basis</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.multi_voxel_fit" title="dipy.reconst.shore.multi_voxel_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_voxel_fit</span></code></a>(single_voxel_fit)</td>
<td>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.n_shore" title="dipy.reconst.shore.n_shore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_shore</span></code></a>(radial_order)</td>
<td>Returns the angular regularisation matrix for SHORE basis</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.optional_package" title="dipy.reconst.shore.optional_package"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optional_package</span></code></a>(name[,&nbsp;trip_msg])</td>
<td>Return package-like thing and module setup for package <cite>name</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.real_sph_harm" title="dipy.reconst.shore.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a>(m,&nbsp;n,&nbsp;theta,&nbsp;phi)</td>
<td>Compute real spherical harmonics.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.shore_indices" title="dipy.reconst.shore.shore_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_indices</span></code></a>(radial_order,&nbsp;index)</td>
<td>Given the basis order and the index, return the shore indices n, l, m for modified Merlets 3D-SHORE ..math::         :nowrap:             begin{equation}                 textbf{E}(qtextbf{u})=sum_{l=0, even}^{N_{max}}                                         sum_{n=l}^{(N_{max}+l)/2}                                         sum_{m=-l}^l c_{nlm}                                         phi_{nlm}(qtextbf{u})             end{equation}</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.shore_matrix" title="dipy.reconst.shore.shore_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_matrix</span></code></a>(radial_order,&nbsp;zeta,&nbsp;gtab[,&nbsp;tau])</td>
<td>Compute the SHORE matrix for modified Merlets 3D-SHORE <a class="reference internal" href="#r0425af01b43f-1" id="id57">[1]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.shore_matrix_odf" title="dipy.reconst.shore.shore_matrix_odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_matrix_odf</span></code></a>(radial_order,&nbsp;zeta,&nbsp;)</td>
<td>Compute the SHORE ODF matrix <a class="reference internal" href="#r0934fd177e35-1" id="id58">[1]</a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.shore_matrix_pdf" title="dipy.reconst.shore.shore_matrix_pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_matrix_pdf</span></code></a>(radial_order,&nbsp;zeta,&nbsp;rtab)</td>
<td>Compute the SHORE propagator matrix <a class="reference internal" href="#r5470c7e1e272-1" id="id59">[1]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.shore_order" title="dipy.reconst.shore.shore_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_order</span></code></a>(n,&nbsp;l,&nbsp;m)</td>
<td>Given the indices (n,l,m) of the basis, return the minimum order for those indices and their index for modified Merlets 3D-SHORE.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.warn" title="dipy.reconst.shore.warn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warn</span></code></a></td>
<td>Issue a warning, or maybe ignore it or raise an exception.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.reconst.utils">
<span id="module-reconst-utils"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">reconst.utils</span></code><a class="headerlink" href="#module-dipy.reconst.utils" title="Permalink to this headline"></a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.utils.dki_design_matrix" title="dipy.reconst.utils.dki_design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dki_design_matrix</span></code></a>(gtab)</td>
<td>Constructs B design matrix for DKI</td>
</tr>
</tbody>
</table>
<div class="section" id="bench">
<h3>bench<a class="headerlink" href="#bench" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.bench">
<code class="descclassname">dipy.reconst.</code><code class="descname">bench</code><span class="sig-paren">(</span><em>label='fast'</em>, <em>verbose=1</em>, <em>extra_argv=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.bench" title="Permalink to this definition"></a></dt>
<dd><p>Run benchmarks for module using nose.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{fast, full, , attribute identifier}, optional</span></dt>
<dd><p class="first">Identifies the benchmarks to run. This can be a string to pass to
the nosetests executable with the -A option, or one of several
special values.  Special values are:
* fast - the default - which corresponds to the <code class="docutils literal notranslate"><span class="pre">nosetests</span> <span class="pre">-A</span></code></p>
<blockquote>
<div><p>option of not slow.</p>
</div></blockquote>
<ul class="simple">
<li>full - fast (as above) and slow benchmarks as in the
no -A option to nosetests - this is the same as .</li>
<li>None or  - run all tests.</li>
</ul>
<p class="last">attribute_identifier - string passed directly to nosetests as -A.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Verbosity value for benchmark outputs, in the range 1-10. Default is 1.</p>
</dd>
<dt><strong>extra_argv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last">List with any extra arguments to pass to nosetests.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Returns True if running the benchmarks works, False if an error
occurred.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Benchmarks are like tests, but have names starting with bench instead
of test, and can be found under the benchmarks sub-directory of the
module.</p>
<p>Each NumPy module exposes <cite>bench</cite> in its namespace to run all benchmarks
for it.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">success</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span> 
<span class="go">Running benchmarks for numpy.lib</span>
<span class="gp">...</span>
<span class="go">using 562341 items:</span>
<span class="go">unique:</span>
<span class="go">0.11</span>
<span class="go">unique1d:</span>
<span class="go">0.11</span>
<span class="go">ratio: 1.0</span>
<span class="go">nUnique: 56230 == 56230</span>
<span class="gp">...</span>
<span class="go">OK</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">success</span> 
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="test">
<h3>test<a class="headerlink" href="#test" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.test">
<code class="descclassname">dipy.reconst.</code><code class="descname">test</code><span class="sig-paren">(</span><em>label='fast'</em>, <em>verbose=1</em>, <em>extra_argv=None</em>, <em>doctests=False</em>, <em>coverage=False</em>, <em>raise_warnings=None</em>, <em>timer=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.test" title="Permalink to this definition"></a></dt>
<dd><p>Run tests for module using nose.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{fast, full, , attribute identifier}, optional</span></dt>
<dd><p class="first">Identifies the tests to run. This can be a string to pass to
the nosetests executable with the -A option, or one of several
special values.  Special values are:
* fast - the default - which corresponds to the <code class="docutils literal notranslate"><span class="pre">nosetests</span> <span class="pre">-A</span></code></p>
<blockquote>
<div><p>option of not slow.</p>
</div></blockquote>
<ul class="simple">
<li>full - fast (as above) and slow tests as in the
no -A option to nosetests - this is the same as .</li>
<li>None or  - run all tests.</li>
</ul>
<p class="last">attribute_identifier - string passed directly to nosetests as -A.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Verbosity value for test outputs, in the range 1-10. Default is 1.</p>
</dd>
<dt><strong>extra_argv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last">List with any extra arguments to pass to nosetests.</p>
</dd>
<dt><strong>doctests</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, run doctests in module. Default is False.</p>
</dd>
<dt><strong>coverage</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If True, report coverage of NumPy code. Default is False.
(This requires the <a href="#id60"><span class="problematic" id="id61">`</span></a>coverage module:</p>
<blockquote class="last">
<div><p>&lt;<a class="reference external" href="http://nedbatchelder.com/code/modules/coverage.html">http://nedbatchelder.com/code/modules/coverage.html</a>&gt;`_).</p>
</div></blockquote>
</dd>
<dt><strong>raise_warnings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None, str or sequence of warnings, optional</span></dt>
<dd><p class="first">This specifies which warnings to configure as raise instead
of being shown once during the test execution.  Valid strings are:</p>
<blockquote>
<div><ul class="simple">
<li>develop : equals <code class="docutils literal notranslate"><span class="pre">(Warning,)</span></code></li>
<li>release : equals <code class="docutils literal notranslate"><span class="pre">()</span></code>, dont raise on any warnings.</li>
</ul>
</div></blockquote>
<p class="last">The default is to use the class initialization value.</p>
</dd>
<dt><strong>timer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool or int, optional</span></dt>
<dd><p class="first last">Timing of individual tests with <code class="docutils literal notranslate"><span class="pre">nose-timer</span></code> (which needs to be
installed).  If True, time tests and report on all of them.
If an integer (say <code class="docutils literal notranslate"><span class="pre">N</span></code>), report timing results for <code class="docutils literal notranslate"><span class="pre">N</span></code> slowest
tests.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns the result of running the tests as a
<code class="docutils literal notranslate"><span class="pre">nose.result.TextTestResult</span></code> object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Each NumPy module exposes <cite>test</cite> in its namespace to run all tests for it.
For example, to run all tests for numpy.lib:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">test</span><span class="p">()</span> 
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">test</span><span class="p">()</span> 
<span class="go">Running unit tests for numpy.lib</span>
<span class="gp">...</span>
<span class="go">Ran 976 tests in 3.933s</span>
</pre></div>
</div>
<p>OK</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">errors</span> 
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">knownfail</span> 
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="reconstfit">
<h3><a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><a class="headerlink" href="#reconstfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.base.ReconstFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.base.</code><code class="descname">ReconstFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.base.ReconstFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="reconstmodel">
<h3><a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#reconstmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.base.ReconstModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.base.</code><code class="descname">ReconstModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.base.ReconstModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.base.ReconstModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.base.ReconstModel.fit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="bench-bounding-box">
<h3>bench_bounding_box<a class="headerlink" href="#bench-bounding-box" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box">
<code class="descclassname">dipy.reconst.benchmarks.bench_bounding_box.</code><code class="descname">bench_bounding_box</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="bounding-box">
<h3>bounding_box<a class="headerlink" href="#bounding-box" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_bounding_box.bounding_box">
<code class="descclassname">dipy.reconst.benchmarks.bench_bounding_box.</code><code class="descname">bounding_box</code><span class="sig-paren">(</span><em>vol</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_bounding_box.bounding_box" title="Permalink to this definition"></a></dt>
<dd><p>Compute the bounding box of nonzero intensity voxels in the volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Volume to compute bounding box on.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>npmins</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Array containg minimum index of each dimension</p>
</dd>
<dt><strong>npmaxs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Array containg maximum index of each dimension</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="measure">
<h3>measure<a class="headerlink" href="#measure" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_bounding_box.measure">
<code class="descclassname">dipy.reconst.benchmarks.bench_bounding_box.</code><code class="descname">measure</code><span class="sig-paren">(</span><em>code_str</em>, <em>times=1</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_bounding_box.measure" title="Permalink to this definition"></a></dt>
<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>
<p>The supplied code string is compiled with the Python builtin <code class="docutils literal notranslate"><span class="pre">compile</span></code>.
The precision of the timing is 10 milli-seconds. If the code will execute
fast on this timescale, it can be executed many times to get reasonable
timing accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>code_str</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The code to be timed.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of times the code is executed. Default is 1. The code is
only compiled once.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A label to identify <cite>code_str</cite> with. This is passed into <code class="docutils literal notranslate"><span class="pre">compile</span></code>
as the second argument (for run-time error messages).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>elapsed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">etime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="s1">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time for a single execution : &quot;</span><span class="p">,</span> <span class="n">etime</span> <span class="o">/</span> <span class="n">times</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
<span class="go">Time for a single execution :  0.005 s</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="constrainedsphericaldeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel" title="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a><a class="headerlink" href="#constrainedsphericaldeconvmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.benchmarks.bench_csd.</code><code class="descname">ConstrainedSphericalDeconvModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>response</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1</em>, <em>tau=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.shm.SphHarmModel</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit" title="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict" title="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(sh_coeff[,&nbsp;gtab,&nbsp;S0])</td>
<td>Compute a signal prediction given spherical harmonic coefficients for the provided GradientTable class instance.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>response</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1</em>, <em>tau=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constrained Spherical Deconvolution (CSD) <a class="reference internal" href="#r82c564debcff-1" id="id62">[1]</a>.</p>
<p>Spherical deconvolution computes a fiber orientation distribution
(FOD), also called fiber ODF (fODF) <a class="reference internal" href="#r82c564debcff-2" id="id63">[2]</a>, as opposed to a diffusion ODF
as the QballModel or the CsaOdfModel. This results in a sharper angular
profile with better angular resolution that is the best object to be
used for later deterministic and probabilistic tractography <a class="reference internal" href="#r82c564debcff-3" id="id64">[3]</a>.</p>
<p>A sharp fODF is obtained because a single fiber <em>response</em> function is
injected as <em>a priori</em> knowledge. The response function is often
data-driven and is thus provided as input to the
ConstrainedSphericalDeconvModel. It will be used as deconvolution
kernel, as described in <a class="reference internal" href="#r82c564debcff-1" id="id65">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>response</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple or AxSymShResponse object</span></dt>
<dd><p class="first last">A tuple with two elements. The first is the eigen-values as an (3,)
ndarray and the second is the signal value for the response
function without diffusion weighting.  This is to be able to
generate a single fiber synthetic signal. The response function
will be used as deconvolution kernel (<a class="reference internal" href="#r82c564debcff-1" id="id66">[1]</a>)</p>
</dd>
<dt><strong>reg_sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere (optional)</span></dt>
<dd><p class="first last">sphere used to build the regularization B matrix.
Default: symmetric362.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">maximal spherical harmonics order. Default: 8</p>
</dd>
<dt><strong>lambda_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">weight given to the constrained-positivity regularization part of
the deconvolution equation (see <a class="reference internal" href="#r82c564debcff-1" id="id67">[1]</a>). Default: 1</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">threshold controlling the amplitude below which the corresponding
fODF is assumed to be zero.  Ideally, tau should be set to
zero. However, to improve the stability of the algorithm, tau is
set to tau*100 % of the mean fODF amplitude (here, 10% by default)
(see <a class="reference internal" href="#r82c564debcff-1" id="id68">[1]</a>). Default: 0.1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r82c564debcff-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id62">1</a>, <a class="fn-backref" href="#id65">2</a>, <a class="fn-backref" href="#id66">3</a>, <a class="fn-backref" href="#id67">4</a>, <a class="fn-backref" href="#id68">5</a>, <a class="fn-backref" href="#id69">6</a>)</em> Tournier, J.D., et al. NeuroImage 2007. Robust determination of
the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical
deconvolution</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r82c564debcff-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id63">1</a>, <a class="fn-backref" href="#id70">2</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r82c564debcff-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id64">1</a>, <a class="fn-backref" href="#id71">2</a>)</em> C^ote, M-A., et al. Medical Image Analysis 2013. Tractometer:
Towards validation of tractography pipelines</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r82c564debcff-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id72">[4]</a></td><td>Tournier, J.D, et al. Imaging Systems and Technology
2012. MRtrix: Diffusion Tractography in Crossing Fiber Regions</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>sh_coeff</em>, <em>gtab=None</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict" title="Permalink to this definition"></a></dt>
<dd><p>Compute a signal prediction given spherical harmonic coefficients
for the provided GradientTable class instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh_coeff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The spherical harmonic representation of the FOD from which to make
the signal prediction.</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd><p class="first last">The gradients for which the signal will be predicted. Use the
models gradient table by default.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or float</span></dt>
<dd><p class="first last">The non diffusion-weighted signal value.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pred_sig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The predicted signal.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="gradienttable">
<h3><a class="reference internal" href="#dipy.reconst.benchmarks.bench_csd.GradientTable" title="dipy.reconst.benchmarks.bench_csd.GradientTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientTable</span></code></a><a class="headerlink" href="#gradienttable" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable">
<em class="property">class </em><code class="descclassname">dipy.reconst.benchmarks.bench_csd.</code><code class="descname">GradientTable</code><span class="sig-paren">(</span><em>gradients</em>, <em>big_delta=None</em>, <em>small_delta=None</em>, <em>b0_threshold=50</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Diffusion gradient information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gradients</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (N, 3)</span></dt>
<dd><p class="first last">Diffusion gradients. The direction of each of these vectors corresponds
to the b-vector, and the length corresponds to the b-value.</p>
</dd>
<dt><strong>b0_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Gradients with b-value less than or equal to <cite>b0_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient_table</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The GradientTable object is immutable. Do NOT assign attributes.
If you have your gradient table in a bval &amp; bvec format, we recommend
using the factory function gradient_table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gradients</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,3) ndarray</span></dt>
<dd><p class="first last">diffusion gradients</p>
</dd>
<dt><strong>bvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last">The b-value, or magnitude, of each gradient direction.</p>
</dd>
<dt><strong>qvals: (N,) ndarray</strong></dt>
<dd><p class="first last">The q-value for each gradient direction. Needs big and small
delta.</p>
</dd>
<dt><strong>bvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,3) ndarray</span></dt>
<dd><p class="first last">The direction, represented as a unit vector, of each gradient.</p>
</dd>
<dt><strong>b0s_mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last">Boolean array indicating which gradients have no diffusion
weighting, ie b-value is close to 0.</p>
</dd>
<dt><strong>b0_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Gradients with b-value less than or equal to <cite>b0_threshold</cite> are
considered to not have diffusion weighting.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="68%" />
<col width="32%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>b0s_mask</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>bvals</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>bvecs</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>gradient_strength</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>qvals</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>tau</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gradients</em>, <em>big_delta=None</em>, <em>small_delta=None</em>, <em>b0_threshold=50</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructor for GradientTable class</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask">
<code class="descname">b0s_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.bvals">
<code class="descname">bvals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.bvals" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs">
<code class="descname">bvecs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.gradient_strength">
<code class="descname">gradient_strength</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.gradient_strength" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.info">
<code class="descname">info</code><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.info" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.qvals">
<code class="descname">qvals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.qvals" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.benchmarks.bench_csd.GradientTable.tau">
<code class="descname">tau</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.GradientTable.tau" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="bench-csdeconv">
<h3>bench_csdeconv<a class="headerlink" href="#bench-csdeconv" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_csd.bench_csdeconv">
<code class="descclassname">dipy.reconst.benchmarks.bench_csd.</code><code class="descname">bench_csdeconv</code><span class="sig-paren">(</span><em>center=(50</em>, <em>40</em>, <em>40)</em>, <em>width=12</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.bench_csdeconv" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="num-grad">
<h3>num_grad<a class="headerlink" href="#num-grad" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_csd.num_grad">
<code class="descclassname">dipy.reconst.benchmarks.bench_csd.</code><code class="descname">num_grad</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.num_grad" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="read-stanford-labels">
<h3>read_stanford_labels<a class="headerlink" href="#read-stanford-labels" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_csd.read_stanford_labels">
<code class="descclassname">dipy.reconst.benchmarks.bench_csd.</code><code class="descname">read_stanford_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_csd.read_stanford_labels" title="Permalink to this definition"></a></dt>
<dd><p>Read stanford hardi data and label map</p>
</dd></dl>

</div>
<div class="section" id="bench-local-maxima">
<h3>bench_local_maxima<a class="headerlink" href="#bench-local-maxima" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.bench_local_maxima">
<code class="descclassname">dipy.reconst.benchmarks.bench_peaks.</code><code class="descname">bench_local_maxima</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.bench_local_maxima" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="get-sphere">
<h3>get_sphere<a class="headerlink" href="#get-sphere" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.get_sphere">
<code class="descclassname">dipy.reconst.benchmarks.bench_peaks.</code><code class="descname">get_sphere</code><span class="sig-paren">(</span><em>name='symmetric362'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.get_sphere" title="Permalink to this definition"></a></dt>
<dd><p>provide triangulated spheres</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">which sphere - one of:
* symmetric362
* symmetric642
* symmetric724
* repulsion724
* repulsion100
* repulsion200</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a dipy.core.sphere.Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;symmetric362&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">sphere</span><span class="o">.</span><span class="n">faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">362</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">720</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;not a sphere name&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">DataError</span>: <span class="n">No sphere called &quot;not a sphere name&quot;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="local-maxima">
<h3>local_maxima<a class="headerlink" href="#local-maxima" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.local_maxima">
<code class="descclassname">dipy.reconst.benchmarks.bench_peaks.</code><code class="descname">local_maxima</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.local_maxima" title="Permalink to this definition"></a></dt>
<dd><p>Local maxima of a function evaluated on a discrete set of points.</p>
<p>If a function is evaluated on some set of points where each pair of
neighboring points is an edge in edges, find the local maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, 1d, dtype=double</span></dt>
<dd><p class="first last">The function evaluated on a set of discrete points.</p>
</dd>
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, 2)</span></dt>
<dd><p class="first last">The set of neighbor relations between the points. Every edge, ie
<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>peak_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Value of odf at a maximum point. Peak values is sorted in descending
order.</p>
</dd>
<dt><strong>peak_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so
<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="dipy.core.html#module-dipy.core.sphere" title="dipy.core.sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dipy.core.sphere</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="id73">
<h3>measure<a class="headerlink" href="#id73" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.measure">
<code class="descclassname">dipy.reconst.benchmarks.bench_peaks.</code><code class="descname">measure</code><span class="sig-paren">(</span><em>code_str</em>, <em>times=1</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.measure" title="Permalink to this definition"></a></dt>
<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>
<p>The supplied code string is compiled with the Python builtin <code class="docutils literal notranslate"><span class="pre">compile</span></code>.
The precision of the timing is 10 milli-seconds. If the code will execute
fast on this timescale, it can be executed many times to get reasonable
timing accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>code_str</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The code to be timed.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of times the code is executed. Default is 1. The code is
only compiled once.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A label to identify <cite>code_str</cite> with. This is passed into <code class="docutils literal notranslate"><span class="pre">compile</span></code>
as the second argument (for run-time error messages).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>elapsed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">etime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="s1">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time for a single execution : &quot;</span><span class="p">,</span> <span class="n">etime</span> <span class="o">/</span> <span class="n">times</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
<span class="go">Time for a single execution :  0.005 s</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="unique-edges">
<h3>unique_edges<a class="headerlink" href="#unique-edges" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_peaks.unique_edges">
<code class="descclassname">dipy.reconst.benchmarks.bench_peaks.</code><code class="descname">unique_edges</code><span class="sig-paren">(</span><em>faces</em>, <em>return_mapping=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_peaks.unique_edges" title="Permalink to this definition"></a></dt>
<dd><p>Extract all unique edges from given triangular faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>faces</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 3) ndarray</span></dt>
<dd><p class="first last">Vertex indices forming triangular faces.</p>
</dd>
<dt><strong>return_mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, a mapping to the edges of each face is returned.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) ndarray</span></dt>
<dd><p class="first last">Unique edges.</p>
</dd>
<dt><strong>mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 3)</span></dt>
<dd><p class="first">For each face, [x, y, z], a mapping to its edges [a, b, c].</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span>   y
   /               /               a/    
/                  /                   /__________          x      c     z
</pre></div>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="bench-quick-squash">
<h3>bench_quick_squash<a class="headerlink" href="#bench-quick-squash" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.bench_quick_squash">
<code class="descclassname">dipy.reconst.benchmarks.bench_squash.</code><code class="descname">bench_quick_squash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.bench_quick_squash" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id74">
<h3>measure<a class="headerlink" href="#id74" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.measure">
<code class="descclassname">dipy.reconst.benchmarks.bench_squash.</code><code class="descname">measure</code><span class="sig-paren">(</span><em>code_str</em>, <em>times=1</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.measure" title="Permalink to this definition"></a></dt>
<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>
<p>The supplied code string is compiled with the Python builtin <code class="docutils literal notranslate"><span class="pre">compile</span></code>.
The precision of the timing is 10 milli-seconds. If the code will execute
fast on this timescale, it can be executed many times to get reasonable
timing accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>code_str</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The code to be timed.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of times the code is executed. Default is 1. The code is
only compiled once.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A label to identify <cite>code_str</cite> with. This is passed into <code class="docutils literal notranslate"><span class="pre">compile</span></code>
as the second argument (for run-time error messages).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>elapsed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">etime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="s1">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time for a single execution : &quot;</span><span class="p">,</span> <span class="n">etime</span> <span class="o">/</span> <span class="n">times</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
<span class="go">Time for a single execution :  0.005 s</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ndindex">
<h3>ndindex<a class="headerlink" href="#ndindex" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.ndindex">
<code class="descclassname">dipy.reconst.benchmarks.bench_squash.</code><code class="descname">ndindex</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.ndindex" title="Permalink to this definition"></a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd><p class="first last">The dimensions of the array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="k">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="old-squash">
<h3>old_squash<a class="headerlink" href="#old-squash" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.old_squash">
<code class="descclassname">dipy.reconst.benchmarks.bench_squash.</code><code class="descname">old_squash</code><span class="sig-paren">(</span><em>arr</em>, <em>mask=None</em>, <em>fill=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.old_squash" title="Permalink to this definition"></a></dt>
<dd><p>Try and make a standard array from an object array</p>
<p>This function takes an object array and attempts to convert it to a more
useful dtype. If array can be converted to a better dtype, Nones are
replaced by <cite>fill</cite>. To make the behaviour of this function more clear, here
are the most common cases:</p>
<ol class="arabic simple">
<li><cite>arr</cite> is an array of scalars of type <cite>T</cite>. Returns an array like
<cite>arr.astype(T)</cite></li>
<li><cite>arr</cite> is an array of arrays. All items in <cite>arr</cite> have the same shape
<cite>S</cite>. Returns an array with shape <cite>arr.shape + S</cite>.</li>
<li><cite>arr</cite> is an array of arrays of different shapes. Returns <cite>arr</cite>.</li>
<li>Items in <cite>arr</cite> are not ndarrys or scalars. Returns <cite>arr</cite>.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype=object</span></dt>
<dd><p class="first last">The array to be converted.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype=bool, optional</span></dt>
<dd><p class="first last">Where arr has Nones.</p>
</dd>
<dt><strong>fill</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number, optional</span></dt>
<dd><p class="first last">Nones are replaced by fill.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([2, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([0, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">old_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="quick-squash">
<h3>quick_squash<a class="headerlink" href="#quick-squash" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.quick_squash">
<code class="descclassname">dipy.reconst.benchmarks.bench_squash.</code><code class="descname">quick_squash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.quick_squash" title="Permalink to this definition"></a></dt>
<dd><p>Try and make a standard array from an object array</p>
<p>This function takes an object array and attempts to convert it to a more
useful dtype. If array can be converted to a better dtype, Nones are
replaced by <cite>fill</cite>. To make the behaviour of this function more clear, here
are the most common cases:</p>
<ol class="arabic simple">
<li><cite>obj_arr</cite> is an array of scalars of type <cite>T</cite>. Returns an array like
<cite>obj_arr.astype(T)</cite></li>
<li><cite>obj_arr</cite> is an array of arrays. All items in <cite>obj_arr</cite> have the same
shape <code class="docutils literal notranslate"><span class="pre">S</span></code>. Returns an array with shape <code class="docutils literal notranslate"><span class="pre">obj_arr.shape</span> <span class="pre">+</span> <span class="pre">S</span></code></li>
<li><cite>obj_arr</cite> is an array of arrays of different shapes. Returns <cite>obj_arr</cite>.</li>
<li>Items in <cite>obj_arr</cite> are not ndarrays or scalars. Returns <cite>obj_arr</cite>.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj_arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype=object</span></dt>
<dd><p class="first last">The array to be converted.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype=bool, optional</span></dt>
<dd><p class="first last">mask is nonzero where <cite>obj_arr</cite> has Nones.</p>
</dd>
<dt><strong>fill</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number, optional</span></dt>
<dd><p class="first last">Nones are replaced by <cite>fill</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quick_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([2, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quick_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([0, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">quick_squash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="reduce">
<h3>reduce<a class="headerlink" href="#reduce" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_squash.reduce">
<code class="descclassname">dipy.reconst.benchmarks.bench_squash.</code><code class="descname">reduce</code><span class="sig-paren">(</span><em>function</em>, <em>sequence</em><span class="optional">[</span>, <em>initial</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; value<a class="headerlink" href="#dipy.reconst.benchmarks.bench_squash.reduce" title="Permalink to this definition"></a></dt>
<dd><p>Apply a function of two arguments cumulatively to the items of a sequence,
from left to right, so as to reduce the sequence to a single value.
For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
of the sequence in the calculation, and serves as a default when the
sequence is empty.</p>
</dd></dl>

</div>
<div class="section" id="bench-vec-val-vect">
<h3>bench_vec_val_vect<a class="headerlink" href="#bench-vec-val-vect" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect">
<code class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</code><code class="descname">bench_vec_val_vect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id75">
<h3>measure<a class="headerlink" href="#id75" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.measure">
<code class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</code><code class="descname">measure</code><span class="sig-paren">(</span><em>code_str</em>, <em>times=1</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.measure" title="Permalink to this definition"></a></dt>
<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>
<p>The supplied code string is compiled with the Python builtin <code class="docutils literal notranslate"><span class="pre">compile</span></code>.
The precision of the timing is 10 milli-seconds. If the code will execute
fast on this timescale, it can be executed many times to get reasonable
timing accuracy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>code_str</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The code to be timed.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of times the code is executed. Default is 1. The code is
only compiled once.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A label to identify <cite>code_str</cite> with. This is passed into <code class="docutils literal notranslate"><span class="pre">compile</span></code>
as the second argument (for run-time error messages).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>elapsed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">etime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="s1">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time for a single execution : &quot;</span><span class="p">,</span> <span class="n">etime</span> <span class="o">/</span> <span class="n">times</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
<span class="go">Time for a single execution :  0.005 s</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="randn">
<h3>randn<a class="headerlink" href="#randn" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.randn">
<code class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</code><code class="descname">randn</code><span class="sig-paren">(</span><em>d0</em>, <em>d1</em>, <em>...</em>, <em>dn</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.randn" title="Permalink to this definition"></a></dt>
<dd><p>Return a sample (or samples) from the standard normal distribution.</p>
<p>If positive, int_like or int-convertible arguments are provided,
<cite>randn</cite> generates an array of shape <code class="docutils literal notranslate"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></code>, filled
with random floats sampled from a univariate normal (Gaussian)
distribution of mean 0 and variance 1 (if any of the <span class="math notranslate nohighlight">\(d_i\)</span> are
floats, they are first converted to integers by truncation). A single
float randomly sampled from the distribution is returned if no
argument is provided.</p>
<p>This is a convenience function.  If you want an interface that takes a
tuple as the first argument, use <cite>numpy.random.standard_normal</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>d0, d1, , dn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The dimensions of the returned array, should be all positive.
If no argument is given a single Python float is returned.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or float</span></dt>
<dd><p class="first last">A <code class="docutils literal notranslate"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></code>-shaped array of floating-point samples from
the standard normal distribution, or a single such float if
no parameters were supplied.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">standard_normal</span></code></dt>
<dd>Similar, but takes a tuple as its argument.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For random samples from <span class="math notranslate nohighlight">\(N(\mu, \sigma^2)\)</span>, use:</p>
<p><code class="docutils literal notranslate"><span class="pre">sigma</span> <span class="pre">*</span> <span class="pre">np.random.randn(...)</span> <span class="pre">+</span> <span class="pre">mu</span></code></p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
<span class="go">2.1923875335537315 #random</span>
</pre></div>
</div>
<p>Two-by-four array of samples from N(3, 6.25):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
<span class="go">array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],  #random</span>
<span class="go">       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]]) #random</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="vec-val-vect">
<h3>vec_val_vect<a class="headerlink" href="#vec-val-vect" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect">
<code class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</code><code class="descname">vec_val_vect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect" title="Permalink to this definition"></a></dt>
<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, N) array</span></dt>
<dd><p class="first last">containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>
</dd>
<dt><strong>vals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, N) array</span></dt>
<dd><p class="first last">diagonal values carried in last dimension, <code class="docutils literal notranslate"><span class="pre">...</span></code> shape above must
match that for <cite>vecs</cite></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, M) array</span></dt>
<dd><p class="first last">For all the dimensions ellided by <code class="docutils literal notranslate"><span class="pre">...</span></code>, loops to get (M, N) <code class="docutils literal notranslate"><span class="pre">vec</span></code>
matrix, and (N,) <code class="docutils literal notranslate"><span class="pre">vals</span></code> vector, and calculates
<code class="docutils literal notranslate"><span class="pre">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Make a 3D array where the first dimension is only 1</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_val_vect</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="go">array([[[   9.,   24.,   39.],</span>
<span class="go">        [  24.,   66.,  108.],</span>
<span class="go">        [  39.,  108.,  177.]]])</span>
</pre></div>
</div>
<p>Thats the same as the 2D case (apart from the float casting):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">vecs</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">array([[  9,  24,  39],</span>
<span class="go">       [ 24,  66, 108],</span>
<span class="go">       [ 39, 108, 177]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="with-einsum">
<h3>with_einsum<a class="headerlink" href="#with-einsum" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.benchmarks.bench_vec_val_sum.with_einsum">
<code class="descclassname">dipy.reconst.benchmarks.bench_vec_val_sum.</code><code class="descname">with_einsum</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.benchmarks.bench_vec_val_sum.with_einsum" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cache">
<h3><a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#cache" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.cache.Cache">
<em class="property">class </em><code class="descclassname">dipy.reconst.cache.</code><code class="descname">Cache</code><a class="headerlink" href="#dipy.reconst.cache.Cache" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cache.Cache.cache_clear" title="dipy.reconst.cache.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.cache.Cache.cache_get" title="dipy.reconst.cache.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cache.Cache.cache_set" title="dipy.reconst.cache.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.cache.Cache.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cache.Cache.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.cache.Cache.cache_clear">
<code class="descname">cache_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_clear" title="Permalink to this definition"></a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.cache.Cache.cache_get">
<code class="descname">cache_get</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.cache.Cache.cache_set">
<code class="descname">cache_set</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cache.Cache.cache_set" title="Permalink to this definition"></a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="auto-attr">
<h3>auto_attr<a class="headerlink" href="#auto-attr" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.cache.auto_attr">
<code class="descclassname">dipy.reconst.cache.</code><code class="descname">auto_attr</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cache.auto_attr" title="Permalink to this definition"></a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">The method that will be called the first time to compute a value.
Afterwards, the methods name will be a standard attribute holding the
value of this computation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="range">
<h3><a class="reference internal" href="#dipy.reconst.cross_validation.range" title="dipy.reconst.cross_validation.range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a><a class="headerlink" href="#range" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.cross_validation.range">
<em class="property">class </em><code class="descclassname">dipy.reconst.cross_validation.</code><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span> &#x2192; range object<a class="headerlink" href="#dipy.reconst.cross_validation.range" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>range(start, stop[, step]) -&gt; range object</p>
<p>Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, , j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>start</strong></dt>
<dd></dd>
<dt><strong>step</strong></dt>
<dd></dd>
<dt><strong>stop</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.cross_validation.range.count" title="dipy.reconst.cross_validation.range.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(value)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.cross_validation.range.index" title="dipy.reconst.cross_validation.range.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(value,&nbsp;[start,&nbsp;[stop]])</td>
<td>Raise ValueError if the value is not present.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.cross_validation.range.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cross_validation.range.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.cross_validation.range.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span> &#x2192; integer -- return number of occurrences of value<a class="headerlink" href="#dipy.reconst.cross_validation.range.count" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.cross_validation.range.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>stop</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; integer -- return index of value.<a class="headerlink" href="#dipy.reconst.cross_validation.range.index" title="Permalink to this definition"></a></dt>
<dd><p>Raise ValueError if the value is not present.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.cross_validation.range.start">
<code class="descname">start</code><a class="headerlink" href="#dipy.reconst.cross_validation.range.start" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.cross_validation.range.step">
<code class="descname">step</code><a class="headerlink" href="#dipy.reconst.cross_validation.range.step" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.cross_validation.range.stop">
<code class="descname">stop</code><a class="headerlink" href="#dipy.reconst.cross_validation.range.stop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="coeff-of-determination">
<h3>coeff_of_determination<a class="headerlink" href="#coeff-of-determination" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.cross_validation.coeff_of_determination">
<code class="descclassname">dipy.reconst.cross_validation.</code><code class="descname">coeff_of_determination</code><span class="sig-paren">(</span><em>data</em>, <em>model</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cross_validation.coeff_of_determination" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Calculate the coefficient of determination for a model prediction, relative
to data.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><blockquote class="first">
<div><p>The data</p>
</div></blockquote>
<dl class="last docutils">
<dt>model <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The predictions of a model for this data. Same shape as the data.</p>
</dd>
<dt>axis: int, optional</dt>
<dd><p class="first last">The axis along which different samples are laid out (default: -1).</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>COD</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The coefficient of determination. This has shape <cite>data.shape[:-1]</cite></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{SSE}{SSD})</p>
<blockquote>
<div>where SSE is the sum of the squared error between the model and the data
(sum of the squared residuals) and SSD is the sum of the squares of the
deviations of the data from the mean of the data (variance * N).</div></blockquote>
</dd></dl>

</div>
<div class="section" id="kfold-xval">
<h3>kfold_xval<a class="headerlink" href="#kfold-xval" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.cross_validation.kfold_xval">
<code class="descclassname">dipy.reconst.cross_validation.</code><code class="descname">kfold_xval</code><span class="sig-paren">(</span><em>model</em>, <em>data</em>, <em>folds</em>, <em>*model_args</em>, <em>**model_kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.cross_validation.kfold_xval" title="Permalink to this definition"></a></dt>
<dd><p>Perform k-fold cross-validation to generate out-of-sample predictions for
each measurement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Model class instance</span></dt>
<dd><p class="first last">The type of the model to use for prediction. The corresponding Fit
object must have a <cite>predict</cite> function implementd One of the following:
<cite>reconst.dti.TensorModel</cite> or
<cite>reconst.csdeconv.ConstrainedSphericalDeconvModel</cite>.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Diffusion MRI data acquired with the GradientTable of the model. Shape
will typically be <cite>(x, y, z, b)</cite> where <cite>xyz</cite> are spatial dimensions and
b is the number of bvals/bvecs in the GradientTable.</p>
</dd>
<dt><strong>folds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of divisions to apply to the data</p>
</dd>
<dt><strong>model_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Additional arguments to the model initialization</p>
</dd>
<dt><strong>model_kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional key-word arguments to the model initialization. If contains
the kwarg <cite>mask</cite>, this will be used as a key-word argument to the <cite>fit</cite>
method of the model object, rather than being used in the
initialization of the model object</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function assumes that a prediction API is implemented in the Model
class for which prediction is conducted. That is, the Fit object that gets
generated upon fitting the model needs to have a <cite>predict</cite> method, which
receives a GradientTable class instance as input and produces a predicted
signal as output.</p>
<p>It also assumes that the model object has <cite>bval</cite> and <cite>bvec</cite> attributes
holding b-values and corresponding unit vectors.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="ra6e888b05b47-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id76">[1]</a></td><td>Rokem, A., Chan, K.L. Yeatman, J.D., Pestilli, F., Mezer, A.,
Wandell, B.A., 2014. Evaluating the accuracy of diffusion models at
multiple b-values with cross-validation. ISMRM 2014.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="axsymshresponse">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse" title="dipy.reconst.csdeconv.AxSymShResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">AxSymShResponse</span></code></a><a class="headerlink" href="#axsymshresponse" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.AxSymShResponse">
<em class="property">class </em><code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">AxSymShResponse</code><span class="sig-paren">(</span><em>S0</em>, <em>dwi_response</em>, <em>bvalue=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A simple wrapper for response functions represented using only axially
symmetric, even spherical harmonic functions (ie, m == 0 and n even).</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse.basis" title="dipy.reconst.csdeconv.AxSymShResponse.basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">basis</span></code></a>(sphere)</td>
<td>A basis that maps the response coefficients onto a sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.AxSymShResponse.on_sphere" title="dipy.reconst.csdeconv.AxSymShResponse.on_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">on_sphere</span></code></a>(sphere)</td>
<td>Evaluates the response function on sphere.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.AxSymShResponse.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>S0</em>, <em>dwi_response</em>, <em>bvalue=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.AxSymShResponse.basis">
<code class="descname">basis</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.basis" title="Permalink to this definition"></a></dt>
<dd><p>A basis that maps the response coefficients onto a sphere.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.AxSymShResponse.on_sphere">
<code class="descname">on_sphere</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.AxSymShResponse.on_sphere" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the response function on sphere.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="constrainedsdtmodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="dipy.reconst.csdeconv.ConstrainedSDTModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSDTModel</span></code></a><a class="headerlink" href="#constrainedsdtmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.ConstrainedSDTModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">ConstrainedSDTModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>ratio</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1.0</em>, <em>tau=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.shm.SphHarmModel</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.fit" title="dipy.reconst.csdeconv.ConstrainedSDTModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSDTModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>ratio</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1.0</em>, <em>tau=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Spherical Deconvolution Transform (SDT) <a class="reference internal" href="#ra758a02951fe-1" id="id77">[1]</a>.</p>
<p>The SDT computes a fiber orientation distribution (FOD) as opposed to a
diffusion ODF as the QballModel or the CsaOdfModel. This results in a
sharper angular profile with better angular resolution. The Constrained
SDTModel is similar to the Constrained CSDModel but mathematically it
deconvolves the q-ball ODF as oppposed to the HARDI signal (see <a class="reference internal" href="#ra758a02951fe-1" id="id78">[1]</a>
for a comparison and a through discussion).</p>
<p>A sharp fODF is obtained because a single fiber <em>response</em> function is
injected as <em>a priori</em> knowledge. In the SDTModel, this response is a
single fiber q-ball ODF as opposed to a single fiber signal function
for the CSDModel. The response function will be used as deconvolution
kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>ratio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">ratio of the smallest vs the largest eigenvalue of the single
prolate tensor response function</p>
</dd>
<dt><strong>reg_sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">sphere used to build the regularization B matrix</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">maximal spherical harmonics order</p>
</dd>
<dt><strong>lambda_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">weight given to the constrained-positivity regularization part of
the deconvolution equation</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">threshold (tau <a href="#id79"><span class="problematic" id="id80">*</span></a>mean(fODF)) controlling the amplitude below
which the corresponding fODF is assumed to be zero.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="ra758a02951fe-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id77">1</a>, <a class="fn-backref" href="#id78">2</a>, <a class="fn-backref" href="#id81">3</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSDTModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSDTModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id82">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedSphericalDeconvModel</span></code></a><a class="headerlink" href="#id82" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">ConstrainedSphericalDeconvModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>response</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1</em>, <em>tau=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.shm.SphHarmModel</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict" title="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(sh_coeff[,&nbsp;gtab,&nbsp;S0])</td>
<td>Compute a signal prediction given spherical harmonic coefficients for the provided GradientTable class instance.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>response</em>, <em>reg_sphere=None</em>, <em>sh_order=8</em>, <em>lambda_=1</em>, <em>tau=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constrained Spherical Deconvolution (CSD) <a class="reference internal" href="#r2b09b06a1a8d-1" id="id83">[1]</a>.</p>
<p>Spherical deconvolution computes a fiber orientation distribution
(FOD), also called fiber ODF (fODF) <a class="reference internal" href="#r2b09b06a1a8d-2" id="id84">[2]</a>, as opposed to a diffusion ODF
as the QballModel or the CsaOdfModel. This results in a sharper angular
profile with better angular resolution that is the best object to be
used for later deterministic and probabilistic tractography <a class="reference internal" href="#r2b09b06a1a8d-3" id="id85">[3]</a>.</p>
<p>A sharp fODF is obtained because a single fiber <em>response</em> function is
injected as <em>a priori</em> knowledge. The response function is often
data-driven and is thus provided as input to the
ConstrainedSphericalDeconvModel. It will be used as deconvolution
kernel, as described in <a class="reference internal" href="#r2b09b06a1a8d-1" id="id86">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>response</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple or AxSymShResponse object</span></dt>
<dd><p class="first last">A tuple with two elements. The first is the eigen-values as an (3,)
ndarray and the second is the signal value for the response
function without diffusion weighting.  This is to be able to
generate a single fiber synthetic signal. The response function
will be used as deconvolution kernel (<a class="reference internal" href="#r2b09b06a1a8d-1" id="id87">[1]</a>)</p>
</dd>
<dt><strong>reg_sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere (optional)</span></dt>
<dd><p class="first last">sphere used to build the regularization B matrix.
Default: symmetric362.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">maximal spherical harmonics order. Default: 8</p>
</dd>
<dt><strong>lambda_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">weight given to the constrained-positivity regularization part of
the deconvolution equation (see <a class="reference internal" href="#r2b09b06a1a8d-1" id="id88">[1]</a>). Default: 1</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">threshold controlling the amplitude below which the corresponding
fODF is assumed to be zero.  Ideally, tau should be set to
zero. However, to improve the stability of the algorithm, tau is
set to tau*100 % of the mean fODF amplitude (here, 10% by default)
(see <a class="reference internal" href="#r2b09b06a1a8d-1" id="id89">[1]</a>). Default: 0.1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2b09b06a1a8d-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id83">1</a>, <a class="fn-backref" href="#id86">2</a>, <a class="fn-backref" href="#id87">3</a>, <a class="fn-backref" href="#id88">4</a>, <a class="fn-backref" href="#id89">5</a>, <a class="fn-backref" href="#id90">6</a>)</em> Tournier, J.D., et al. NeuroImage 2007. Robust determination of
the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical
deconvolution</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r2b09b06a1a8d-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id84">1</a>, <a class="fn-backref" href="#id91">2</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r2b09b06a1a8d-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id85">1</a>, <a class="fn-backref" href="#id92">2</a>)</em> C^ote, M-A., et al. Medical Image Analysis 2013. Tractometer:
Towards validation of tractography pipelines</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r2b09b06a1a8d-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id93">[4]</a></td><td>Tournier, J.D, et al. Imaging Systems and Technology
2012. MRtrix: Diffusion Tractography in Crossing Fiber Regions</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>sh_coeff</em>, <em>gtab=None</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict" title="Permalink to this definition"></a></dt>
<dd><p>Compute a signal prediction given spherical harmonic coefficients
for the provided GradientTable class instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh_coeff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The spherical harmonic representation of the FOD from which to make
the signal prediction.</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd><p class="first last">The gradients for which the signal will be predicted. Use the
models gradient table by default.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or float</span></dt>
<dd><p class="first last">The non diffusion-weighted signal value.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pred_sig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The predicted signal.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sphharmfit">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit" title="dipy.reconst.csdeconv.SphHarmFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a><a class="headerlink" href="#sphharmfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.SphHarmFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">SphHarmFit</code><span class="sig-paren">(</span><em>model</em>, <em>shm_coef</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfFit</span></code></a></p>
<p>Diffusion data fit to a spherical harmonic model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit.shm_coeff" title="dipy.reconst.csdeconv.SphHarmFit.shm_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm_coeff</span></code></a></dt>
<dd><p class="first last">The spherical harmonic coefficients of the odf</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit.odf" title="dipy.reconst.csdeconv.SphHarmFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>Samples the odf function on the points of a sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmFit.predict" title="dipy.reconst.csdeconv.SphHarmFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>([gtab,&nbsp;S0])</td>
<td>Predict the diffusion signal from the model coefficients.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>gfa</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>shm_coef</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmFit.gfa">
<code class="descname">gfa</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.gfa" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>Samples the odf function on the points of a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The points on which to sample the odf.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The value of the odf on each point of <cite>sphere</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab=None</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the diffusion signal from the model coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The directions and bvalues on which prediction is desired</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">The mean non-diffusion-weighted signal in each voxel.
Default: 1.0 in all voxels</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.csdeconv.SphHarmFit.shape">
<code class="descname">shape</code><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.shape" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.csdeconv.SphHarmFit.shm_coeff">
<code class="descname">shm_coeff</code><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmFit.shm_coeff" title="Permalink to this definition"></a></dt>
<dd><p>The spherical harmonic coefficients of the odf</p>
<p>Make this a property for now, if there is a usecase for modifying
the coefficients we can add a setter or expose the coefficients more
directly</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sphharmmodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmModel" title="dipy.reconst.csdeconv.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a><a class="headerlink" href="#sphharmmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.SphHarmModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">SphHarmModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.cache.Cache</span></code></a></p>
<p>To be subclassed by all models that return a SphHarmFit when fit.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.SphHarmModel.sampling_matrix" title="dipy.reconst.csdeconv.SphHarmModel.sampling_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code></a>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.SphHarmModel.sampling_matrix">
<code class="descname">sampling_matrix</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.SphHarmModel.sampling_matrix" title="Permalink to this definition"></a></dt>
<dd><p>The matrix needed to sample ODFs from coefficients of the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">Points used to sample ODF.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sampling_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The size of the matrix will be (N, M) where N is the number of
vertices on sphere and M is the number of coefficients needed by
the model.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tensormodel">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.TensorModel" title="dipy.reconst.csdeconv.TensorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorModel</span></code></a><a class="headerlink" href="#tensormodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.TensorModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">TensorModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>return_S0_hat=False</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.TensorModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>Diffusion Tensor</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.TensorModel.fit" title="dipy.reconst.csdeconv.TensorModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method of the DTI model class</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.TensorModel.predict" title="dipy.reconst.csdeconv.TensorModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(dti_params[,&nbsp;S0])</td>
<td>Predict a signal for this TensorModel class instance given parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.TensorModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>return_S0_hat=False</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.TensorModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>A Diffusion Tensor Model <a class="reference internal" href="#rd9db3d4c080e-1" id="id94">[1]</a>, <a class="reference internal" href="#rd9db3d4c080e-2" id="id95">[2]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>fit_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or callable</span></dt>
<dd><p class="first">str can be one of the following:</p>
<dl class="last docutils">
<dt>WLS for weighted least squares</dt>
<dd><p class="first last"><code class="xref py py-func docutils literal notranslate"><span class="pre">dti.wls_fit_tensor()</span></code></p>
</dd>
<dt>LS or OLS for ordinary least squares</dt>
<dd><p class="first last"><code class="xref py py-func docutils literal notranslate"><span class="pre">dti.ols_fit_tensor()</span></code></p>
</dd>
<dt>NLLS for non-linear least-squares</dt>
<dd><p class="first last"><code class="xref py py-func docutils literal notranslate"><span class="pre">dti.nlls_fit_tensor()</span></code></p>
</dd>
<dt>RT or restore or RESTORE for RESTORE robust tensor</dt>
<dd><p class="first last">fitting <a class="reference internal" href="#rd9db3d4c080e-3" id="id96">[3]</a>
<code class="xref py py-func docutils literal notranslate"><span class="pre">dti.restore_fit_tensor()</span></code></p>
</dd>
<dt>callable has to have the signature:</dt>
<dd><p class="first last">fit_method(design_matrix, data, <a href="#id97"><span class="problematic" id="id98">*</span></a>args, <a href="#id99"><span class="problematic" id="id100">**</span></a>kwargs)</p>
</dd>
</dl>
</dd>
<dt><strong>return_S0_hat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>args, kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">arguments and key-word arguments passed to the</span></dt>
<dd><p class="first last">fit_method. See dti.wls_fit_tensor, dti.ols_fit_tensor for details</p>
</dd>
<dt><strong>min_signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum signal value. Needs to be a strictly positive
number. Default: minimal signal in the data provided to <cite>fit</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. Many fit_methods use the step
parameter to set the number of voxels that will be fit at once in each
iteration. This is the chunk size as a number of voxels. A larger step
value should speed things up, but it will also take up more memory. It
is advisable to keep an eye on memory consumption as this value is
increased.</p>
<p>Example : In <code class="xref py py-func docutils literal notranslate"><span class="pre">iter_fit_tensor()</span></code> we have a default step value of
1e4</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd9db3d4c080e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id94">1</a>, <a class="fn-backref" href="#id101">2</a>)</em> Basser, P.J., Mattiello, J., LeBihan, D., 1994. Estimation of
the effective self-diffusion tensor from the NMR spin echo. J Magn
Reson B 103, 247-254.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rd9db3d4c080e-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id95">1</a>, <a class="fn-backref" href="#id102">2</a>)</em> Basser, P., Pierpaoli, C., 1996. Microstructural and
physiological features of tissues elucidated by quantitative
diffusion-tensor MRI.  Journal of Magnetic Resonance 111, 209-219.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rd9db3d4c080e-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id96">1</a>, <a class="fn-backref" href="#id103">2</a>)</em> Lin-Ching C., Jones D.K., Pierpaoli, C. 2005. RESTORE: Robust
estimation of tensors by outlier rejection. MRM 53: 1088-1095</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.TensorModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.TensorModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method of the DTI model class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The measured signal from one voxel.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.TensorModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>dti_params</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.TensorModel.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict a signal for this TensorModel class instance given parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dti_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The last dimension should have 12 tensor parameters: 3
eigenvalues, followed by the 3 eigenvectors</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id104">
<h3><a class="reference internal" href="#dipy.reconst.csdeconv.range" title="dipy.reconst.csdeconv.range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a><a class="headerlink" href="#id104" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.csdeconv.range">
<em class="property">class </em><code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span> &#x2192; range object<a class="headerlink" href="#dipy.reconst.csdeconv.range" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>range(start, stop[, step]) -&gt; range object</p>
<p>Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, , j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>start</strong></dt>
<dd></dd>
<dt><strong>step</strong></dt>
<dd></dd>
<dt><strong>stop</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.csdeconv.range.count" title="dipy.reconst.csdeconv.range.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(value)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.csdeconv.range.index" title="dipy.reconst.csdeconv.range.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(value,&nbsp;[start,&nbsp;[stop]])</td>
<td>Raise ValueError if the value is not present.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.csdeconv.range.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.range.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.range.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span> &#x2192; integer -- return number of occurrences of value<a class="headerlink" href="#dipy.reconst.csdeconv.range.count" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.csdeconv.range.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>stop</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; integer -- return index of value.<a class="headerlink" href="#dipy.reconst.csdeconv.range.index" title="Permalink to this definition"></a></dt>
<dd><p>Raise ValueError if the value is not present.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.csdeconv.range.start">
<code class="descname">start</code><a class="headerlink" href="#dipy.reconst.csdeconv.range.start" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.csdeconv.range.step">
<code class="descname">step</code><a class="headerlink" href="#dipy.reconst.csdeconv.range.step" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.csdeconv.range.stop">
<code class="descname">stop</code><a class="headerlink" href="#dipy.reconst.csdeconv.range.stop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="auto-response">
<h3>auto_response<a class="headerlink" href="#auto-response" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.auto_response">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">auto_response</code><span class="sig-paren">(</span><em>gtab</em>, <em>data</em>, <em>roi_center=None</em>, <em>roi_radius=10</em>, <em>fa_thr=0.7</em>, <em>fa_callable=&lt;function fa_superior&gt;</em>, <em>return_number_of_voxels=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.auto_response" title="Permalink to this definition"></a></dt>
<dd><p>Automatic estimation of response function using FA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">diffusion data</p>
</dd>
<dt><strong>roi_center</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, (3,)</span></dt>
<dd><p class="first last">Center of ROI in data. If center is None, it is assumed that it is
the center of the volume with shape <cite>data.shape[:3]</cite>.</p>
</dd>
<dt><strong>roi_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">radius of cubic ROI</p>
</dd>
<dt><strong>fa_thr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">FA threshold</p>
</dd>
<dt><strong>fa_callable</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">A callable that defines an operation that compares FA with the fa_thr.
The operator should have two positional arguments
(e.g., <cite>fa_operator(FA, fa_thr)</cite>) and it should return a bool array.</p>
</dd>
<dt><strong>return_number_of_voxels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, returns the number of voxels used for estimating the response
function.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>response</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, (2,)</span></dt>
<dd><p class="first last">(<cite>evals</cite>, <cite>S0</cite>)</p>
</dd>
<dt><strong>ratio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The ratio between smallest versus largest eigenvalue of the response.</p>
</dd>
<dt><strong>number of voxels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">The number of voxels used for estimating the response function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. In order to do this we look for voxels with very
anisotropic configurations. For example we can use an ROI (20x20x20) at
the center of the volume and store the signal values for the voxels with
FA values higher than 0.7. Of course, if we havent precalculated FA we
need to fit a Tensor model to the datasets. Which is what we do in this
function.</p>
<p>For the response we also need to find the average S0 in the ROI. This is
possible using <cite>gtab.b0s_mask()</cite> we can find all the S0 volumes (which
correspond to b-values equal 0) in the dataset.</p>
<p>The <cite>response</cite> consists always of a prolate tensor created by averaging
the highest and second highest eigenvalues in the ROI with FA higher than
threshold. We also include the average S0s.</p>
<p>We also return the <cite>ratio</cite> which is used for the SDT models. If requested,
the number of voxels used for estimating the response function is also
returned, which can be used to judge the fidelity of the response function.
As a rule of thumb, at least 300 voxels should be used to estimate a good
response function (see <a class="reference internal" href="#rf2ae5ba8c209-1" id="id105">[1]</a>).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rf2ae5ba8c209-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id105">1</a>, <a class="fn-backref" href="#id106">2</a>)</em> Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</td></tr>
</tbody>
</table>
<p>fiber orientation density function from diffusion-weighted MRI
data using spherical deconvolution</p>
</dd></dl>

</div>
<div class="section" id="cart2sphere">
<h3>cart2sphere<a class="headerlink" href="#cart2sphere" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.cart2sphere">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">cart2sphere</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.cart2sphere" title="Permalink to this definition"></a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions and derivation
of the formulae.</p>
<p><span class="math notranslate nohighlight">\(0\le\theta\mathrm{(theta)}\le\pi\)</span> and <span class="math notranslate nohighlight">\(-\pi\le\phi\mathrm{(phi)}\le\pi\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">x coordinate in Cartesian space</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">z coordinate</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">radius</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">inclination (polar) angle</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">azimuth angle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="csdeconv">
<h3>csdeconv<a class="headerlink" href="#csdeconv" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.csdeconv">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">csdeconv</code><span class="sig-paren">(</span><em>dwsignal</em>, <em>X</em>, <em>B_reg</em>, <em>tau=0.1</em>, <em>convergence=50</em>, <em>P=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.csdeconv" title="Permalink to this definition"></a></dt>
<dd><p>Constrained-regularized spherical deconvolution (CSD) <a class="reference internal" href="#r537fd66f8bb4-1" id="id107">[1]</a></p>
<p>Deconvolves the axially symmetric single fiber response function <cite>r_rh</cite> in
rotational harmonics coefficients from the diffusion weighted signal in
<cite>dwsignal</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dwsignal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Diffusion weighted signals to be deconvolved.</p>
</dd>
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Prediction matrix which estimates diffusion weighted signals from FOD
coefficients.</p>
</dd>
<dt><strong>B_reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, B)</span></dt>
<dd><p class="first last">SH basis matrix which maps FOD coefficients to FOD values on the
surface of the sphere. B_reg should be scaled to account for lambda.</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Threshold controlling the amplitude below which the corresponding fODF
is assumed to be zero.  Ideally, tau should be set to zero. However, to
improve the stability of the algorithm, tau is set to tau*100 % of the
max fODF amplitude (here, 10% by default). This is similar to peak
detection where peaks below 0.1 amplitude are usually considered noise
peaks. Because SDT is based on a q-ball ODF deconvolution, and not
signal deconvolution, using the max instead of mean (as in CSD), is
more stable.</p>
</dd>
<dt><strong>convergence</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations to allow the deconvolution to converge.</p>
</dd>
<dt><strong>P</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">This is an optimization to avoid computing <code class="docutils literal notranslate"><span class="pre">dot(X.T,</span> <span class="pre">X)</span></code> many times.
If the same <code class="docutils literal notranslate"><span class="pre">X</span></code> is used many times, <code class="docutils literal notranslate"><span class="pre">P</span></code> can be precomputed and
passed to this function.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fodf_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt>
<dd><p class="first last">Spherical harmonics coefficients of the constrained-regularized fiber
ODF.</p>
</dd>
<dt><strong>num_it</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of iterations in the constrained-regularization used for
convergence.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This section describes how the fitting of the SH coefficients is done.
Problem is to minimise per iteration:</p>
<p><span class="math notranslate nohighlight">\(F(f_n) = ||Xf_n - S||^2 + \lambda^2 ||H_{n-1} f_n||^2\)</span></p>
<p>Where <span class="math notranslate nohighlight">\(X\)</span> maps current FOD SH coefficients <span class="math notranslate nohighlight">\(f_n\)</span> to DW signals <span class="math notranslate nohighlight">\(s\)</span> and
<span class="math notranslate nohighlight">\(H_{n-1}\)</span> maps FOD SH coefficients <span class="math notranslate nohighlight">\(f_n\)</span> to amplitudes along set of
negative directions identified in previous iteration, i.e. the matrix
formed by the rows of <span class="math notranslate nohighlight">\(B_{reg}\)</span> for which <span class="math notranslate nohighlight">\(Hf_{n-1}&lt;0\)</span> where <span class="math notranslate nohighlight">\(B_{reg}\)</span>
maps <span class="math notranslate nohighlight">\(f_n\)</span> to FOD amplitude on a sphere.</p>
<p>Solve by differentiating and setting to zero:</p>
<p><span class="math notranslate nohighlight">\(\Rightarrow \frac{\delta F}{\delta f_n} = 2X^T(Xf_n - S) + 2 \lambda^2
H_{n-1}^TH_{n-1}f_n=0\)</span></p>
<p>Or:</p>
<p><span class="math notranslate nohighlight">\((X^TX + \lambda^2 H_{n-1}^TH_{n-1})f_n = X^Ts\)</span></p>
<p>Define <span class="math notranslate nohighlight">\(Q = X^TX + \lambda^2 H_{n-1}^TH_{n-1}\)</span> , which by construction is a
square positive definite symmetric matrix of size <span class="math notranslate nohighlight">\(n_{SH} by n_{SH}\)</span>. If
needed, positive definiteness can be enforced with a small minimum norm
regulariser (helps a lot with poorly conditioned direction sets and/or
superresolution):</p>
<p><span class="math notranslate nohighlight">\(Q = X^TX + (\lambda H_{n-1}^T) (\lambda H_{n-1}) + \mu I\)</span></p>
<p>Solve <span class="math notranslate nohighlight">\(Qf_n = X^Ts\)</span> using Cholesky decomposition:</p>
<p><span class="math notranslate nohighlight">\(Q = LL^T\)</span></p>
<p>where <span class="math notranslate nohighlight">\(L\)</span> is lower triangular. Then problem can be solved by
back-substitution:</p>
<p><span class="math notranslate nohighlight">\(L_y = X^Ts\)</span></p>
<p><span class="math notranslate nohighlight">\(L^Tf_n = y\)</span></p>
<p>To speeds things up further, form <span class="math notranslate nohighlight">\(P = X^TX + \mu I\)</span>, and update to form
<span class="math notranslate nohighlight">\(Q\)</span> by rankn update with <span class="math notranslate nohighlight">\(H_{n-1}\)</span>. The dipy implementation looks like:</p>
<blockquote>
<div><p>form initially <span class="math notranslate nohighlight">\(P = X^T X + \mu I\)</span> and <span class="math notranslate nohighlight">\(\lambda B_{reg}\)</span></p>
<p>for each voxel: form <span class="math notranslate nohighlight">\(z = X^Ts\)</span></p>
<blockquote>
<div><p>estimate <span class="math notranslate nohighlight">\(f_0\)</span> by solving <span class="math notranslate nohighlight">\(Pf_0=z\)</span>. We use a simplified <span class="math notranslate nohighlight">\(l_{max}=4\)</span>
solution here, but it might not make a big difference.</p>
<p>Then iterate until no change in rows of <span class="math notranslate nohighlight">\(H\)</span> used in <span class="math notranslate nohighlight">\(H_n\)</span></p>
<blockquote>
<div><p>form <span class="math notranslate nohighlight">\(H_{n}\)</span> given <span class="math notranslate nohighlight">\(f_{n-1}\)</span></p>
<p>form <span class="math notranslate nohighlight">\(Q = P + (\lambda H_{n-1}^T) (\lambda H_{n-1}\)</span>) (this can
be done by rankn update, but we currently do not use rankn
update).</p>
<p>solve <span class="math notranslate nohighlight">\(Qf_n = z\)</span> using Cholesky decomposition</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>Wed like to thanks Donald Tournier for his help with describing and
implementing this algorithm.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r537fd66f8bb4-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id107">2</a>, <a class="fn-backref" href="#id108">3</a>)</em> Tournier, J.D., et al. NeuroImage 2007. Robust determination of the
fibre orientation distribution in diffusion MRI: Non-negativity
constrained super-resolved spherical deconvolution.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="estimate-response">
<h3>estimate_response<a class="headerlink" href="#estimate-response" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.estimate_response">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">estimate_response</code><span class="sig-paren">(</span><em>gtab</em>, <em>evals</em>, <em>S0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.estimate_response" title="Permalink to this definition"></a></dt>
<dd><p>Estimate single fiber response function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd></dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">non diffusion weighted</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">estimated signal</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fa-inferior">
<h3>fa_inferior<a class="headerlink" href="#fa-inferior" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.fa_inferior">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">fa_inferior</code><span class="sig-paren">(</span><em>FA</em>, <em>fa_thr</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.fa_inferior" title="Permalink to this definition"></a></dt>
<dd><p>Check that the FA is lower than the FA threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>FA</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Fractional Anisotropy</p>
</dd>
<dt><strong>fa_thr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">FA threshold</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>True when the FA value is lower than the FA threshold, otherwise False.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fa-superior">
<h3>fa_superior<a class="headerlink" href="#fa-superior" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.fa_superior">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">fa_superior</code><span class="sig-paren">(</span><em>FA</em>, <em>fa_thr</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.fa_superior" title="Permalink to this definition"></a></dt>
<dd><p>Check that the FA is greater than the FA threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>FA</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Fractional Anisotropy</p>
</dd>
<dt><strong>fa_thr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">FA threshold</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>True when the FA value is greater than the FA threshold, otherwise False.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fa-trace-to-lambdas">
<h3>fa_trace_to_lambdas<a class="headerlink" href="#fa-trace-to-lambdas" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.fa_trace_to_lambdas">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">fa_trace_to_lambdas</code><span class="sig-paren">(</span><em>fa=0.08</em>, <em>trace=0.0021</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.fa_trace_to_lambdas" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="forward-sdeconv-mat">
<h3>forward_sdeconv_mat<a class="headerlink" href="#forward-sdeconv-mat" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.forward_sdeconv_mat">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">forward_sdeconv_mat</code><span class="sig-paren">(</span><em>r_rh</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.forward_sdeconv_mat" title="Permalink to this definition"></a></dt>
<dd><p>Build forward spherical deconvolution matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r_rh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Rotational harmonics coefficients for the single fiber response
function. Each element <cite>rh[i]</cite> is associated with spherical harmonics
of degree <cite>2*i</cite>.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The degree of spherical harmonic function associated with each row of
the deconvolution matrix. Only even degrees are allowed</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N, N)</span></dt>
<dd><p class="first last">Deconvolution matrix with shape (N, N)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="forward-sdt-deconv-mat">
<h3>forward_sdt_deconv_mat<a class="headerlink" href="#forward-sdt-deconv-mat" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.forward_sdt_deconv_mat">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">forward_sdt_deconv_mat</code><span class="sig-paren">(</span><em>ratio</em>, <em>n</em>, <em>r2_term=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.forward_sdt_deconv_mat" title="Permalink to this definition"></a></dt>
<dd><p>Build forward sharpening deconvolution transform (SDT) matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ratio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">ratio = :math:<a href="#id109"><span class="problematic" id="id110">`</span></a></p>
</dd>
<dt><strong>rac{lambda_2}{lambda_1}` of the single fiber response</strong></dt>
<dd><blockquote class="first">
<div><p>function</p>
</div></blockquote>
<dl class="last docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">The degree of spherical harmonic function associated with each row of
the deconvolution matrix. Only even degrees are allowed.</p>
</dd>
<dt>r2_term <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if ODF comes from an ODF computed from a model using the <span class="math notranslate nohighlight">\(r^2\)</span>
term in the integral. For example, DSI, GQI, SHORE, CSA, Tensor,
Multi-tensor ODFs. This results in using the proper analytical response
function solution solving from the single-fiber ODF with the r^2 term.
This derivation is not published anywhere but is very similar to [Rf897e7c36096-1].</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N, N)</span></dt>
<dd><blockquote class="first">
<div><p>SDT deconvolution matrix</p>
</div></blockquote>
<dl class="last docutils">
<dt>P <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N, N)</span></dt>
<dd><p class="first last">Funk-Radon Transform (FRT) matrix</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fractional-anisotropy">
<h3>fractional_anisotropy<a class="headerlink" href="#fractional-anisotropy" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.fractional_anisotropy">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">fractional_anisotropy</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.fractional_anisotropy" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Fractional anisotropy (FA) of a diffusion tensor.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{1}{2}
rac{(lambda_1-lambda_2)^2+(lambda_1-</p>
<blockquote>
<div>lambda_3)^2+(lambda_2-lambda_3)^2}{lambda_1^2+
lambda_2^2+lambda_3^2}}</div></blockquote>
</dd></dl>

</div>
<div class="section" id="id112">
<h3>get_sphere<a class="headerlink" href="#id112" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.get_sphere">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">get_sphere</code><span class="sig-paren">(</span><em>name='symmetric362'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.get_sphere" title="Permalink to this definition"></a></dt>
<dd><p>provide triangulated spheres</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">which sphere - one of:
* symmetric362
* symmetric642
* symmetric724
* repulsion724
* repulsion100
* repulsion200</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a dipy.core.sphere.Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;symmetric362&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">sphere</span><span class="o">.</span><span class="n">faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">362</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">720</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;not a sphere name&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">DataError</span>: <span class="n">No sphere called &quot;not a sphere name&quot;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="lazy-index">
<h3>lazy_index<a class="headerlink" href="#lazy-index" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.lazy_index">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">lazy_index</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.lazy_index" title="Permalink to this definition"></a></dt>
<dd><p>Produces a lazy index</p>
<p>Returns a slice that can be used for indexing an array, if no slice can be
made index is returned as is.</p>
</dd></dl>

</div>
<div class="section" id="lpn">
<h3>lpn<a class="headerlink" href="#lpn" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.lpn">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">lpn</code><span class="sig-paren">(</span><em>n</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.lpn" title="Permalink to this definition"></a></dt>
<dd><p>Legendre function of the first kind.</p>
<p>Compute sequence of Legendre functions of the first kind (polynomials),
Pn(z) and derivatives for all degrees from 0 to n (inclusive).</p>
<p>See also special.legendre for polynomial class.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r631d63c165ca-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id113">[1]</a></td><td>Zhang, Shanjie and Jin, Jianming. Computation of Special
Functions, John Wiley and Sons, 1996.
<a class="reference external" href="https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html">https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="multi-voxel-fit">
<h3>multi_voxel_fit<a class="headerlink" href="#multi-voxel-fit" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.multi_voxel_fit">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="id114">
<h3>ndindex<a class="headerlink" href="#id114" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.ndindex">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">ndindex</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.ndindex" title="Permalink to this definition"></a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd><p class="first last">The dimensions of the array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="k">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="odf-deconv">
<h3>odf_deconv<a class="headerlink" href="#odf-deconv" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.odf_deconv">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">odf_deconv</code><span class="sig-paren">(</span><em>odf_sh</em>, <em>R</em>, <em>B_reg</em>, <em>lambda_=1.0</em>, <em>tau=0.1</em>, <em>r2_term=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.odf_deconv" title="Permalink to this definition"></a></dt>
<dd><p>ODF constrained-regularized spherical deconvolution using
the Sharpening Deconvolution Transform (SDT) <a class="reference internal" href="#ra707a2933099-1" id="id115">[1]</a>, <a class="reference internal" href="#ra707a2933099-2" id="id116">[2]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>odf_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt>
<dd><p class="first last">ndarray of SH coefficients for the ODF spherical function to be
deconvolved</p>
</dd>
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>, <code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>)</span></dt>
<dd><p class="first last">SDT matrix in SH basis</p>
</dd>
<dt><strong>B_reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>, <code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>)</span></dt>
<dd><p class="first last">SH basis matrix used for deconvolution</p>
</dd>
<dt><strong>lambda_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">lambda parameter in minimization equation (default 1.0)</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">threshold (tau <a href="#id117"><span class="problematic" id="id118">*</span></a>max(fODF)) controlling the amplitude below
which the corresponding fODF is assumed to be zero.</p>
</dd>
<dt><strong>r2_term</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if ODF is computed from model that uses the <span class="math notranslate nohighlight">\(r^2\)</span> term in the
integral.  Recall that Tuchs ODF (used in Q-ball Imaging <a class="reference internal" href="#ra707a2933099-1" id="id119">[1]</a>) and
the true normalized ODF definition differ from a <span class="math notranslate nohighlight">\(r^2\)</span> term in the ODF
integral. The original Sharpening Deconvolution Transform (SDT)
technique <a class="reference internal" href="#ra707a2933099-2" id="id120">[2]</a> is expecting Tuchs ODF without the <span class="math notranslate nohighlight">\(r^2\)</span> (see <a class="reference internal" href="#ra707a2933099-3" id="id121">[3]</a> for
the mathematical details).  Now, this function supports ODF that have
been computed using the <span class="math notranslate nohighlight">\(r^2\)</span> term because the proper analytical
response function has be derived.  For example, models such as DSI,
GQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved
with the r2_term=True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fodf_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt>
<dd><p class="first last">Spherical harmonics coefficients of the constrained-regularized fiber
ODF</p>
</dd>
<dt><strong>num_it</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of iterations in the constrained-regularization used for
convergence</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="ra707a2933099-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id115">2</a>, <a class="fn-backref" href="#id119">3</a>, <a class="fn-backref" href="#id122">4</a>)</em> Tuch, D. MRM 2004. Q-Ball Imaging.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ra707a2933099-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id116">2</a>, <a class="fn-backref" href="#id120">3</a>, <a class="fn-backref" href="#id123">4</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ra707a2933099-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id121">1</a>, <a class="fn-backref" href="#id124">2</a>)</em> Descoteaux, M, PhD thesis, INRIA Sophia-Antipolis, 2008.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="odf-sh-to-sharp">
<h3>odf_sh_to_sharp<a class="headerlink" href="#odf-sh-to-sharp" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.odf_sh_to_sharp">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">odf_sh_to_sharp</code><span class="sig-paren">(</span><em>odfs_sh</em>, <em>sphere</em>, <em>basis=None</em>, <em>ratio=0.2</em>, <em>sh_order=8</em>, <em>lambda_=1.0</em>, <em>tau=0.1</em>, <em>r2_term=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.odf_sh_to_sharp" title="Permalink to this definition"></a></dt>
<dd><p>Sharpen odfs using the sharpening deconvolution transform <a class="reference internal" href="#rc713c9e45b9d-2" id="id125">[2]</a></p>
<p>This function can be used to sharpen any smooth ODF spherical function. In
theory, this should only be used to sharpen QballModel ODFs, but in
practice, one can play with the deconvolution ratio and sharpen almost any
ODF-like spherical function. The constrained-regularization is stable and
will not only sharpen the ODF peaks but also regularize the noisy peaks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>odfs_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>, )</span></dt>
<dd><p class="first last">array of odfs expressed as spherical harmonics coefficients</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">sphere used to build the regularization matrix</p>
</dd>
<dt><strong>basis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, tournier07, descoteaux07}</span></dt>
<dd><p class="first last">different spherical harmonic basis:
<code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="reference internal" href="#rc713c9e45b9d-4" id="id126">[4]</a> basis, and
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="reference internal" href="#rc713c9e45b9d-3" id="id127">[3]</a> basis
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>ratio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">ratio of the smallest vs the largest eigenvalue of the single prolate
tensor response function (<span class="math notranslate nohighlight">\(\frac{\lambda_2}{\lambda_1}\)</span>)</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">maximal SH order of the SH representation</p>
</dd>
<dt><strong>lambda_</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">lambda parameter (see odfdeconv) (default 1.0)</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">tau parameter in the L matrix construction (see odfdeconv)
(default 0.1)</p>
</dd>
<dt><strong>r2_term</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if ODF is computed from model that uses the <span class="math notranslate nohighlight">\(r^2\)</span> term in the
integral.  Recall that Tuchs ODF (used in Q-ball Imaging <a class="reference internal" href="#rc713c9e45b9d-1" id="id128">[1]</a>) and
the true normalized ODF definition differ from a <span class="math notranslate nohighlight">\(r^2\)</span> term in the ODF
integral. The original Sharpening Deconvolution Transform (SDT)
technique <a class="reference internal" href="#rc713c9e45b9d-2" id="id129">[2]</a> is expecting Tuchs ODF without the <span class="math notranslate nohighlight">\(r^2\)</span> (see <a class="reference internal" href="#rc713c9e45b9d-3" id="id130">[3]</a> for
the mathematical details).  Now, this function supports ODF that have
been computed using the <span class="math notranslate nohighlight">\(r^2\)</span> term because the proper analytical
response function has be derived.  For example, models such as DSI,
GQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved
with the r2_term=True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fodf_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">sharpened odf expressed as spherical harmonics coefficients</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rc713c9e45b9d-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id128">1</a>, <a class="fn-backref" href="#id131">2</a>)</em> Tuch, D. MRM 2004. Q-Ball Imaging.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rc713c9e45b9d-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id125">2</a>, <a class="fn-backref" href="#id129">3</a>, <a class="fn-backref" href="#id132">4</a>)</em> Descoteaux, M., et al. IEEE TMI 2009. Deterministic and
Probabilistic Tractography Based on Complex Fibre Orientation
Distributions</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rc713c9e45b9d-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id127">1</a>, <a class="fn-backref" href="#id130">2</a>, <a class="fn-backref" href="#id133">3</a>)</em> Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rc713c9e45b9d-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id126">1</a>, <a class="fn-backref" href="#id134">2</a>)</em> Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="peaks-from-model">
<h3>peaks_from_model<a class="headerlink" href="#peaks-from-model" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.peaks_from_model">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">peaks_from_model</code><span class="sig-paren">(</span><em>model</em>, <em>data</em>, <em>sphere</em>, <em>relative_peak_threshold</em>, <em>min_separation_angle</em>, <em>mask=None</em>, <em>return_odf=False</em>, <em>return_sh=True</em>, <em>gfa_thr=0</em>, <em>normalize_peaks=False</em>, <em>sh_order=8</em>, <em>sh_basis_type=None</em>, <em>npeaks=5</em>, <em>B=None</em>, <em>invB=None</em>, <em>parallel=False</em>, <em>nbr_processes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.peaks_from_model" title="Permalink to this definition"></a></dt>
<dd><p>Fit the model to data and computes peaks and metrics</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a model instance</span></dt>
<dd><p class="first last"><cite>model</cite> will be used to fit the data.</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The Sphere providing discrete directions for evaluation.</p>
</dd>
<dt><strong>relative_peak_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Only return peaks greater than <code class="docutils literal notranslate"><span class="pre">relative_peak_threshold</span> <span class="pre">*</span> <span class="pre">m</span></code> where m
is the largest peak.</p>
</dd>
<dt><strong>min_separation_angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float in [0, 90] The minimum distance between</span></dt>
<dd><p class="first last">directions. If two peaks are too close only the larger of the two is
returned.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd><p class="first last">If <cite>mask</cite> is provided, voxels that are False in <cite>mask</cite> are skipped and
no peaks are returned.</p>
</dd>
<dt><strong>return_odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, the odfs are returned.</p>
</dd>
<dt><strong>return_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, the odf as spherical harmonics coefficients is returned</p>
</dd>
<dt><strong>gfa_thr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Voxels with gfa less than <cite>gfa_thr</cite> are skipped, no peaks are returned.</p>
</dd>
<dt><strong>normalize_peaks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, all peak values are calculated relative to <cite>max(odf)</cite>.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients (default 8).</p>
</dd>
<dt><strong>sh_basis_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, tournier07, descoteaux07}</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="reference internal" href="#r50d34e03da10-2" id="id135">[2]</a> basis, and
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="reference internal" href="#r50d34e03da10-1" id="id136">[1]</a> basis
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>sh_smooth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Lambda-regularization in the SH fit (default 0.0).</p>
</dd>
<dt><strong>npeaks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of peaks found (default 5 peaks).</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">Matrix that transforms spherical harmonics to spherical function
<code class="docutils literal notranslate"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></code>.</p>
</dd>
<dt><strong>invB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">Inverse of B.</p>
</dd>
<dt><strong>parallel: bool</strong></dt>
<dd><p class="first last">If True, use multiprocessing to compute peaks and metric
(default False). Temporary files are saved in the default temporary
directory of the system. It can be changed using <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">tempfile</span></code>
and <code class="docutils literal notranslate"><span class="pre">tempfile.tempdir</span> <span class="pre">=</span> <span class="pre">'/path/to/tempdir'</span></code>.</p>
</dd>
<dt><strong>nbr_processes: int</strong></dt>
<dd><p class="first last">If <cite>parallel</cite> is True, the number of subprocesses to use
(default multiprocessing.cpu_count()).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pam</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PeaksAndMetrics</span></dt>
<dd><p class="first last">An object with <code class="docutils literal notranslate"><span class="pre">gfa</span></code>, <code class="docutils literal notranslate"><span class="pre">peak_directions</span></code>, <code class="docutils literal notranslate"><span class="pre">peak_values</span></code>,
<code class="docutils literal notranslate"><span class="pre">peak_indices</span></code>, <code class="docutils literal notranslate"><span class="pre">odf</span></code>, <code class="docutils literal notranslate"><span class="pre">shm_coeffs</span></code> as attributes</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r50d34e03da10-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id136">1</a>, <a class="fn-backref" href="#id137">2</a>)</em> Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r50d34e03da10-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id135">1</a>, <a class="fn-backref" href="#id138">2</a>)</em> Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="quad">
<h3>quad<a class="headerlink" href="#quad" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.quad">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">quad</code><span class="sig-paren">(</span><em>func</em>, <em>a</em>, <em>b</em>, <em>args=()</em>, <em>full_output=0</em>, <em>epsabs=1.49e-08</em>, <em>epsrel=1.49e-08</em>, <em>limit=50</em>, <em>points=None</em>, <em>weight=None</em>, <em>wvar=None</em>, <em>wopts=None</em>, <em>maxp1=50</em>, <em>limlst=50</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.quad" title="Permalink to this definition"></a></dt>
<dd><p>Compute a definite integral.</p>
<p>Integrate func from <cite>a</cite> to <cite>b</cite> (possibly infinite interval) using a
technique from the Fortran library QUADPACK.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{function, scipy.LowLevelCallable}</span></dt>
<dd><p class="first">A Python function or method to integrate.  If <cite>func</cite> takes many
arguments, it is integrated along the axis corresponding to the
first argument.</p>
<p>If the user desires improved integration performance, then <cite>f</cite> may
be a <cite>scipy.LowLevelCallable</cite> with one of the signatures:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">func</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">)</span>
<span class="n">double</span> <span class="n">func</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span>
<span class="n">double</span> <span class="n">func</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">xx</span><span class="p">)</span>
<span class="n">double</span> <span class="n">func</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">xx</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">user_data</span></code> is the data contained in the <cite>scipy.LowLevelCallable</cite>.
In the call forms with <code class="docutils literal notranslate"><span class="pre">xx</span></code>,  <code class="docutils literal notranslate"><span class="pre">n</span></code> is the length of the <code class="docutils literal notranslate"><span class="pre">xx</span></code>
array which contains <code class="docutils literal notranslate"><span class="pre">xx[0]</span> <span class="pre">==</span> <span class="pre">x</span></code> and the rest of the items are
numbers contained in the <code class="docutils literal notranslate"><span class="pre">args</span></code> argument of quad.</p>
<p class="last">In addition, certain ctypes call signatures are supported for
backward compatibility, but those should not be used in new code.</p>
</dd>
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Lower limit of integration (use -numpy.inf for -infinity).</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Upper limit of integration (use numpy.inf for +infinity).</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, optional</span></dt>
<dd><p class="first last">Extra arguments to pass to <cite>func</cite>.</p>
</dd>
<dt><strong>full_output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Non-zero to return a dictionary of integration information.
If non-zero, warning messages are also suppressed and the
message is appended to the output tuple.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The integral of func from <cite>a</cite> to <cite>b</cite>.</p>
</dd>
<dt><strong>abserr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">An estimate of the absolute error in the result.</p>
</dd>
<dt><strong>infodict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary containing additional information.
Run scipy.integrate.quad_explain() for more information.</p>
</dd>
<dt><strong>message</strong></dt>
<dd><p class="first last">A convergence message.</p>
</dd>
<dt><strong>explain</strong></dt>
<dd><p class="first last">Appended only with cos or sin weighting and infinite
integration limits, it contains an explanation of the codes in
infodict[ierlst]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>epsabs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or int, optional</span></dt>
<dd><p class="first last">Absolute error tolerance.</p>
</dd>
<dt><strong>epsrel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or int, optional</span></dt>
<dd><p class="first last">Relative error tolerance.</p>
</dd>
<dt><strong>limit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or int, optional</span></dt>
<dd><p class="first last">An upper bound on the number of subintervals used in the adaptive
algorithm.</p>
</dd>
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(sequence of floats,ints), optional</span></dt>
<dd><p class="first last">A sequence of break points in the bounded integration interval
where local difficulties of the integrand may occur (e.g.,
singularities, discontinuities). The sequence does not have
to be sorted.</p>
</dd>
<dt><strong>weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or int, optional</span></dt>
<dd><p class="first last">String indicating weighting function. Full explanation for this
and the remaining arguments can be found below.</p>
</dd>
<dt><strong>wvar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">optional</span></dt>
<dd><p class="first last">Variables for use with weighting functions.</p>
</dd>
<dt><strong>wopts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">optional</span></dt>
<dd><p class="first last">Optional input for reusing Chebyshev moments.</p>
</dd>
<dt><strong>maxp1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or int, optional</span></dt>
<dd><p class="first last">An upper bound on the number of Chebyshev moments.</p>
</dd>
<dt><strong>limlst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Upper bound on the number of cycles (&gt;=3) for use with a sinusoidal
weighting and an infinite end-point.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dblquad</span></code></dt>
<dd>double integral</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">tplquad</span></code></dt>
<dd>triple integral</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nquad</span></code></dt>
<dd>n-dimensional integrals (uses <cite>quad</cite> recursively)</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">fixed_quad</span></code></dt>
<dd>fixed-order Gaussian quadrature</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadrature</span></code></dt>
<dd>adaptive Gaussian quadrature</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">odeint</span></code></dt>
<dd>ODE integrator</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ode</span></code></dt>
<dd>ODE integrator</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">simps</span></code></dt>
<dd>integrator for sampled data</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">romb</span></code></dt>
<dd>integrator for sampled data</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.special</span></code></dt>
<dd>for coefficients and roots of orthogonal polynomials</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><strong>Extra information for quad() inputs and outputs</strong></p>
<p>If full_output is non-zero, then the third output argument
(infodict) is a dictionary with entries as tabulated below.  For
infinite limits, the range is transformed to (0,1) and the
optional outputs are given with respect to this transformed range.
Let M be the input argument limit and let K be infodict[last].
The entries are:</p>
<dl class="docutils">
<dt>neval</dt>
<dd>The number of function evaluations.</dd>
<dt>last</dt>
<dd>The number, K, of subintervals produced in the subdivision process.</dd>
<dt>alist</dt>
<dd>A rank-1 array of length M, the first K elements of which are the
left end points of the subintervals in the partition of the
integration range.</dd>
<dt>blist</dt>
<dd>A rank-1 array of length M, the first K elements of which are the
right end points of the subintervals.</dd>
<dt>rlist</dt>
<dd>A rank-1 array of length M, the first K elements of which are the
integral approximations on the subintervals.</dd>
<dt>elist</dt>
<dd>A rank-1 array of length M, the first K elements of which are the
moduli of the absolute error estimates on the subintervals.</dd>
<dt>iord</dt>
<dd>A rank-1 integer array of length M, the first L elements of
which are pointers to the error estimates over the subintervals
with <code class="docutils literal notranslate"><span class="pre">L=K</span></code> if <code class="docutils literal notranslate"><span class="pre">K&lt;=M/2+2</span></code> or <code class="docutils literal notranslate"><span class="pre">L=M+1-K</span></code> otherwise. Let I be the
sequence <code class="docutils literal notranslate"><span class="pre">infodict['iord']</span></code> and let E be the sequence
<code class="docutils literal notranslate"><span class="pre">infodict['elist']</span></code>.  Then <code class="docutils literal notranslate"><span class="pre">E[I[1]],</span> <span class="pre">...,</span> <span class="pre">E[I[L]]</span></code> forms a
decreasing sequence.</dd>
</dl>
<p>If the input argument points is provided (i.e. it is not None),
the following additional outputs are placed in the output
dictionary.  Assume the points sequence is of length P.</p>
<dl class="docutils">
<dt>pts</dt>
<dd>A rank-1 array of length P+2 containing the integration limits
and the break points of the intervals in ascending order.
This is an array giving the subintervals over which integration
will occur.</dd>
<dt>level</dt>
<dd>A rank-1 integer array of length M (=limit), containing the
subdivision levels of the subintervals, i.e., if (aa,bb) is a
subinterval of <code class="docutils literal notranslate"><span class="pre">(pts[1],</span> <span class="pre">pts[2])</span></code> where <code class="docutils literal notranslate"><span class="pre">pts[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">pts[2]</span></code>
are adjacent elements of <code class="docutils literal notranslate"><span class="pre">infodict['pts']</span></code>, then (aa,bb) has level l
if <code class="docutils literal notranslate"><span class="pre">|bb-aa|</span> <span class="pre">=</span> <span class="pre">|pts[2]-pts[1]|</span> <span class="pre">*</span> <span class="pre">2**(-l)</span></code>.</dd>
<dt>ndin</dt>
<dd>A rank-1 integer array of length P+2.  After the first integration
over the intervals (pts[1], pts[2]), the error estimates over some
of the intervals may have been increased artificially in order to
put their subdivision forward.  This array has ones in slots
corresponding to the subintervals for which this happens.</dd>
</dl>
<p><strong>Weighting the integrand</strong></p>
<p>The input variables, <em>weight</em> and <em>wvar</em>, are used to weight the
integrand by a select list of functions.  Different integration
methods are used to compute the integral with these weighting
functions.  The possible values of weight and the corresponding
weighting functions are.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="53%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal notranslate"><span class="pre">weight</span></code></th>
<th class="head">Weight function used</th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">wvar</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>cos</td>
<td>cos(w*x)</td>
<td>wvar = w</td>
</tr>
<tr class="row-odd"><td>sin</td>
<td>sin(w*x)</td>
<td>wvar = w</td>
</tr>
<tr class="row-even"><td>alg</td>
<td>g(x) = ((x-a)**alpha)*((b-x)**beta)</td>
<td>wvar = (alpha, beta)</td>
</tr>
<tr class="row-odd"><td>alg-loga</td>
<td>g(x)*log(x-a)</td>
<td>wvar = (alpha, beta)</td>
</tr>
<tr class="row-even"><td>alg-logb</td>
<td>g(x)*log(b-x)</td>
<td>wvar = (alpha, beta)</td>
</tr>
<tr class="row-odd"><td>alg-log</td>
<td>g(x)*log(x-a)*log(b-x)</td>
<td>wvar = (alpha, beta)</td>
</tr>
<tr class="row-even"><td>cauchy</td>
<td>1/(x-c)</td>
<td>wvar = c</td>
</tr>
</tbody>
</table>
<p>wvar holds the parameter w, (alpha, beta), or c depending on the weight
selected.  In these expressions, a and b are the integration limits.</p>
<p>For the cos and sin weighting, additional inputs and outputs are
available.</p>
<p>For finite integration limits, the integration is performed using a
Clenshaw-Curtis method which uses Chebyshev moments.  For repeated
calculations, these moments are saved in the output dictionary:</p>
<dl class="docutils">
<dt>momcom</dt>
<dd>The maximum level of Chebyshev moments that have been computed,
i.e., if <code class="docutils literal notranslate"><span class="pre">M_c</span></code> is <code class="docutils literal notranslate"><span class="pre">infodict['momcom']</span></code> then the moments have been
computed for intervals of length <code class="docutils literal notranslate"><span class="pre">|b-a|</span> <span class="pre">*</span> <span class="pre">2**(-l)</span></code>,
<code class="docutils literal notranslate"><span class="pre">l=0,1,...,M_c</span></code>.</dd>
<dt>nnlog</dt>
<dd>A rank-1 integer array of length M(=limit), containing the
subdivision levels of the subintervals, i.e., an element of this
array is equal to l if the corresponding subinterval is
<code class="docutils literal notranslate"><span class="pre">|b-a|*</span> <span class="pre">2**(-l)</span></code>.</dd>
<dt>chebmo</dt>
<dd>A rank-2 array of shape (25, maxp1) containing the computed
Chebyshev moments.  These can be passed on to an integration
over the same interval by passing this array as the second
element of the sequence wopts and passing infodict[momcom] as
the first element.</dd>
</dl>
<p>If one of the integration limits is infinite, then a Fourier integral is
computed (assuming w neq 0).  If full_output is 1 and a numerical error
is encountered, besides the error message attached to the output tuple,
a dictionary is also appended to the output tuple which translates the
error codes in the array <code class="docutils literal notranslate"><span class="pre">info['ierlst']</span></code> to English messages.  The
output information dictionary contains the following entries instead of
last, alist, blist, rlist, and elist:</p>
<dl class="docutils">
<dt>lst</dt>
<dd>The number of subintervals needed for the integration (call it <code class="docutils literal notranslate"><span class="pre">K_f</span></code>).</dd>
<dt>rslst</dt>
<dd>A rank-1 array of length M_f=limlst, whose first <code class="docutils literal notranslate"><span class="pre">K_f</span></code> elements
contain the integral contribution over the interval
<code class="docutils literal notranslate"><span class="pre">(a+(k-1)c,</span> <span class="pre">a+kc)</span></code> where <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">(2*floor(|w|)</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">pi</span> <span class="pre">/</span> <span class="pre">|w|</span></code>
and <code class="docutils literal notranslate"><span class="pre">k=1,2,...,K_f</span></code>.</dd>
<dt>erlst</dt>
<dd>A rank-1 array of length <code class="docutils literal notranslate"><span class="pre">M_f</span></code> containing the error estimate
corresponding to the interval in the same position in
<code class="docutils literal notranslate"><span class="pre">infodict['rslist']</span></code>.</dd>
<dt>ierlst</dt>
<dd>A rank-1 integer array of length <code class="docutils literal notranslate"><span class="pre">M_f</span></code> containing an error flag
corresponding to the interval in the same position in
<code class="docutils literal notranslate"><span class="pre">infodict['rslist']</span></code>.  See the explanation dictionary (last entry
in the output tuple) for the meaning of the codes.</dd>
</dl>
<p class="rubric">Examples</p>
<p>Calculate <span class="math notranslate nohighlight">\(\int^4_0 x^2 dx\)</span> and compare with an analytic result</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">integrate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(21.333333333333332, 2.3684757858670003e-13)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="mi">4</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>  <span class="c1"># analytical result</span>
<span class="go">21.3333333333</span>
</pre></div>
</div>
<p>Calculate <span class="math notranslate nohighlight">\(\int^\infty_0 e^{-x} dx\)</span></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invexp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">invexp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">(1.0, 5.842605999138044e-11)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">a</span> <span class="p">:</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">1.5</span>
</pre></div>
</div>
<p>Calculate <span class="math notranslate nohighlight">\(\int^1_0 x^2 + y^2 dx\)</span> with ctypes, holding
y parameter as 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">testlib</span><span class="o">.</span><span class="n">c</span> <span class="o">=&gt;</span>
    <span class="n">double</span> <span class="n">func</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">double</span> <span class="n">args</span><span class="p">[</span><span class="n">n</span><span class="p">]){</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];}</span>
<span class="nb">compile</span> <span class="n">to</span> <span class="n">library</span> <span class="n">testlib</span><span class="o">.*</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">integrate</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="n">lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="s1">&#39;/home/.../testlib.*&#39;</span><span class="p">)</span> <span class="c1">#use absolute path</span>
<span class="n">lib</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
<span class="n">lib</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)</span>
<span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">func</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">1</span><span class="p">))</span>
<span class="c1">#(1.3333333333333333, 1.4802973661668752e-14)</span>
<span class="nb">print</span><span class="p">((</span><span class="mf">1.0</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mf">3.0</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.0</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mf">3.0</span> <span class="o">+</span> <span class="mf">0.0</span><span class="p">))</span> <span class="c1">#Analytic result</span>
<span class="c1"># 1.3333333333333333</span>
</pre></div>
</div>
<p>Be aware that pulse shapes and other sharp features as compared to the
size of the integration interval may not be integrated correctly using
this method. A simplified example of this limitation is integrating a
y-axis reflected step function with many zero values within the integrals
bounds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(1.0, 1.1102230246251565e-14)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">(1.0000000002199108, 1.0189464580163188e-08)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
<span class="go">(0.0, 0.0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="real-sph-harm">
<h3>real_sph_harm<a class="headerlink" href="#real-sph-harm" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.real_sph_harm">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">real_sph_harm</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.real_sph_harm" title="Permalink to this definition"></a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>Where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:</p>
<blockquote>
<div>Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
<span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code></span></dt>
<dd><p class="first last">The order of the harmonic.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt>
<dd><p class="first last">The degree of the harmonic.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">real float</span></dt>
<dd><p class="first last">The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.special.sph_harm</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="real-sym-sh-basis">
<h3>real_sym_sh_basis<a class="headerlink" href="#real-sym-sh-basis" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.real_sym_sh_basis">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">real_sym_sh_basis</code><span class="sig-paren">(</span><em>sh_order</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.real_sym_sh_basis" title="Permalink to this definition"></a></dt>
<dd><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p>
<p>Samples the basis functions up to order <cite>sh_order</cite> at points on the sphere
given by <cite>theta</cite> and <cite>phi</cite>. The basis functions are defined here the same
way as in Descoteaux et al. 2007 <a class="reference internal" href="#r434b25cab165-1" id="id139">[1]</a> where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is
defined to be:</p>
<blockquote>
<div>Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
<span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">even int &gt; 0, max spherical harmonic degree</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">real float</span></dt>
<dd><p class="first last">The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite></p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The order of the harmonics.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The degree of the harmonics.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r434b25cab165-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id139">1</a>, <a class="fn-backref" href="#id140">2</a>)</em> Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="recursive-response">
<h3>recursive_response<a class="headerlink" href="#recursive-response" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.recursive_response">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">recursive_response</code><span class="sig-paren">(</span><em>gtab</em>, <em>data</em>, <em>mask=None</em>, <em>sh_order=8</em>, <em>peak_thr=0.01</em>, <em>init_fa=0.08</em>, <em>init_trace=0.0021</em>, <em>iter=8</em>, <em>convergence=0.001</em>, <em>parallel=True</em>, <em>nbr_processes=None</em>, <em>sphere=&lt;dipy.core.sphere.HemiSphere object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.recursive_response" title="Permalink to this definition"></a></dt>
<dd><p>Recursive calibration of response function using peak threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">diffusion data</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">mask for recursive calibration, for example a white matter mask. It has
shape <cite>data.shape[0:3]</cite> and dtype=bool. Default: use the entire data
array.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">maximal spherical harmonics order. Default: 8</p>
</dd>
<dt><strong>peak_thr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">peak threshold, how large the second peak can be relative to the first
peak in order to call it a single fiber population [1]. Default: 0.01</p>
</dd>
<dt><strong>init_fa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">FA of the initial fat response function (tensor). Default: 0.08</p>
</dd>
<dt><strong>init_trace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">trace of the initial fat response function (tensor). Default: 0.0021</p>
</dd>
<dt><strong>iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">maximum number of iterations for calibration. Default: 8.</p>
</dd>
<dt><strong>convergence</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">convergence criterion, maximum relative change of SH
coefficients. Default: 0.001.</p>
</dd>
<dt><strong>parallel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to use parallelization in peak-finding during the calibration
procedure. Default: True</p>
</dd>
<dt><strong>nbr_processes: int</strong></dt>
<dd><p class="first last">If <cite>parallel</cite> is True, the number of subprocesses to use
(default multiprocessing.cpu_count()).</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere, optional.</span></dt>
<dd><p class="first last">The sphere used for peak finding. Default: default_sphere.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>response</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">response function in SH coefficients</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In CSD there is an important pre-processing step: the estimation of the
fiber response function. Using an FA threshold is not a very robust method.
It is dependent on the dataset (non-informed used subjectivity), and still
depends on the diffusion tensor (FA and first eigenvector),
which has low accuracy at high b-value. This function recursively
calibrates the response function, for more information see [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rbeb1f12bf5b3-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id141">[1]</a></td><td>Tax, C.M.W., et al. NeuroImage 2014. Recursive calibration of
the fiber response function for spherical deconvolution of
diffusion MRI data.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="response-from-mask">
<h3>response_from_mask<a class="headerlink" href="#response-from-mask" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.response_from_mask">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">response_from_mask</code><span class="sig-paren">(</span><em>gtab</em>, <em>data</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.response_from_mask" title="Permalink to this definition"></a></dt>
<dd><p>Estimate the response function from a given mask.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Diffusion data</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Mask to use for the estimation of the response function. For example a
mask of the white matter voxels with FA values higher than 0.7
(see <a class="reference internal" href="#r64bc28ca561d-1" id="id142">[1]</a>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>response</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, (2,)</span></dt>
<dd><p class="first last">(<cite>evals</cite>, <cite>S0</cite>)</p>
</dd>
<dt><strong>ratio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The ratio between smallest versus largest eigenvalue of the response.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See csdeconv.auto_response() or csdeconv.recursive_response() if you dont
have a computed mask for the response function estimation.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r64bc28ca561d-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id142">1</a>, <a class="fn-backref" href="#id143">2</a>)</em> Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</td></tr>
</tbody>
</table>
<p>fiber orientation density function from diffusion-weighted MRI
data using spherical deconvolution</p>
</dd></dl>

</div>
<div class="section" id="sh-to-rh">
<h3>sh_to_rh<a class="headerlink" href="#sh-to-rh" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.sh_to_rh">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">sh_to_rh</code><span class="sig-paren">(</span><em>r_sh</em>, <em>m</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.sh_to_rh" title="Permalink to this definition"></a></dt>
<dd><p>Spherical harmonics (SH) to rotational harmonics (RH)</p>
<p>Calculate the rotational harmonic decomposition up to
harmonic order <cite>m</cite>, degree <cite>n</cite> for an axially and antipodally
symmetric function. Note that all <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">!=</span> <span class="pre">0</span></code> coefficients
will be ignored as axial symmetry is assumed. Hence, there
will be <code class="docutils literal notranslate"><span class="pre">(sh_order/2</span> <span class="pre">+</span> <span class="pre">1)</span></code> non-zero coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">ndarray of SH coefficients for the single fiber response function.
These coefficients must correspond to the real spherical harmonic
functions produced by <cite>shm.real_sph_harm</cite>.</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">The order of the spherical harmonic function associated with each
coefficient.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">The degree of the spherical harmonic function associated with each
coefficient.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r_rh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt>
<dd><p class="first last">Rotational harmonics coefficients representing the input <cite>r_sh</cite></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sph_harm</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sym_sh_basis</span></code></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rfcfdfef87aa2-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id144">[1]</a></td><td>Tournier, J.D., et al. NeuroImage 2007. Robust determination of the
fibre orientation distribution in diffusion MRI: Non-negativity
constrained super-resolved spherical deconvolution</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="single-tensor">
<h3>single_tensor<a class="headerlink" href="#single-tensor" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.single_tensor">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">single_tensor</code><span class="sig-paren">(</span><em>gtab</em>, <em>S0=1</em>, <em>evals=None</em>, <em>evecs=None</em>, <em>snr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.single_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Simulated Q-space signal with a single tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd><p class="first last">Measurement directions.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">double,</span></dt>
<dd><p class="first last">Strength of signal in the presence of no diffusion gradient (also
called the <code class="docutils literal notranslate"><span class="pre">b=0</span></code> value).</p>
</dd>
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray</span></dt>
<dd><p class="first last">Eigenvalues of the diffusion tensor.  By default, values typical for
prolate white matter are used.</p>
</dd>
<dt><strong>evecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first last">Eigenvectors of the tensor.  You can also think of this as a rotation
matrix that transforms the direction of the tensor. The eigenvectors
need to be column wise.</p>
</dd>
<dt><strong>snr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Signal to noise ratio, assuming Rician noise.  None implies no noise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last">Simulated signal: <code class="docutils literal notranslate"><span class="pre">S(q,</span> <span class="pre">tau)</span> <span class="pre">=</span> <span class="pre">S_0</span> <span class="pre">e^(-b</span> <span class="pre">g^T</span> <span class="pre">R</span> <span class="pre">D</span> <span class="pre">R.T</span> <span class="pre">g)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re8d2d5c91ad1-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id145">[1]</a></td><td>M. Descoteaux, High Angular Resolution Diffusion MRI: from Local
Estimation to Segmentation and Tractography, PhD thesis,
University of Nice-Sophia Antipolis, p. 42, 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="re8d2d5c91ad1-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id146">[2]</a></td><td>E. Stejskal and J. Tanner, Spin diffusion measurements: spin echos
in the presence of a time-dependent field gradient, Journal of
Chemical Physics, nr. 42, pp. 288292, 1965.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sph-harm-ind-list">
<h3>sph_harm_ind_list<a class="headerlink" href="#sph-harm-ind-list" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.sph_harm_ind_list">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">sph_harm_ind_list</code><span class="sig-paren">(</span><em>sh_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.sph_harm_ind_list" title="Permalink to this definition"></a></dt>
<dd><p>Returns the degree (n) and order (m) of all the symmetric spherical
harmonics of degree less then or equal to <cite>sh_order</cite>. The results, <cite>m_list</cite>
and <cite>n_list</cite> are kx1 arrays, where k depends on sh_order. They can be
passed to <a class="reference internal" href="#dipy.reconst.csdeconv.real_sph_harm" title="dipy.reconst.csdeconv.real_sph_harm"><code class="xref py py-func docutils literal notranslate"><span class="pre">real_sph_harm()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">even int &gt; 0, max degree to return</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>m_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">orders of even spherical harmonics</p>
</dd>
<dt><strong>n_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">degrees of even spherical harmonics</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.csdeconv.real_sph_harm" title="dipy.reconst.csdeconv.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="vec2vec-rotmat">
<h3>vec2vec_rotmat<a class="headerlink" href="#vec2vec-rotmat" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.csdeconv.vec2vec_rotmat">
<code class="descclassname">dipy.reconst.csdeconv.</code><code class="descname">vec2vec_rotmat</code><span class="sig-paren">(</span><em>u</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.csdeconv.vec2vec_rotmat" title="Permalink to this definition"></a></dt>
<dd><p>rotation matrix from 2 unit vectors</p>
<p>u, v being unit 3d vectors return a 3x3 rotation matrix R than aligns u to
v.</p>
<p>In general there are many rotations that will map u to v. If S is any
rotation using v as an axis then R.S will also map u to v since (S.R)u =
S(Ru) = Sv = v.  The rotation R returned by vec2vec_rotmat leaves fixed the
perpendicular to the plane spanned by u and v.</p>
<p>The transpose of R will align v to u.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape(3,)</span></dt>
<dd></dd>
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape(3,)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape(3,3)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.geometry</span> <span class="k">import</span> <span class="n">vec2vec_rotmat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">=</span><span class="n">vec2vec_rotmat</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
<span class="go">array([ 1.,  0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="diffusionkurtosisfit">
<h3><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a><a class="headerlink" href="#diffusionkurtosisfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dki.DiffusionKurtosisFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.dki.</code><code class="descname">DiffusionKurtosisFit</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.dti.TensorFit</span></code></a></p>
<p>Class for fitting the Diffusion Kurtosis Model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S0_hat</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></dt>
<dd><p class="first last">For tracking - return the primary direction in each voxel</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></dt>
<dd><p class="first last">Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></dt>
<dd><p class="first last">Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.kt" title="dipy.reconst.dki.DiffusionKurtosisFit.kt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kt</span></code></a></dt>
<dd><p class="first last">Returns the 15 independent elements of the kurtosis tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></dt>
<dd><p class="first last">Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code>()</td>
<td>Axial diffusivity (AD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code>(sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction on</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.ak" title="dipy.reconst.dki.DiffusionKurtosisFit.ak"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ak</span></code></a>([min_kurtosis,&nbsp;max_kurtosis])</td>
<td>Axial Kurtosis (AK) of a diffusion kurtosis tensor <a class="reference internal" href="#r9df403773432-1" id="id147">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.akc" title="dipy.reconst.dki.DiffusionKurtosisFit.akc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">akc</span></code></a>(sphere)</td>
<td>Calculates the apparent kurtosis coefficient (AKC) in each direction on the sphere for each voxel in the data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code>()</td>
<td>Color fractional anisotropy of diffusion tensor</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code>()</td>
<td>Fractional anisotropy (FA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code>()</td>
<td>Geodesic anisotropy (GA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.kmax" title="dipy.reconst.dki.DiffusionKurtosisFit.kmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kmax</span></code></a>([sphere,&nbsp;gtol,&nbsp;mask])</td>
<td>Computes the maximum value of a single voxel kurtosis tensor</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code>()</td>
<td>Mean diffusivity (MD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.mk" title="dipy.reconst.dki.DiffusionKurtosisFit.mk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mk</span></code></a>([min_kurtosis,&nbsp;max_kurtosis])</td>
<td>Computes mean Kurtosis (MK) from the kurtosis tensor.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code>()</td>
<td>Tensor mode calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</td>
<td>The diffusion orientation distribution function (dODF).</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.predict" title="dipy.reconst.dki.DiffusionKurtosisFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab[,&nbsp;S0])</td>
<td>Given a DKI model fit, predict the signal on the vertices of a gradient table</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code>()</td>
<td>Radial diffusivity (RD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit.rk" title="dipy.reconst.dki.DiffusionKurtosisFit.rk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rk</span></code></a>([min_kurtosis,&nbsp;max_kurtosis])</td>
<td>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class="reference internal" href="#r1ebb108e90df-1" id="id148">[1]</a>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>()</td>
<td>Trace of the tensor calculated from cached eigenvalues.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>lower_triangular</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a DiffusionKurtosisFit class instance.</p>
<p>Since DKI is an extension of DTI, class instance is defined as subclass
of the TensorFit from dti.py</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DiffusionKurtosisModel Class instance</span></dt>
<dd><p class="first last">Class instance containing the Diffusion Kurtosis Model for the fit</p>
</dd>
<dt><strong>model_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisFit.ak">
<code class="descname">ak</code><span class="sig-paren">(</span><em>min_kurtosis=-0.42857142857142855</em>, <em>max_kurtosis=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.ak" title="Permalink to this definition"></a></dt>
<dd><p>Axial Kurtosis (AK) of a diffusion kurtosis tensor <a class="reference internal" href="#r9df403773432-1" id="id149">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores <a class="reference internal" href="#r9df403773432-2" id="id150">[2]</a>)</p>
</dd>
<dt><strong>max_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ak</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated AK.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r9df403773432-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id147">1</a>, <a class="fn-backref" href="#id149">2</a>, <a class="fn-backref" href="#id151">3</a>)</em> Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r9df403773432-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id150">1</a>, <a class="fn-backref" href="#id152">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisFit.akc">
<code class="descname">akc</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.akc" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the apparent kurtosis coefficient (AKC) in each
direction on the sphere for each voxel in the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>akc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The estimates of the apparent kurtosis coefficient in every
direction on the input sphere</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For each sphere direction with coordinates <span class="math notranslate nohighlight">\((n_{1}, n_{2}, n_{3})\)</span>, the
calculation of AKC is done using formula:</p>
<div class="math notranslate nohighlight">
\[AKC(n)=\frac{MD^{2}}{ADC(n)^{2}}\sum_{i=1}^{3}\sum_{j=1}^{3}
\sum_{k=1}^{3}\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\]</div>
<p>where <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the kurtosis tensor, MD the mean
diffusivity and ADC the apparent diffusion coefficent computed as:</p>
<div class="math notranslate nohighlight">
\[ADC(n)=\sum_{i=1}^{3}\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\]</div>
<p>where <span class="math notranslate nohighlight">\(D_{ij}\)</span> are the elements of the diffusion tensor.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisFit.kmax">
<code class="descname">kmax</code><span class="sig-paren">(</span><em>sphere='repulsion100'</em>, <em>gtol=1e-05</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.kmax" title="Permalink to this definition"></a></dt>
<dd><p>Computes the maximum value of a single voxel kurtosis tensor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance, optional</span></dt>
<dd><p class="first last">The sphere providing sample directions for the initial search of
the maximum value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">This input is to refine kurtosis maximum under the precision of the
directions sampled on the sphere class instance. The gradient of
the convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken
from the initial sampled directions of the given sphere object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>max_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">kurtosis tensor maximum value</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.DiffusionKurtosisFit.kt">
<code class="descname">kt</code><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.kt" title="Permalink to this definition"></a></dt>
<dd><p>Returns the 15 independent elements of the kurtosis tensor as an array</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisFit.mk">
<code class="descname">mk</code><span class="sig-paren">(</span><em>min_kurtosis=-0.42857142857142855</em>, <em>max_kurtosis=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.mk" title="Permalink to this definition"></a></dt>
<dd><p>Computes mean Kurtosis (MK) from the kurtosis tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores <a class="reference internal" href="#r1a4c5980fd18-2" id="id153">[2]</a>)</p>
</dd>
<dt><strong>max_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mk</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated MK.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The MK analytical solution is calculated using the following equation
<a class="reference internal" href="#r1a4c5980fd18-1" id="id154">[1]</a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}MK=F_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{1111}+
F_1(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{2222}+
F_1(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{3333}+ \\
F_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}+
F_2(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{1133}+
F_2(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{1122}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{W}_{ijkl}\)</span> are the components of the <span class="math notranslate nohighlight">\(W\)</span> tensor in the
coordinates system defined by the eigenvectors of the diffusion tensor
<span class="math notranslate nohighlight">\(\mathbf{D}\)</span> and</p>
<div class="math notranslate nohighlight">
\[\begin{split}F_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{18(\lambda_1-\lambda_2)(\lambda_1-\lambda_3)}
[\frac{\sqrt{\lambda_2\lambda_3}}{\lambda_1}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{3\lambda_1^2-\lambda_1\lambda_2-\lambda_2\lambda_3-
\lambda_1\lambda_3}
{3\lambda_1 \sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-1 ]\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}F_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{3(\lambda_2-\lambda_3)^2}
[\frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{2\lambda_1-\lambda_2-\lambda_3}{3\sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-2]\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(R_f\)</span> and <span class="math notranslate nohighlight">\(R_d\)</span> are the Carlsons elliptic integrals.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1a4c5980fd18-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id154">1</a>, <a class="fn-backref" href="#id155">2</a>)</em> Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1a4c5980fd18-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id153">1</a>, <a class="fn-backref" href="#id156">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Given a DKI model fit, predict the signal on the vertices of a
gradient table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray (optional)</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S(n,b)=S_{0}e^{-bD(n)+\frac{1}{6}b^{2}D(n)^{2}K(n)}\]</div>
<p><span class="math notranslate nohighlight">\(\mathbf{D(n)}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{K(n)}\)</span> can be computed from the DT and KT
using the following equations:</p>
<div class="math notranslate nohighlight">
\[D(n)=\sum_{i=1}^{3}\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[K(n)=\frac{MD^{2}}{D(n)^{2}}\sum_{i=1}^{3}\sum_{j=1}^{3}
\sum_{k=1}^{3}\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\]</div>
<p>where <span class="math notranslate nohighlight">\(D_{ij}\)</span> and <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the second-order DT
and the fourth-order KT tensors, respectively, and <span class="math notranslate nohighlight">\(MD\)</span> is the mean
diffusivity.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisFit.rk">
<code class="descname">rk</code><span class="sig-paren">(</span><em>min_kurtosis=-0.42857142857142855</em>, <em>max_kurtosis=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisFit.rk" title="Permalink to this definition"></a></dt>
<dd><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class="reference internal" href="#r1ebb108e90df-1" id="id157">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores <a class="reference internal" href="#r1ebb108e90df-2" id="id158">[2]</a>)</p>
</dd>
<dt><strong>max_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rk</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated RK.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>RK is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[K_{\bot} = G_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2222} +
           G_1(\lambda_1,\lambda_3,\lambda_2)\hat{W}_{3333} +
           G_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[G_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{18\lambda_2(\lambda_2-
\lambda_3)} \left (2\lambda_2 +
\frac{\lambda_3^2-3\lambda_2\lambda_3}{\sqrt{\lambda_2\lambda_3}}
\right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[G_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{(\lambda_2-\lambda_3)^2}
\left ( \frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}-2
\right )\]</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1ebb108e90df-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id148">1</a>, <a class="fn-backref" href="#id157">2</a>, <a class="fn-backref" href="#id159">3</a>)</em> Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1ebb108e90df-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id158">1</a>, <a class="fn-backref" href="#id160">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffusionkurtosismodel">
<h3><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="dipy.reconst.dki.DiffusionKurtosisModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a><a class="headerlink" href="#diffusionkurtosismodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dki.DiffusionKurtosisModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.dki.</code><code class="descname">DiffusionKurtosisModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>Class for the Diffusion Kurtosis Model</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel.fit" title="dipy.reconst.dki.DiffusionKurtosisModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method of the DKI model class</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel.predict" title="dipy.reconst.dki.DiffusionKurtosisModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(dki_params[,&nbsp;S0])</td>
<td>Predict a signal for this DKI model class instance given parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Diffusion Kurtosis Tensor Model [1]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>fit_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or callable</span></dt>
<dd><p class="first">str can be one of the following:
OLS or ULLS for ordinary least squares</p>
<blockquote>
<div><p>dki.ols_fit_dki</p>
</div></blockquote>
<dl class="last docutils">
<dt>WLS or UWLLS for weighted ordinary least squares</dt>
<dd><p class="first last">dki.wls_fit_dki</p>
</dd>
<dt>callable has to have the signature:</dt>
<dd><p class="first last">fit_method(design_matrix, data, <a href="#id161"><span class="problematic" id="id162">*</span></a>args, <a href="#id163"><span class="problematic" id="id164">**</span></a>kwargs)</p>
</dd>
</dl>
</dd>
<dt><strong>args, kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">arguments and key-word arguments passed to the</span></dt>
<dd><p class="first last">fit_method. See dki.ols_fit_dki, dki.wls_fit_dki for details</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r0d8411329c32-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id165">[1]</a></td><td>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.</td></tr>
</tbody>
</table>
<p>Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method of the DKI model class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The measured signal from one voxel.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[-1]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.DiffusionKurtosisModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>dki_params</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.DiffusionKurtosisModel.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict a signal for this DKI model class instance given
parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray (optional)</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id166">
<h3><a class="reference internal" href="#dipy.reconst.dki.ReconstModel" title="dipy.reconst.dki.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#id166" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dki.ReconstModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.dki.</code><code class="descname">ReconstModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.ReconstModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dki.ReconstModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.ReconstModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.ReconstModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.ReconstModel.fit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="tensorfit">
<h3><a class="reference internal" href="#dipy.reconst.dki.TensorFit" title="dipy.reconst.dki.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a><a class="headerlink" href="#tensorfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dki.TensorFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.dki.</code><code class="descname">TensorFit</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em>, <em>model_S0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S0_hat</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.dki.TensorFit.directions" title="dipy.reconst.dki.TensorFit.directions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></a></dt>
<dd><p class="first last">For tracking - return the primary direction in each voxel</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki.TensorFit.evals" title="dipy.reconst.dki.TensorFit.evals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></a></dt>
<dd><p class="first last">Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki.TensorFit.evecs" title="dipy.reconst.dki.TensorFit.evecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></a></dt>
<dd><p class="first last">Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki.TensorFit.quadratic_form" title="dipy.reconst.dki.TensorFit.quadratic_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></a></dt>
<dd><p class="first last">Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.ad" title="dipy.reconst.dki.TensorFit.ad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code></a>()</td>
<td>Axial diffusivity (AD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.adc" title="dipy.reconst.dki.TensorFit.adc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code></a>(sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction on</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.color_fa" title="dipy.reconst.dki.TensorFit.color_fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code></a>()</td>
<td>Color fractional anisotropy of diffusion tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.fa" title="dipy.reconst.dki.TensorFit.fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code></a>()</td>
<td>Fractional anisotropy (FA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.ga" title="dipy.reconst.dki.TensorFit.ga"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code></a>()</td>
<td>Geodesic anisotropy (GA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.linearity" title="dipy.reconst.dki.TensorFit.linearity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.md" title="dipy.reconst.dki.TensorFit.md"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code></a>()</td>
<td>Mean diffusivity (MD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.mode" title="dipy.reconst.dki.TensorFit.mode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code></a>()</td>
<td>Tensor mode calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.odf" title="dipy.reconst.dki.TensorFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>The diffusion orientation distribution function (dODF).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.planarity" title="dipy.reconst.dki.TensorFit.planarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.predict" title="dipy.reconst.dki.TensorFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab[,&nbsp;S0,&nbsp;step])</td>
<td>Given a model fit, predict the signal on the vertices of a sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.rd" title="dipy.reconst.dki.TensorFit.rd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code></a>()</td>
<td>Radial diffusivity (RD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.sphericity" title="dipy.reconst.dki.TensorFit.sphericity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.TensorFit.trace" title="dipy.reconst.dki.TensorFit.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>()</td>
<td>Trace of the tensor calculated from cached eigenvalues.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>lower_triangular</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em>, <em>model_S0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a TensorFit class instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.TensorFit.S0_hat">
<code class="descname">S0_hat</code><a class="headerlink" href="#dipy.reconst.dki.TensorFit.S0_hat" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.ad">
<code class="descname">ad</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.ad" title="Permalink to this definition"></a></dt>
<dd><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated AD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>RD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[AD = \lambda_1\]</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.adc">
<code class="descname">adc</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.adc" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Calculate the apparent diffusion coefficient (ADC) in each direction on
the sphere for each voxel in the data</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The estimates of the apparent diffusion coefficient in every
direction on the input sphere</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>ec{b} Q 
ec{b}^T</p>
<blockquote>
<div>Where Q is the quadratic form of the tensor.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.color_fa">
<code class="descname">color_fa</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.color_fa" title="Permalink to this definition"></a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.TensorFit.directions">
<code class="descname">directions</code><a class="headerlink" href="#dipy.reconst.dki.TensorFit.directions" title="Permalink to this definition"></a></dt>
<dd><p>For tracking - return the primary direction in each voxel</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.TensorFit.evals">
<code class="descname">evals</code><a class="headerlink" href="#dipy.reconst.dki.TensorFit.evals" title="Permalink to this definition"></a></dt>
<dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.TensorFit.evecs">
<code class="descname">evecs</code><a class="headerlink" href="#dipy.reconst.dki.TensorFit.evecs" title="Permalink to this definition"></a></dt>
<dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.fa">
<code class="descname">fa</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.fa" title="Permalink to this definition"></a></dt>
<dd><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.ga">
<code class="descname">ga</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.ga" title="Permalink to this definition"></a></dt>
<dd><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.linearity">
<code class="descname">linearity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.linearity" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>linearity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated linearity of the diffusion tensor <a class="footnote-reference" href="#id344" id="id167">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1-lambda_2}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.lower_triangular">
<code class="descname">lower_triangular</code><span class="sig-paren">(</span><em>b0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.lower_triangular" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.md">
<code class="descname">md</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.md" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Mean diffusivity (MD) calculated from cached eigenvalues.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated MD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1+lambda_2+lambda_3}{3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.mode">
<code class="descname">mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.mode" title="Permalink to this definition"></a></dt>
<dd><p>Tensor mode calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>The diffusion orientation distribution function (dODF). This is an
estimate of the diffusion distance in each direction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance.</span></dt>
<dd><p class="first last">The dODF is calculated in the vertices of this input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The diffusion distance in every direction of the sphere in every
voxel in the input data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is based on equation 3 in <a class="reference internal" href="#rdedbfce4601d-aganj2010" id="id168">[Aganj2010]</a>. To re-derive it from
scratch, follow steps in <a class="reference internal" href="#rdedbfce4601d-descoteaux2008" id="id169">[Descoteaux2008]</a>, Section 7.9 Equation
7.24 but with an <span class="math notranslate nohighlight">\(r^2\)</span> term in the integral.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rdedbfce4601d-aganj2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Aganj2010]</td><td><em>(<a class="fn-backref" href="#id168">1</a>, <a class="fn-backref" href="#id170">2</a>)</em> Aganj, I., Lenglet, C., Sapiro, G., Yacoub, E., Ugurbil,
K., &amp; Harel, N. (2010). Reconstruction of the orientation
distribution function in single- and multiple-shell q-ball imaging
within constant solid angle. Magnetic Resonance in Medicine, 64(2),
554-566. doi:DOI: 10.1002/mrm.22365</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rdedbfce4601d-descoteaux2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Descoteaux2008]</td><td><em>(<a class="fn-backref" href="#id169">1</a>, <a class="fn-backref" href="#id171">2</a>)</em> Descoteaux, M. (2008). PhD Thesis: High Angular
Resolution Diffusion MRI: from Local Estimation to Segmentation and
Tractography. <a class="reference external" href="ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf">ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.planarity">
<code class="descname">planarity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.planarity" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphericity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated sphericity of the diffusion tensor <a class="footnote-reference" href="#id344" id="id172">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{2 (lambda_2 - lambda_3)}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab</em>, <em>S0=None</em>, <em>step=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Given a model fit, predict the signal on the vertices of a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">This encodes the directions for which a prediction is made</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">The mean non-diffusion weighted signal in each voxel. Default:
The fitted S0 value in all voxels if it was fitted. Otherwise 1 in
all voxels.</p>
</dd>
<dt><strong>step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">The chunk size as a number of voxels. Optional parameter with
default value 10,000.</p>
<p class="last">In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. This parameter sets the number of
voxels that will be fit at once in each iteration. A larger step
value should speed things up, but it will also take up more memory.
It is advisable to keep an eye on memory consumption as this value
is increased.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S(  heta, b) = S_0 * e^{-b ADC}\]</div>
<p>Where:
.. math</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ADC</span> <span class="o">=</span>       <span class="n">heta</span> <span class="n">Q</span>  <span class="n">heta</span><span class="o">^</span><span class="n">T</span>
</pre></div>
</div>
<p>:math:`       heta` is a unit vector pointing at any direction on the sphere for
which a signal is to be predicted and <span class="math notranslate nohighlight">\(b\)</span> is the b value provided in
the GradientTable input for that direction</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.TensorFit.quadratic_form">
<code class="descname">quadratic_form</code><a class="headerlink" href="#dipy.reconst.dki.TensorFit.quadratic_form" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.rd">
<code class="descname">rd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.rd" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Radial diffusivity (RD) calculated from cached eigenvalues.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rd</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated RD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_2 + lambda_3}{2}</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.TensorFit.shape">
<code class="descname">shape</code><a class="headerlink" href="#dipy.reconst.dki.TensorFit.shape" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.sphericity">
<code class="descname">sphericity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.sphericity" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphericity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated sphericity of the diffusion tensor <a class="footnote-reference" href="#id344" id="id173">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{3 lambda_3}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.TensorFit.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.TensorFit.trace" title="Permalink to this definition"></a></dt>
<dd><p>Trace of the tensor calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated trace.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The trace is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[trace = \lambda_1 + \lambda_2 + \lambda_3\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id174">
<h3><a class="reference internal" href="#dipy.reconst.dki.range" title="dipy.reconst.dki.range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a><a class="headerlink" href="#id174" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dki.range">
<em class="property">class </em><code class="descclassname">dipy.reconst.dki.</code><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span> &#x2192; range object<a class="headerlink" href="#dipy.reconst.dki.range" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>range(start, stop[, step]) -&gt; range object</p>
<p>Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, , j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>start</strong></dt>
<dd></dd>
<dt><strong>step</strong></dt>
<dd></dd>
<dt><strong>stop</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki.range.count" title="dipy.reconst.dki.range.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(value)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki.range.index" title="dipy.reconst.dki.range.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(value,&nbsp;[start,&nbsp;[stop]])</td>
<td>Raise ValueError if the value is not present.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dki.range.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.range.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.range.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span> &#x2192; integer -- return number of occurrences of value<a class="headerlink" href="#dipy.reconst.dki.range.count" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki.range.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>stop</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; integer -- return index of value.<a class="headerlink" href="#dipy.reconst.dki.range.index" title="Permalink to this definition"></a></dt>
<dd><p>Raise ValueError if the value is not present.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.range.start">
<code class="descname">start</code><a class="headerlink" href="#dipy.reconst.dki.range.start" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.range.step">
<code class="descname">step</code><a class="headerlink" href="#dipy.reconst.dki.range.step" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki.range.stop">
<code class="descname">stop</code><a class="headerlink" href="#dipy.reconst.dki.range.stop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="wcons">
<h3>Wcons<a class="headerlink" href="#wcons" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.Wcons">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">Wcons</code><span class="sig-paren">(</span><em>k_elements</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.Wcons" title="Permalink to this definition"></a></dt>
<dd><p>Construct the full 4D kurtosis tensors from its 15 independent
elements</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>k_elements</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(15,)</span></dt>
<dd><p class="first last">elements of the kurtosis tensor in the following order:</p>
</dd>
<dt><strong>.. math::</strong></dt>
<dd></dd>
<dt><strong>begin{matrix} ( &amp; W_{xxxx} &amp; W_{yyyy} &amp; W_{zzzz} &amp; W_{xxxy} &amp; W_{xxxz}</strong></dt>
<dd><p class="first last">&amp;  \
&amp; W_{xyyy} &amp; W_{yyyz} &amp; W_{xzzz} &amp; W_{yzzz} &amp; W_{xxyy}
&amp;  \
&amp; W_{xxzz} &amp; W_{yyzz} &amp; W_{xxyz} &amp; W_{xyyz} &amp; W_{xyzz}
&amp; &amp; )end{matrix}</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array(3, 3, 3, 3)</span></dt>
<dd><p class="first last">Full 4D kurtosis tensor</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="wrotate">
<h3>Wrotate<a class="headerlink" href="#wrotate" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.Wrotate">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">Wrotate</code><span class="sig-paren">(</span><em>kt</em>, <em>Basis</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.Wrotate" title="Permalink to this definition"></a></dt>
<dd><p>Rotate a kurtosis tensor from the standard Cartesian coordinate system
to another coordinate system basis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>kt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(15,)</span></dt>
<dd><p class="first last">Vector with the 15 independent elements of the kurtosis tensor</p>
</dd>
<dt><strong>Basis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (3, 3)</span></dt>
<dd><p class="first last">Vectors of the basis column-wise oriented</p>
</dd>
<dt><strong>inds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array(m, 4) (optional)</span></dt>
<dd><p class="first last">Array of vectors containing the four indexes of m specific elements of
the rotated kurtosis tensor. If not specified all 15 elements of the
rotated kurtosis tensor are computed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Wrot</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (m,) or (15,)</span></dt>
<dd><p class="first last">Vector with the m independent elements of the rotated kurtosis tensor.
If indices is not specified all 15 elements of the rotated kurtosis
tensor are computed.</p>
</dd>
<dt><strong>Note</strong></dt>
<dd></dd>
<dt><strong></strong></dt>
<dd></dd>
<dt><strong>KT elements are assumed to be ordered as follows:</strong></dt>
<dd></dd>
<dt><strong>.. math::</strong></dt>
<dd></dd>
<dt><strong>begin{matrix} ( &amp; W_{xxxx} &amp; W_{yyyy} &amp; W_{zzzz} &amp; W_{xxxy} &amp; W_{xxxz}</strong></dt>
<dd><p class="first last">&amp;  \
&amp; W_{xyyy} &amp; W_{yyyz} &amp; W_{xzzz} &amp; W_{yzzz} &amp; W_{xxyy}
&amp;  \
&amp; W_{xxzz} &amp; W_{yyzz} &amp; W_{xxyz} &amp; W_{xyyz} &amp; W_{xyzz}
&amp; &amp; )end{matrix}</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>[1] Hui ES, Cheung MM, Qi L, Wu EX, 2008. Towards better MR
characterization of neural tissues using directional diffusion kurtosis
analysis. Neuroimage 42(1): 122-34</p>
</dd></dl>

</div>
<div class="section" id="wrotate-element">
<h3>Wrotate_element<a class="headerlink" href="#wrotate-element" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.Wrotate_element">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">Wrotate_element</code><span class="sig-paren">(</span><em>kt</em>, <em>indi</em>, <em>indj</em>, <em>indk</em>, <em>indl</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.Wrotate_element" title="Permalink to this definition"></a></dt>
<dd><p>Computes the the specified index element of a kurtosis tensor rotated
to the coordinate system basis B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>kt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 15) or (n, 15)</span></dt>
<dd><p class="first last">Array containing the 15 independent elements of the kurtosis tensor</p>
</dd>
<dt><strong>indi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Rotated kurtosis tensor element index i (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt><strong>indj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Rotated kurtosis tensor element index j (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt><strong>indk</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Rotated kurtosis tensor element index k (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt><strong>indl: int</strong></dt>
<dd><p class="first last">Rotated kurtosis tensor element index l (0 for x, 1 for y, 2 for z)</p>
</dd>
<dt><strong>B: array (x, y, z, 3, 3) or (n, 15)</strong></dt>
<dd><p class="first last">Vectors of the basis column-wise oriented</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Wre</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">rotated kurtosis tensor element of index ind_i, ind_j, ind_k, ind_l</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>[1] Hui ES, Cheung MM, Qi L, Wu EX, 2008. Towards better MR
characterization of neural tissues using directional diffusion kurtosis
analysis. Neuroimage 42(1): 122-34</p>
</dd></dl>

</div>
<div class="section" id="apparent-kurtosis-coef">
<h3>apparent_kurtosis_coef<a class="headerlink" href="#apparent-kurtosis-coef" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.apparent_kurtosis_coef">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">apparent_kurtosis_coef</code><span class="sig-paren">(</span><em>dki_params</em>, <em>sphere</em>, <em>min_diffusivity=0</em>, <em>min_kurtosis=-0.42857142857142855</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.apparent_kurtosis_coef" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the apparent kurtosis coefficient (AKC) in each direction
of a sphere <a class="reference internal" href="#r1b3e9922dec3-1" id="id175">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvectors respectively</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a Sphere class instance</span></dt>
<dd><p class="first last">The AKC will be calculated for each of the vertices in the sphere</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>. Default = 0</p>
</dd>
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">Because high-amplitude negative values of kurtosis are not physicaly
and biologicaly pluasible, and these cause artefacts in
kurtosis-based measures, directional kurtosis values smaller than
<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7
(theoretical kurtosis limit for regions that consist of water confined
to spherical pores <a class="reference internal" href="#r1b3e9922dec3-2" id="id176">[2]</a>)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>akc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, g) or (n, g)</span></dt>
<dd><p class="first last">Apparent kurtosis coefficient (AKC) for all g directions of a sphere.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For each sphere direction with coordinates <span class="math notranslate nohighlight">\((n_{1}, n_{2}, n_{3})\)</span>, the
calculation of AKC is done using formula <a class="reference internal" href="#r1b3e9922dec3-1" id="id177">[1]</a>:</p>
<div class="math notranslate nohighlight">
\[AKC(n)=\frac{MD^{2}}{ADC(n)^{2}}\sum_{i=1}^{3}\sum_{j=1}^{3}
\sum_{k=1}^{3}\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\]</div>
<p>where <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the kurtosis tensor, MD the mean
diffusivity and ADC the apparent diffusion coefficent computed as:</p>
<div class="math notranslate nohighlight">
\[ADC(n)=\sum_{i=1}^{3}\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\]</div>
<p>where <span class="math notranslate nohighlight">\(D_{ij}\)</span> are the elements of the diffusion tensor.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1b3e9922dec3-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id175">2</a>, <a class="fn-backref" href="#id177">3</a>, <a class="fn-backref" href="#id178">4</a>)</em> Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
Exploring the 3D geometry of the diffusion kurtosis tensor -
Impact on the development of robust tractography procedures and
novel biomarkers, NeuroImage 111: 85-99</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1b3e9922dec3-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id176">1</a>, <a class="fn-backref" href="#id179">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="axial-kurtosis">
<h3>axial_kurtosis<a class="headerlink" href="#axial-kurtosis" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.axial_kurtosis">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">axial_kurtosis</code><span class="sig-paren">(</span><em>dki_params</em>, <em>min_kurtosis=-0.42857142857142855</em>, <em>max_kurtosis=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.axial_kurtosis" title="Permalink to this definition"></a></dt>
<dd><p>Computes axial Kurtosis (AK) from the kurtosis tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores <a class="reference internal" href="#rf80d380179f9-1" id="id180">[1]</a>)</p>
</dd>
<dt><strong>max_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ak</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated AK.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rf80d380179f9-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id180">1</a>, <a class="fn-backref" href="#id181">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="carlson-rd">
<h3>carlson_rd<a class="headerlink" href="#carlson-rd" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.carlson_rd">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">carlson_rd</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>errtol=0.0001</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.carlson_rd" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Carlsons incomplete elliptic integral of the second kind
defined as:</p>
<div class="math notranslate nohighlight">
\[R_D = \frac{3}{2} \int_{0}^{\infty} (t+x)^{-\frac{1}{2}}
(t+y)^{-\frac{1}{2}}(t+z)  ^{-\frac{3}{2}}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">First independent variable of the integral.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Second independent variable of the integral.</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Third independent variable of the integral.</p>
</dd>
<dt><strong>errtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Error tolerance. Integral is computed with relative error less in
magnitude than the defined value</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>RD</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Value of the incomplete second order elliptic integral</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="carlson-rf">
<h3>carlson_rf<a class="headerlink" href="#carlson-rf" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.carlson_rf">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">carlson_rf</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>errtol=0.0003</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.carlson_rf" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Carlsons incomplete elliptic integral of the first kind
defined as:</p>
<div class="math notranslate nohighlight">
\[R_F = \frac{1}{2} \int_{0}^{\infty} \left [(t+x)(t+y)(t+z)  \right ]
^{-\frac{1}{2}}dt\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">First independent variable of the integral.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Second independent variable of the integral.</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Third independent variable of the integral.</p>
</dd>
<dt><strong>errtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Error tolerance. Integral is computed with relative error less in
magnitude than the defined value</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>RF</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Value of the incomplete first order elliptic integral</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1621ed3829b0-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id182">[1]</a></td><td>Carlson, B.C., 1994. Numerical computation of real or complex
elliptic integrals. arXiv:math/9409227 [math.CA]</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id183">
<h3>cart2sphere<a class="headerlink" href="#id183" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.cart2sphere">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">cart2sphere</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.cart2sphere" title="Permalink to this definition"></a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions and derivation
of the formulae.</p>
<p><span class="math notranslate nohighlight">\(0\le\theta\mathrm{(theta)}\le\pi\)</span> and <span class="math notranslate nohighlight">\(-\pi\le\phi\mathrm{(phi)}\le\pi\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">x coordinate in Cartesian space</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">z coordinate</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">radius</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">inclination (polar) angle</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">azimuth angle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="check-multi-b">
<h3>check_multi_b<a class="headerlink" href="#check-multi-b" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.check_multi_b">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">check_multi_b</code><span class="sig-paren">(</span><em>gtab</em>, <em>n_bvals</em>, <em>non_zero=True</em>, <em>bmag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.check_multi_b" title="Permalink to this definition"></a></dt>
<dd><p>Check if you have enough different b-values in your gradient table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance.</span></dt>
<dd></dd>
<dt><strong>n_bvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of different b-values you are checking for.</p>
</dd>
<dt><strong>non_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to check only non-zero bvalues. In this case, we will require
at least <cite>n_bvals</cite> <em>non-zero</em> b-values (where non-zero is defined
depending on the <cite>gtab</cite> objects <cite>b0_threshold</cite> attribute)</p>
</dd>
<dt><strong>bmag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The order of magnitude of the b-values used. The function will
normalize the b-values relative <span class="math notranslate nohighlight">\(10^{bmag - 1}\)</span>. Default: derive this
value from the maximal b-value provided: <span class="math notranslate nohighlight">\(bmag=log_{10}(max(bvals))\)</span>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bool</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Whether there are at least <cite>n_bvals</cite> different b-values in the</span></dt>
<dd></dd>
<dt><strong>gradient table used.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="decompose-tensor">
<h3>decompose_tensor<a class="headerlink" href="#decompose-tensor" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.decompose_tensor">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">decompose_tensor</code><span class="sig-paren">(</span><em>tensor</em>, <em>min_diffusivity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.decompose_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>
<p>Computes tensor eigen decomposition to calculate eigenvalues and
eigenvectors (Basser et al., 1994a).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Hermitian matrix representing a diffusion tensor.</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3)</span></dt>
<dd><p class="first last">Eigenvalues from eigen decomposition of the tensor. Negative
eigenvalues are replaced by zero. Sorted from largest to smallest.</p>
</dd>
<dt><strong>eigvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[, :, j] is associated with
eigvals[, j])</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="design-matrix">
<h3>design_matrix<a class="headerlink" href="#design-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.design_matrix">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">design_matrix</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.design_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Constructs B design matrix for DKI</p>
<dl class="docutils">
<dt>gtab <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd>Measurement directions.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, 22)</span></dt>
<dd><p class="first">Design matrix or B matrix for the DKI model
B[j, :] = (Bxx, Bxy, Bzz, Bxz, Byz, Bzz,</p>
<blockquote class="last">
<div><p>Bxxxx, Byyyy, Bzzzz, Bxxxy, Bxxxz,
Bxyyy, Byyyz, Bxzzz, Byzzz, Bxxyy,
Bxxzz, Byyzz, Bxxyz, Bxyyz, Bxyzz,
BlogS0)</p>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="directional-diffusion">
<h3>directional_diffusion<a class="headerlink" href="#directional-diffusion" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.directional_diffusion">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">directional_diffusion</code><span class="sig-paren">(</span><em>dt</em>, <em>V</em>, <em>min_diffusivity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.directional_diffusion" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the apparent diffusion coefficient (adc) in each direction
of a sphere for a single voxel <a class="reference internal" href="#r62a8a421f533-1" id="id184">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (6,)</span></dt>
<dd><p class="first last">elements of the diffusion tensor of the voxel.</p>
</dd>
<dt><strong>V</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 3)</span></dt>
<dd><p class="first last">g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>. Default = 0</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (g,)</span></dt>
<dd><p class="first last">Apparent diffusion coefficient (adc) in all g directions of a sphere
for a single voxel.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r62a8a421f533-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id184">2</a>, <a class="fn-backref" href="#id185">3</a>)</em> Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
Exploring the 3D geometry of the diffusion kurtosis tensor -
Impact on the development of robust tractography procedures and
novel biomarkers, NeuroImage 111: 85-99</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="directional-diffusion-variance">
<h3>directional_diffusion_variance<a class="headerlink" href="#directional-diffusion-variance" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.directional_diffusion_variance">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">directional_diffusion_variance</code><span class="sig-paren">(</span><em>kt</em>, <em>V</em>, <em>min_kurtosis=-0.42857142857142855</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.directional_diffusion_variance" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the apparent diffusion variance (adv) in each direction
of a sphere for a single voxel <a class="reference internal" href="#r87e53edeef9c-1" id="id186">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (6,)</span></dt>
<dd><p class="first last">elements of the diffusion tensor of the voxel.</p>
</dd>
<dt><strong>kt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (15,)</span></dt>
<dd><p class="first last">elements of the kurtosis tensor of the voxel.</p>
</dd>
<dt><strong>V</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 3)</span></dt>
<dd><p class="first last">g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">Because high-amplitude negative values of kurtosis are not physicaly
and biologicaly pluasible, and these cause artefacts in
kurtosis-based measures, directional kurtosis values smaller than
<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7
(theoretical kurtosis limit for regions that consist of water confined
to spherical pores <a href="#id779"><span class="problematic" id="id187">[2]_</span></a>)</p>
</dd>
<dt><strong>adc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray(g,) (optional)</span></dt>
<dd><p class="first last">Apparent diffusion coefficient (adc) in all g directions of a sphere
for a single voxel.</p>
</dd>
<dt><strong>adv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray(g,) (optional)</span></dt>
<dd><p class="first last">Apparent diffusion variance coefficient (advc) in all g directions of
a sphere for a single voxel.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (g,)</span></dt>
<dd><p class="first last">Apparent diffusion variance (adv) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r87e53edeef9c-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id186">2</a>, <a class="fn-backref" href="#id188">3</a>)</em> Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
Exploring the 3D geometry of the diffusion kurtosis tensor -
Impact on the development of robust tractography procedures and
novel biomarkers, NeuroImage 111: 85-99</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="directional-kurtosis">
<h3>directional_kurtosis<a class="headerlink" href="#directional-kurtosis" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.directional_kurtosis">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">directional_kurtosis</code><span class="sig-paren">(</span><em>dt</em>, <em>md</em>, <em>kt</em>, <em>V</em>, <em>min_diffusivity=0</em>, <em>min_kurtosis=-0.42857142857142855</em>, <em>adc=None</em>, <em>adv=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.directional_kurtosis" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the apparent kurtosis coefficient (akc) in each direction
of a sphere for a single voxel <a class="reference internal" href="#ra6181896282f-1" id="id189">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (6,)</span></dt>
<dd><p class="first last">elements of the diffusion tensor of the voxel.</p>
</dd>
<dt><strong>md</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">mean diffusivity of the voxel</p>
</dd>
<dt><strong>kt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (15,)</span></dt>
<dd><p class="first last">elements of the kurtosis tensor of the voxel.</p>
</dd>
<dt><strong>V</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 3)</span></dt>
<dd><p class="first last">g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>. Default = 0</p>
</dd>
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">Because high-amplitude negative values of kurtosis are not physicaly
and biologicaly pluasible, and these cause artefacts in
kurtosis-based measures, directional kurtosis values smaller than
<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7
(theoretical kurtosis limit for regions that consist of water confined
to spherical pores <a class="reference internal" href="#ra6181896282f-2" id="id190">[2]</a>)</p>
</dd>
<dt><strong>adc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray(g,) (optional)</span></dt>
<dd><p class="first last">Apparent diffusion coefficient (adc) in all g directions of a sphere
for a single voxel.</p>
</dd>
<dt><strong>adv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray(g,) (optional)</span></dt>
<dd><p class="first last">Apparent diffusion variance (advc) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>akc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (g,)</span></dt>
<dd><p class="first last">Apparent kurtosis coefficient (AKC) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="ra6181896282f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id189">2</a>, <a class="fn-backref" href="#id191">3</a>)</em> Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
Exploring the 3D geometry of the diffusion kurtosis tensor -
Impact on the development of robust tractography procedures and
novel biomarkers, NeuroImage 111: 85-99</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ra6181896282f-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id190">1</a>, <a class="fn-backref" href="#id192">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="dki-prediction">
<h3>dki_prediction<a class="headerlink" href="#dki-prediction" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.dki_prediction">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">dki_prediction</code><span class="sig-paren">(</span><em>dki_params</em>, <em>gtab</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.dki_prediction" title="Permalink to this definition"></a></dt>
<dd><p>Predict a signal given diffusion kurtosis imaging parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><blockquote class="first">
<div><p>All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>gtab <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The gradient table for this prediction</p>
</dd>
<dt>S0 <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray (optional)</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 150</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, N) ndarray</span></dt>
<dd><blockquote class="first">
<div><p>Simulated signal based on the DKI model:</p>
</div></blockquote>
<div class="last math notranslate nohighlight">
\[S=S_{0}e^{-bD+\]</div>
</dd>
<dt><strong>rac{1}{6}b^{2}D^{2}K}</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="from-lower-triangular">
<h3>from_lower_triangular<a class="headerlink" href="#from-lower-triangular" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.from_lower_triangular">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">from_lower_triangular</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.from_lower_triangular" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tensor given the six unique tensor elements</p>
<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,
Dyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are
ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, (, &gt;6)</span></dt>
<dd><p class="first last">Unique elements of the tensors</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (, 3, 3)</span></dt>
<dd><p class="first last">3 by 3 tensors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id193">
<h3>get_sphere<a class="headerlink" href="#id193" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.get_sphere">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">get_sphere</code><span class="sig-paren">(</span><em>name='symmetric362'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.get_sphere" title="Permalink to this definition"></a></dt>
<dd><p>provide triangulated spheres</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">which sphere - one of:
* symmetric362
* symmetric642
* symmetric724
* repulsion724
* repulsion100
* repulsion200</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a dipy.core.sphere.Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;symmetric362&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">sphere</span><span class="o">.</span><span class="n">faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">362</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">720</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;not a sphere name&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">DataError</span>: <span class="n">No sphere called &quot;not a sphere name&quot;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="kurtosis-maximum">
<h3>kurtosis_maximum<a class="headerlink" href="#kurtosis-maximum" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.kurtosis_maximum">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">kurtosis_maximum</code><span class="sig-paren">(</span><em>dki_params</em>, <em>sphere='repulsion100'</em>, <em>gtol=0.01</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.kurtosis_maximum" title="Permalink to this definition"></a></dt>
<dd><p>Computes kurtosis maximum value</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eingenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance, optional</span></dt>
<dd><p class="first last">The sphere providing sample directions for the initial search of the
maximal value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">This input is to refine kurtosis maximum under the precision of the
directions sampled on the sphere class instance. The gradient of the
convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken from
the initial sampled directions of the given sphere object</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>max_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">kurtosis tensor maximum value</p>
</dd>
<dt><strong>max_dir</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (3,)</span></dt>
<dd><p class="first last">Cartesian coordinates of the direction of the maximal kurtosis value</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id194">
<h3>local_maxima<a class="headerlink" href="#id194" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.local_maxima">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">local_maxima</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.local_maxima" title="Permalink to this definition"></a></dt>
<dd><p>Local maxima of a function evaluated on a discrete set of points.</p>
<p>If a function is evaluated on some set of points where each pair of
neighboring points is an edge in edges, find the local maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, 1d, dtype=double</span></dt>
<dd><p class="first last">The function evaluated on a set of discrete points.</p>
</dd>
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, 2)</span></dt>
<dd><p class="first last">The set of neighbor relations between the points. Every edge, ie
<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>peak_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Value of odf at a maximum point. Peak values is sorted in descending
order.</p>
</dd>
<dt><strong>peak_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so
<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="dipy.core.html#module-dipy.core.sphere" title="dipy.core.sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dipy.core.sphere</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="lower-triangular">
<h3>lower_triangular<a class="headerlink" href="#lower-triangular" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.lower_triangular">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">lower_triangular</code><span class="sig-paren">(</span><em>tensor</em>, <em>b0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.lower_triangular" title="Permalink to this definition"></a></dt>
<dd><p>Returns the six lower triangular values of the tensor and a dummy variable
if b0 is not None</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, 3, 3)</span></dt>
<dd><p class="first last">a collection of 3, 3 diffusion tensors</p>
</dd>
<dt><strong>b0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">if b0 is not none log(b0) is returned as the dummy variable</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">If b0 is none, then the shape will be (, 6) otherwise (, 7)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mean-diffusivity">
<h3>mean_diffusivity<a class="headerlink" href="#mean-diffusivity" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.mean_diffusivity">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">mean_diffusivity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.mean_diffusivity" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Mean Diffusivity (MD) of a diffusion tensor.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated MD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1 + lambda_2 + lambda_3}{3}</p>
</dd></dl>

</div>
<div class="section" id="mean-kurtosis">
<h3>mean_kurtosis<a class="headerlink" href="#mean-kurtosis" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.mean_kurtosis">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">mean_kurtosis</code><span class="sig-paren">(</span><em>dki_params</em>, <em>min_kurtosis=-0.42857142857142855</em>, <em>max_kurtosis=3</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.mean_kurtosis" title="Permalink to this definition"></a></dt>
<dd><p>Computes mean Kurtosis (MK) from the kurtosis tensor <a class="reference internal" href="#r953e26c55b6a-1" id="id195">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores <a class="reference internal" href="#r953e26c55b6a-2" id="id196">[2]</a>)</p>
</dd>
<dt><strong>max_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mk</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated MK.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The MK analytical solution is calculated using the following equation <a class="reference internal" href="#r953e26c55b6a-1" id="id197">[1]</a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}MK=F_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{1111}+
   F_1(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{2222}+
   F_1(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{3333}+ \\
   F_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}+
   F_2(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{1133}+
   F_2(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{1122}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{W}_{ijkl}\)</span> are the components of the <span class="math notranslate nohighlight">\(W\)</span> tensor in the
coordinates system defined by the eigenvectors of the diffusion tensor
<span class="math notranslate nohighlight">\(\mathbf{D}\)</span> and</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}F_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{18(\lambda_1-\lambda_2)(\lambda_1-\lambda_3)}
[\frac{\sqrt{\lambda_2\lambda_3}}{\lambda_1}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{3\lambda_1^2-\lambda_1\lambda_2-\lambda_2\lambda_3-
\lambda_1\lambda_3}
{3\lambda_1 \sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-1 ]\end{split}\\\begin{split}F_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{3(\lambda_2-\lambda_3)^2}
[\frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{2\lambda_1-\lambda_2-\lambda_3}{3\sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-2]\end{split}\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(R_f\)</span> and <span class="math notranslate nohighlight">\(R_d\)</span> are the Carlsons elliptic integrals.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r953e26c55b6a-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id195">2</a>, <a class="fn-backref" href="#id197">3</a>, <a class="fn-backref" href="#id198">4</a>)</em> Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r953e26c55b6a-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id196">1</a>, <a class="fn-backref" href="#id199">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on Biomedical
Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id200">
<h3>ndindex<a class="headerlink" href="#id200" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.ndindex">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">ndindex</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.ndindex" title="Permalink to this definition"></a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd><p class="first last">The dimensions of the array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="k">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ols-fit-dki">
<h3>ols_fit_dki<a class="headerlink" href="#ols-fit-dki" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.ols_fit_dki">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">ols_fit_dki</code><span class="sig-paren">(</span><em>design_matrix</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.ols_fit_dki" title="Permalink to this definition"></a></dt>
<dd><p>Computes ordinary least squares (OLS) fit to calculate the diffusion
tensor and kurtosis tensor using a linear regression diffusion kurtosis
model <a class="footnote-reference" href="#id344" id="id201">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 22)</span></dt>
<dd><p class="first last">Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, g)</span></dt>
<dd><p class="first last">Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.dki.wls_fit_dki" title="dipy.reconst.dki.wls_fit_dki"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wls_fit_dki</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="radial-kurtosis">
<h3>radial_kurtosis<a class="headerlink" href="#radial-kurtosis" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.radial_kurtosis">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">radial_kurtosis</code><span class="sig-paren">(</span><em>dki_params</em>, <em>min_kurtosis=-0.42857142857142855</em>, <em>max_kurtosis=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.radial_kurtosis" title="Permalink to this definition"></a></dt>
<dd><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class="reference internal" href="#r7cf9df14e56e-1" id="id203">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, radial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with
<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions
that consist of water confined to spherical pores <a class="reference internal" href="#r7cf9df14e56e-2" id="id204">[2]</a>)</p>
</dd>
<dt><strong>max_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, radial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with
<cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rk</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated RK.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>RK is calculated with the following equation  <a class="reference internal" href="#r7cf9df14e56e-1" id="id205">[1]</a>:</p>
<div class="math notranslate nohighlight">
\[K_{\bot} = G_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2222} +
           G_1(\lambda_1,\lambda_3,\lambda_2)\hat{W}_{3333} +
           G_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[G_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{18\lambda_2(\lambda_2-
\lambda_3)} \left (2\lambda_2 +
\frac{\lambda_3^2-3\lambda_2\lambda_3}{\sqrt{\lambda_2\lambda_3}}
\right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[G_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{(\lambda_2-\lambda_3)^2}
\left ( \frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}-2\right )\]</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r7cf9df14e56e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id203">2</a>, <a class="fn-backref" href="#id205">3</a>, <a class="fn-backref" href="#id206">4</a>)</em> Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r7cf9df14e56e-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id204">1</a>, <a class="fn-backref" href="#id207">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on Biomedical
Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sphere2cart">
<h3>sphere2cart<a class="headerlink" href="#sphere2cart" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.sphere2cart">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">sphere2cart</code><span class="sig-paren">(</span><em>r</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.sphere2cart" title="Permalink to this definition"></a></dt>
<dd><p>Spherical to Cartesian coordinates</p>
<p>This is the standard physics convention where <cite>theta</cite> is the
inclination (polar) angle, and <cite>phi</cite> is the azimuth angle.</p>
<p>Imagine a sphere with center (0,0,0).  Orient it with the z axis
running south-north, the y axis running west-east and the x axis
from posterior to anterior.  <cite>theta</cite> (the inclination angle) is the
angle to rotate from the z-axis (the zenith) around the y-axis,
towards the x axis.  Thus the rotation is counter-clockwise from the
point of view of positive y.  <cite>phi</cite> (azimuth) gives the angle of
rotation around the z-axis towards the y axis.  The rotation is
counter-clockwise from the point of view of positive z.</p>
<p>Equivalently, given a point P on the sphere, with coordinates x, y,
z, <cite>theta</cite> is the angle between P and the z-axis, and <cite>phi</cite> is
the angle between the projection of P onto the XY plane, and the X
axis.</p>
<p>Geographical nomenclature designates theta as co-latitude, and phi
as longitude</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">radius</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">inclination or polar angle</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">azimuth angle</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">x coordinate(s) in Cartesion space</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">y coordinate(s) in Cartesian space</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">z coordinate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See these pages:</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Spherical_coordinate_system">http://en.wikipedia.org/wiki/Spherical_coordinate_system</a></li>
<li><a class="reference external" href="http://mathworld.wolfram.com/SphericalCoordinates.html">http://mathworld.wolfram.com/SphericalCoordinates.html</a></li>
</ul>
<p>for excellent discussion of the many different conventions
possible.  Here we use the physics conventions, used in the
wikipedia page.</p>
<p>Derivations of the formulae are simple. Consider a vector x, y, z of
length r (norm of x, y, z).  The inclination angle (theta) can be
found from: cos(theta) == z / r -&gt; z == r * cos(theta).  This gives
the hypotenuse of the projection onto the XY plane, which we will
call Q. Q == r*sin(theta). Now x / Q == cos(phi) -&gt; x == r *
sin(theta) * cos(phi) and so on.</p>
<p>We have deliberately named this function <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">sph2cart</span></code> to distinguish it from the Matlab function of that
name, because the Matlab function uses an unusual convention for the
angles that we did not want to replicate.  The Matlab function is
trivial to implement with the formulae given in the Matlab help.</p>
</dd></dl>

</div>
<div class="section" id="split-dki-param">
<h3>split_dki_param<a class="headerlink" href="#split-dki-param" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.split_dki_param">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">split_dki_param</code><span class="sig-paren">(</span><em>dki_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.split_dki_param" title="Permalink to this definition"></a></dt>
<dd><p>Extract the diffusion tensor eigenvalues, the diffusion tensor
eigenvector matrix, and the 15 independent elements of the kurtosis tensor
from the model parameters estimated from the DKI model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (x, y, z, 3) or (n, 3)</span></dt>
<dd><p class="first last">Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt><strong>eigvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (x, y, z, 3, 3) or (n, 3, 3)</span></dt>
<dd><p class="first last">Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
<dt><strong>kt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (x, y, z, 15) or (n, 15)</span></dt>
<dd><p class="first last">Fifteen elements of the kurtosis tensor</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id208">
<h3>vec_val_vect<a class="headerlink" href="#id208" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.vec_val_vect">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">vec_val_vect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.vec_val_vect" title="Permalink to this definition"></a></dt>
<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, N) array</span></dt>
<dd><p class="first last">containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>
</dd>
<dt><strong>vals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, N) array</span></dt>
<dd><p class="first last">diagonal values carried in last dimension, <code class="docutils literal notranslate"><span class="pre">...</span></code> shape above must
match that for <cite>vecs</cite></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, M) array</span></dt>
<dd><p class="first last">For all the dimensions ellided by <code class="docutils literal notranslate"><span class="pre">...</span></code>, loops to get (M, N) <code class="docutils literal notranslate"><span class="pre">vec</span></code>
matrix, and (N,) <code class="docutils literal notranslate"><span class="pre">vals</span></code> vector, and calculates
<code class="docutils literal notranslate"><span class="pre">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Make a 3D array where the first dimension is only 1</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_val_vect</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="go">array([[[   9.,   24.,   39.],</span>
<span class="go">        [  24.,   66.,  108.],</span>
<span class="go">        [  39.,  108.,  177.]]])</span>
</pre></div>
</div>
<p>Thats the same as the 2D case (apart from the float casting):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">vecs</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">array([[  9,  24,  39],</span>
<span class="go">       [ 24,  66, 108],</span>
<span class="go">       [ 39, 108, 177]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="wls-fit-dki">
<h3>wls_fit_dki<a class="headerlink" href="#wls-fit-dki" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki.wls_fit_dki">
<code class="descclassname">dipy.reconst.dki.</code><code class="descname">wls_fit_dki</code><span class="sig-paren">(</span><em>design_matrix</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki.wls_fit_dki" title="Permalink to this definition"></a></dt>
<dd><p>Computes weighted linear least squares (WLS) fit to calculate
the diffusion tensor and kurtosis tensor using a weighted linear
regression diffusion kurtosis model <a class="footnote-reference" href="#id344" id="id209">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 22)</span></dt>
<dd><p class="first last">Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, g)</span></dt>
<dd><p class="first last">Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>min_signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">default = 1</span></dt>
<dd><p class="first last">All values below min_signal are repalced with min_signal. This is done
in order to avoid taking log(0) durring the tensor fitting.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model for all N
voxels.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id211">
<h3><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit" title="dipy.reconst.dki_micro.DiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisFit</span></code></a><a class="headerlink" href="#id211" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">DiffusionKurtosisFit</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.dti.TensorFit</span></code></a></p>
<p>Class for fitting the Diffusion Kurtosis Model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S0_hat</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></dt>
<dd><p class="first last">For tracking - return the primary direction in each voxel</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></dt>
<dd><p class="first last">Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></dt>
<dd><p class="first last">Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.kt" title="dipy.reconst.dki_micro.DiffusionKurtosisFit.kt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kt</span></code></a></dt>
<dd><p class="first last">Returns the 15 independent elements of the kurtosis tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></dt>
<dd><p class="first last">Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code>()</td>
<td>Axial diffusivity (AD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code>(sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction on</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.ak" title="dipy.reconst.dki_micro.DiffusionKurtosisFit.ak"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ak</span></code></a>([min_kurtosis,&nbsp;max_kurtosis])</td>
<td>Axial Kurtosis (AK) of a diffusion kurtosis tensor <a class="reference internal" href="#rb73f8e7cd86f-1" id="id212">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.akc" title="dipy.reconst.dki_micro.DiffusionKurtosisFit.akc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">akc</span></code></a>(sphere)</td>
<td>Calculates the apparent kurtosis coefficient (AKC) in each direction on the sphere for each voxel in the data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code>()</td>
<td>Color fractional anisotropy of diffusion tensor</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code>()</td>
<td>Fractional anisotropy (FA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code>()</td>
<td>Geodesic anisotropy (GA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.kmax" title="dipy.reconst.dki_micro.DiffusionKurtosisFit.kmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kmax</span></code></a>([sphere,&nbsp;gtol,&nbsp;mask])</td>
<td>Computes the maximum value of a single voxel kurtosis tensor</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code>()</td>
<td>Mean diffusivity (MD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.mk" title="dipy.reconst.dki_micro.DiffusionKurtosisFit.mk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mk</span></code></a>([min_kurtosis,&nbsp;max_kurtosis])</td>
<td>Computes mean Kurtosis (MK) from the kurtosis tensor.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code>()</td>
<td>Tensor mode calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</td>
<td>The diffusion orientation distribution function (dODF).</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.predict" title="dipy.reconst.dki_micro.DiffusionKurtosisFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab[,&nbsp;S0])</td>
<td>Given a DKI model fit, predict the signal on the vertices of a gradient table</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code>()</td>
<td>Radial diffusivity (RD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.rk" title="dipy.reconst.dki_micro.DiffusionKurtosisFit.rk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rk</span></code></a>([min_kurtosis,&nbsp;max_kurtosis])</td>
<td>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class="reference internal" href="#r28a508c47eba-1" id="id213">[1]</a>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>()</td>
<td>Trace of the tensor calculated from cached eigenvalues.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>lower_triangular</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a DiffusionKurtosisFit class instance.</p>
<p>Since DKI is an extension of DTI, class instance is defined as subclass
of the TensorFit from dti.py</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DiffusionKurtosisModel Class instance</span></dt>
<dd><p class="first last">Class instance containing the Diffusion Kurtosis Model for the fit</p>
</dd>
<dt><strong>model_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisFit.ak">
<code class="descname">ak</code><span class="sig-paren">(</span><em>min_kurtosis=-0.42857142857142855</em>, <em>max_kurtosis=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.ak" title="Permalink to this definition"></a></dt>
<dd><p>Axial Kurtosis (AK) of a diffusion kurtosis tensor <a class="reference internal" href="#rb73f8e7cd86f-1" id="id214">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores <a class="reference internal" href="#rb73f8e7cd86f-2" id="id215">[2]</a>)</p>
</dd>
<dt><strong>max_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ak</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated AK.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb73f8e7cd86f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id212">1</a>, <a class="fn-backref" href="#id214">2</a>, <a class="fn-backref" href="#id216">3</a>)</em> Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb73f8e7cd86f-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id215">1</a>, <a class="fn-backref" href="#id217">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisFit.akc">
<code class="descname">akc</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.akc" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the apparent kurtosis coefficient (AKC) in each
direction on the sphere for each voxel in the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>akc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The estimates of the apparent kurtosis coefficient in every
direction on the input sphere</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For each sphere direction with coordinates <span class="math notranslate nohighlight">\((n_{1}, n_{2}, n_{3})\)</span>, the
calculation of AKC is done using formula:</p>
<div class="math notranslate nohighlight">
\[AKC(n)=\frac{MD^{2}}{ADC(n)^{2}}\sum_{i=1}^{3}\sum_{j=1}^{3}
\sum_{k=1}^{3}\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\]</div>
<p>where <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the kurtosis tensor, MD the mean
diffusivity and ADC the apparent diffusion coefficent computed as:</p>
<div class="math notranslate nohighlight">
\[ADC(n)=\sum_{i=1}^{3}\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\]</div>
<p>where <span class="math notranslate nohighlight">\(D_{ij}\)</span> are the elements of the diffusion tensor.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisFit.kmax">
<code class="descname">kmax</code><span class="sig-paren">(</span><em>sphere='repulsion100'</em>, <em>gtol=1e-05</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.kmax" title="Permalink to this definition"></a></dt>
<dd><p>Computes the maximum value of a single voxel kurtosis tensor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance, optional</span></dt>
<dd><p class="first last">The sphere providing sample directions for the initial search of
the maximum value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">This input is to refine kurtosis maximum under the precision of the
directions sampled on the sphere class instance. The gradient of
the convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken
from the initial sampled directions of the given sphere object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>max_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">kurtosis tensor maximum value</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisFit.kt">
<code class="descname">kt</code><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.kt" title="Permalink to this definition"></a></dt>
<dd><p>Returns the 15 independent elements of the kurtosis tensor as an array</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisFit.mk">
<code class="descname">mk</code><span class="sig-paren">(</span><em>min_kurtosis=-0.42857142857142855</em>, <em>max_kurtosis=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.mk" title="Permalink to this definition"></a></dt>
<dd><p>Computes mean Kurtosis (MK) from the kurtosis tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores <a class="reference internal" href="#rb657f27beb9e-2" id="id218">[2]</a>)</p>
</dd>
<dt><strong>max_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, mean
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mk</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated MK.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The MK analytical solution is calculated using the following equation
<a class="reference internal" href="#rb657f27beb9e-1" id="id219">[1]</a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}MK=F_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{1111}+
F_1(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{2222}+
F_1(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{3333}+ \\
F_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}+
F_2(\lambda_2,\lambda_1,\lambda_3)\hat{W}_{1133}+
F_2(\lambda_3,\lambda_2,\lambda_1)\hat{W}_{1122}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{W}_{ijkl}\)</span> are the components of the <span class="math notranslate nohighlight">\(W\)</span> tensor in the
coordinates system defined by the eigenvectors of the diffusion tensor
<span class="math notranslate nohighlight">\(\mathbf{D}\)</span> and</p>
<div class="math notranslate nohighlight">
\[\begin{split}F_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{18(\lambda_1-\lambda_2)(\lambda_1-\lambda_3)}
[\frac{\sqrt{\lambda_2\lambda_3}}{\lambda_1}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{3\lambda_1^2-\lambda_1\lambda_2-\lambda_2\lambda_3-
\lambda_1\lambda_3}
{3\lambda_1 \sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-1 ]\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}F_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}
{3(\lambda_2-\lambda_3)^2}
[\frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}
R_F(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)+\\
\frac{2\lambda_1-\lambda_2-\lambda_3}{3\sqrt{\lambda_2 \lambda_3}}
R_D(\frac{\lambda_1}{\lambda_2},\frac{\lambda_1}{\lambda_3},1)-2]\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(R_f\)</span> and <span class="math notranslate nohighlight">\(R_d\)</span> are the Carlsons elliptic integrals.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb657f27beb9e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id219">1</a>, <a class="fn-backref" href="#id220">2</a>)</em> Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb657f27beb9e-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id218">1</a>, <a class="fn-backref" href="#id221">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Given a DKI model fit, predict the signal on the vertices of a
gradient table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray (optional)</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S(n,b)=S_{0}e^{-bD(n)+\frac{1}{6}b^{2}D(n)^{2}K(n)}\]</div>
<p><span class="math notranslate nohighlight">\(\mathbf{D(n)}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{K(n)}\)</span> can be computed from the DT and KT
using the following equations:</p>
<div class="math notranslate nohighlight">
\[D(n)=\sum_{i=1}^{3}\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[K(n)=\frac{MD^{2}}{D(n)^{2}}\sum_{i=1}^{3}\sum_{j=1}^{3}
\sum_{k=1}^{3}\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\]</div>
<p>where <span class="math notranslate nohighlight">\(D_{ij}\)</span> and <span class="math notranslate nohighlight">\(W_{ijkl}\)</span> are the elements of the second-order DT
and the fourth-order KT tensors, respectively, and <span class="math notranslate nohighlight">\(MD\)</span> is the mean
diffusivity.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisFit.rk">
<code class="descname">rk</code><span class="sig-paren">(</span><em>min_kurtosis=-0.42857142857142855</em>, <em>max_kurtosis=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisFit.rk" title="Permalink to this definition"></a></dt>
<dd><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class="reference internal" href="#r28a508c47eba-1" id="id222">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced
with -3./7 (theoretical kurtosis limit
for regions that consist of water confined to spherical pores <a class="reference internal" href="#r28a508c47eba-2" id="id223">[2]</a>)</p>
</dd>
<dt><strong>max_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">To keep kurtosis values within a plausible biophysical range, axial
kurtosis values that are larger than <cite>max_kurtosis</cite> are replaced
with <cite>max_kurtosis</cite>. Default = 10</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rk</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated RK.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>RK is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[K_{\bot} = G_1(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2222} +
           G_1(\lambda_1,\lambda_3,\lambda_2)\hat{W}_{3333} +
           G_2(\lambda_1,\lambda_2,\lambda_3)\hat{W}_{2233}\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[G_1(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{18\lambda_2(\lambda_2-
\lambda_3)} \left (2\lambda_2 +
\frac{\lambda_3^2-3\lambda_2\lambda_3}{\sqrt{\lambda_2\lambda_3}}
\right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[G_2(\lambda_1,\lambda_2,\lambda_3)=
\frac{(\lambda_1+\lambda_2+\lambda_3)^2}{(\lambda_2-\lambda_3)^2}
\left ( \frac{\lambda_2+\lambda_3}{\sqrt{\lambda_2\lambda_3}}-2
\right )\]</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r28a508c47eba-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id213">1</a>, <a class="fn-backref" href="#id222">2</a>, <a class="fn-backref" href="#id224">3</a>)</em> Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.
Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r28a508c47eba-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id223">1</a>, <a class="fn-backref" href="#id225">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id226">
<h3><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisModel" title="dipy.reconst.dki_micro.DiffusionKurtosisModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionKurtosisModel</span></code></a><a class="headerlink" href="#id226" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">DiffusionKurtosisModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>Class for the Diffusion Kurtosis Model</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisModel.fit" title="dipy.reconst.dki_micro.DiffusionKurtosisModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method of the DKI model class</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.DiffusionKurtosisModel.predict" title="dipy.reconst.dki_micro.DiffusionKurtosisModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(dki_params[,&nbsp;S0])</td>
<td>Predict a signal for this DKI model class instance given parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Diffusion Kurtosis Tensor Model [1]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>fit_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or callable</span></dt>
<dd><p class="first">str can be one of the following:
OLS or ULLS for ordinary least squares</p>
<blockquote>
<div><p>dki.ols_fit_dki</p>
</div></blockquote>
<dl class="last docutils">
<dt>WLS or UWLLS for weighted ordinary least squares</dt>
<dd><p class="first last">dki.wls_fit_dki</p>
</dd>
<dt>callable has to have the signature:</dt>
<dd><p class="first last">fit_method(design_matrix, data, <a href="#id227"><span class="problematic" id="id228">*</span></a>args, <a href="#id229"><span class="problematic" id="id230">**</span></a>kwargs)</p>
</dd>
</dl>
</dd>
<dt><strong>args, kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">arguments and key-word arguments passed to the</span></dt>
<dd><p class="first last">fit_method. See dki.ols_fit_dki, dki.wls_fit_dki for details</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r37c013a7aa4e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id231">[1]</a></td><td>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.</td></tr>
</tbody>
</table>
<p>Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging. Magn Reson Med. 65(3), 823-836</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method of the DKI model class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The measured signal from one voxel.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[-1]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.DiffusionKurtosisModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>dki_params</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.DiffusionKurtosisModel.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict a signal for this DKI model class instance given
parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray (optional)</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="kurtosismicrostructuralfit">
<h3><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructuralFit</span></code></a><a class="headerlink" href="#kurtosismicrostructuralfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">KurtosisMicrostructuralFit</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisFit" title="dipy.reconst.dki.DiffusionKurtosisFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.dki.DiffusionKurtosisFit</span></code></a></p>
<p>Class for fitting the Diffusion Kurtosis Microstructural Model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S0_hat</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">awf</span></code></a></dt>
<dd><p class="first last">Returns the volume fraction of the restricted diffusion compartment also known as axonal water fraction.</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axonal_diffusivity</span></code></a></dt>
<dd><p class="first last">Returns the axonal diffusivity defined as the restricted diffusion tensor trace <a class="footnote-reference" href="#id344" id="id232">[1]</a>.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></dt>
<dd><p class="first last">For tracking - return the primary direction in each voxel</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></dt>
<dd><p class="first last">Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></dt>
<dd><p class="first last">Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hindered_ad</span></code></a></dt>
<dd><p class="first last">Returns the axial diffusivity of the hindered compartment.</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hindered_evals</span></code></a></dt>
<dd><p class="first last">Returns the eigenvalues of the hindered diffusion compartment.</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hindered_rd</span></code></a></dt>
<dd><p class="first last">Returns the radial diffusivity of the hindered compartment.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kt</span></code></dt>
<dd><p class="first last">Returns the 15 independent elements of the kurtosis tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></dt>
<dd><p class="first last">Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">restricted_evals</span></code></a></dt>
<dd><p class="first last">Returns the eigenvalues of the restricted diffusion compartment.</p>
</dd>
<dt><strong>shape</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.dki_micro.tortuosity" title="dipy.reconst.dki_micro.tortuosity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tortuosity</span></code></a></dt>
<dd><p class="first last">Returns the tortuosity of the hindered diffusion which is defined by ADe / RDe, where ADe and RDe are the axial and radial diffusivities of the hindered compartment <a class="footnote-reference" href="#id344" id="id233">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code>()</td>
<td>Axial diffusivity (AD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code>(sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction on</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ak</span></code>([min_kurtosis,&nbsp;max_kurtosis])</td>
<td>Axial Kurtosis (AK) of a diffusion kurtosis tensor [R0b1a747e81c9-1].</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">akc</span></code>(sphere)</td>
<td>Calculates the apparent kurtosis coefficient (AKC) in each direction on the sphere for each voxel in the data</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code>()</td>
<td>Color fractional anisotropy of diffusion tensor</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code>()</td>
<td>Fractional anisotropy (FA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code>()</td>
<td>Geodesic anisotropy (GA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">kmax</span></code>([sphere,&nbsp;gtol,&nbsp;mask])</td>
<td>Computes the maximum value of a single voxel kurtosis tensor</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code>()</td>
<td>Mean diffusivity (MD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mk</span></code>([min_kurtosis,&nbsp;max_kurtosis])</td>
<td>Computes mean Kurtosis (MK) from the kurtosis tensor.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code>()</td>
<td>Tensor mode calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</td>
<td>The diffusion orientation distribution function (dODF).</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict" title="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab[,&nbsp;S0])</td>
<td>Given a DKI microstructural model fit, predict the signal on the vertices of a gradient table</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code>()</td>
<td>Radial diffusivity (RD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rk</span></code>([min_kurtosis,&nbsp;max_kurtosis])</td>
<td>Radial Kurtosis (RK) of a diffusion kurtosis tensor [Rc4101656d30e-1].</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>()</td>
<td>Trace of the tensor calculated from cached eigenvalues.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>lower_triangular</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a KurtosisMicrostructural Fit class instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DiffusionKurtosisModel Class instance</span></dt>
<dd><p class="first last">Class instance containing the Diffusion Kurtosis Model for the fit</p>
</dd>
<dt><strong>model_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 40) or (n, 40)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis
microstructural model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
<li>Six elements of the hindered diffusion tensor</li>
<li>Six elements of the restricted diffusion tensor</li>
<li>Axonal water fraction</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re21233a693ae-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id236">[1]</a></td><td>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf">
<code class="descname">awf</code><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf" title="Permalink to this definition"></a></dt>
<dd><p>Returns the volume fraction of the restricted diffusion compartment
also known as axonal water fraction.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r4c8a5eb03d8b-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id237">[1]</a></td><td>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity">
<code class="descname">axonal_diffusivity</code><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the axonal diffusivity defined as the restricted diffusion
tensor trace <a class="reference internal" href="#rb958a4769cfc-1" id="id238">[1]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb958a4769cfc-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id238">1</a>, <a class="fn-backref" href="#id239">2</a>)</em> Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad">
<code class="descname">hindered_ad</code><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad" title="Permalink to this definition"></a></dt>
<dd><p>Returns the axial diffusivity of the hindered compartment.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rcb29c1d0417b-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id240">[1]</a></td><td>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals">
<code class="descname">hindered_evals</code><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals" title="Permalink to this definition"></a></dt>
<dd><p>Returns the eigenvalues of the hindered diffusion compartment.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r948cec370d67-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id241">[1]</a></td><td>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd">
<code class="descname">hindered_rd</code><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd" title="Permalink to this definition"></a></dt>
<dd><p>Returns the radial diffusivity of the hindered compartment.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r83ec1ea181c7-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id242">[1]</a></td><td>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Given a DKI microstructural model fit, predict the signal on the
vertices of a gradient table</p>
<dl class="docutils">
<dt>gtab <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd>The gradient table for this prediction</dd>
<dt>S0 <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray (optional)</span></dt>
<dd>The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</dd>
</dl>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<p><span class="math notranslate nohighlight">\(S(\theta, b) = S_0 * [f * e^{-b ADC_{r}} + (1-f) * e^{-b ADC_{h}]\)</span>,
where <span class="math notranslate nohighlight">\(ADC_{r}\)</span> and <span class="math notranslate nohighlight">\(ADC_{h}\)</span> are the apparent diffusion coefficients
of the diffusion hindered and restricted compartment for a given
direction <span class="math notranslate nohighlight">\(\theta\)</span>, <span class="math notranslate nohighlight">\(b\)</span> is the b value provided in the GradientTable
input for that direction, <span class="math notranslate nohighlight">\(f\)</span> is the volume fraction of the restricted
diffusion compartment (also known as the axonal water fraction).</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals">
<code class="descname">restricted_evals</code><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals" title="Permalink to this definition"></a></dt>
<dd><p>Returns the eigenvalues of the restricted diffusion compartment.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd96f073eac17-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id243">[1]</a></td><td>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity">
<code class="descname">tortuosity</code><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the tortuosity of the hindered diffusion which is defined
by ADe / RDe, where ADe and RDe are the axial and radial diffusivities
of the hindered compartment <a class="reference internal" href="#r09f7b36bb2d5-1" id="id244">[1]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r09f7b36bb2d5-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id244">1</a>, <a class="fn-backref" href="#id245">2</a>)</em> Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="kurtosismicrostructuremodel">
<h3><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">KurtosisMicrostructureModel</span></code></a><a class="headerlink" href="#kurtosismicrostructuremodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructureModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">KurtosisMicrostructureModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dki.DiffusionKurtosisModel" title="dipy.reconst.dki.DiffusionKurtosisModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.dki.DiffusionKurtosisModel</span></code></a></p>
<p>Class for the Diffusion Kurtosis Microstructural Model</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask,&nbsp;sphere,&nbsp;gtol,&nbsp;awf_only])</td>
<td>Fit method of the Diffusion Kurtosis Microstructural Model</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict" title="dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(params[,&nbsp;S0])</td>
<td>Predict a signal for the DKI microstructural model class instance given parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructureModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a KurtosisMicrostrutureModel class instance <a class="reference internal" href="#r54404032803e-1" id="id246">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>fit_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or callable</span></dt>
<dd><p class="first">str can be one of the following:
OLS or ULLS to fit the diffusion tensor and kurtosis tensor
using the ordinary linear least squares solution</p>
<blockquote>
<div><p>dki.ols_fit_dki</p>
</div></blockquote>
<p>WLS or UWLLS to fit the diffusion tensor and kurtosis tensor
using the ordinary linear least squares solution</p>
<blockquote>
<div><p>dki.wls_fit_dki</p>
</div></blockquote>
<dl class="last docutils">
<dt>callable has to have the signature:</dt>
<dd><p class="first last">fit_method(design_matrix, data, <a href="#id247"><span class="problematic" id="id248">*</span></a>args, <a href="#id249"><span class="problematic" id="id250">**</span></a>kwargs)</p>
</dd>
</dl>
</dd>
<dt><strong>args, kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">arguments and key-word arguments passed to the</span></dt>
<dd><p class="first last">fit_method. See dki.ols_fit_dki, dki.wls_fit_dki for details</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r54404032803e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id246">1</a>, <a class="fn-backref" href="#id251">2</a>)</em> Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em>, <em>sphere='repulsion100'</em>, <em>gtol=0.01</em>, <em>awf_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method of the Diffusion Kurtosis Microstructural Model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An 4D matrix containing the diffusion-weighted data.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[-1]</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance, optional</span></dt>
<dd><p class="first last">The sphere providing sample directions for the initial search of
the maximal value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">This input is to refine kurtosis maxima under the precision of the
directions sampled on the sphere class instance. The gradient of
the convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken
from the initial sampled directions of the given sphere object</p>
</dd>
<dt><strong>awf_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optiomal</span></dt>
<dd><p class="first last">If set to true only the axonal volume fraction is computed from
the kurtosis tensor. Default = False</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>params</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict a signal for the DKI microstructural model class instance
given parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 40) or (n, 40)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis
microstructural model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
<li>Six elements of the hindered diffusion tensor</li>
<li>Six elements of the restricted diffusion tensor</li>
<li>Axonal water fraction</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray (optional)</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r34e1450d7d99-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id252">[1]</a></td><td>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter
Characterization with Diffusion Kurtosis Imaging. Neuroimage
58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="axial-diffusivity">
<h3>axial_diffusivity<a class="headerlink" href="#axial-diffusivity" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.axial_diffusivity">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">axial_diffusivity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.axial_diffusivity" title="Permalink to this definition"></a></dt>
<dd><p>Axial Diffusivity (AD) of a diffusion tensor.
Also called parallel diffusivity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><p class="first last">Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated AD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>AD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[AD = \lambda_1\]</div>
</dd></dl>

</div>
<div class="section" id="axonal-water-fraction">
<h3>axonal_water_fraction<a class="headerlink" href="#axonal-water-fraction" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.axonal_water_fraction">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">axonal_water_fraction</code><span class="sig-paren">(</span><em>dki_params</em>, <em>sphere='repulsion100'</em>, <em>gtol=0.01</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.axonal_water_fraction" title="Permalink to this definition"></a></dt>
<dd><p>Computes the axonal water fraction from DKI <a class="reference internal" href="#r48388d37c81b-1" id="id253">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance, optional</span></dt>
<dd><p class="first last">The sphere providing sample directions for the initial search of the
maximal value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">This input is to refine kurtosis maxima under the precision of the
directions sampled on the sphere class instance. The gradient of the
convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken from
the initial sampled directions of the given sphere object</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>awf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z) or (n)</span></dt>
<dd><p class="first last">Axonal Water Fraction</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r48388d37c81b-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id13">1</a>, <a class="fn-backref" href="#id253">2</a>, <a class="fn-backref" href="#id254">3</a>)</em> Fieremans E, Jensen JH, Helpern JA, 2011. White matter
characterization with diffusional kurtosis imaging.
Neuroimage 58(1):177-88. doi: 10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id255">
<h3>decompose_tensor<a class="headerlink" href="#id255" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.decompose_tensor">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">decompose_tensor</code><span class="sig-paren">(</span><em>tensor</em>, <em>min_diffusivity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.decompose_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>
<p>Computes tensor eigen decomposition to calculate eigenvalues and
eigenvectors (Basser et al., 1994a).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Hermitian matrix representing a diffusion tensor.</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3)</span></dt>
<dd><p class="first last">Eigenvalues from eigen decomposition of the tensor. Negative
eigenvalues are replaced by zero. Sorted from largest to smallest.</p>
</dd>
<dt><strong>eigvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[, :, j] is associated with
eigvals[, j])</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="diffusion-components">
<h3>diffusion_components<a class="headerlink" href="#diffusion-components" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.diffusion_components">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">diffusion_components</code><span class="sig-paren">(</span><em>dki_params</em>, <em>sphere='repulsion100'</em>, <em>awf=None</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.diffusion_components" title="Permalink to this definition"></a></dt>
<dd><p>Extracts the restricted and hindered diffusion tensors of well aligned
fibers from diffusion kurtosis imaging parameters <a class="reference internal" href="#rfba5c976a30b-1" id="id256">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance, optional</span></dt>
<dd><p class="first last">The sphere providing sample directions to sample the restricted and
hindered cellular diffusion tensors. For more details see Fieremans
et al., 2011.</p>
</dd>
<dt><strong>awf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (optional)</span></dt>
<dd><p class="first last">Array containing values of the axonal water fraction that has the shape
dki_params.shape[:-1]. If not given this will be automatically computed
using <a class="reference internal" href="#dipy.reconst.dki_micro.axonal_water_fraction" title="dipy.reconst.dki_micro.axonal_water_fraction"><code class="xref py py-func docutils literal notranslate"><span class="pre">axonal_water_fraction()</span></code></a> with functions default precision.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (optional)</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>edt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 6) or (n, 6)</span></dt>
<dd><p class="first last">Parameters of the hindered diffusion tensor.</p>
</dd>
<dt><strong>idt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 6) or (n, 6)</span></dt>
<dd><p class="first last">Parameters of the restricted diffusion tensor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rfba5c976a30b-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id14">1</a>, <a class="fn-backref" href="#id256">2</a>, <a class="fn-backref" href="#id257">3</a>)</em> Fieremans E, Jensen JH, Helpern JA, 2011. White matter
characterization with diffusional kurtosis imaging.
Neuroimage 58(1):177-88. doi: 10.1016/j.neuroimage.2011.06.006</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id258">
<h3>directional_diffusion<a class="headerlink" href="#id258" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.directional_diffusion">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">directional_diffusion</code><span class="sig-paren">(</span><em>dt</em>, <em>V</em>, <em>min_diffusivity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.directional_diffusion" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the apparent diffusion coefficient (adc) in each direction
of a sphere for a single voxel <a class="reference internal" href="#r1dff1a553580-1" id="id259">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (6,)</span></dt>
<dd><p class="first last">elements of the diffusion tensor of the voxel.</p>
</dd>
<dt><strong>V</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 3)</span></dt>
<dd><p class="first last">g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>. Default = 0</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (g,)</span></dt>
<dd><p class="first last">Apparent diffusion coefficient (adc) in all g directions of a sphere
for a single voxel.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1dff1a553580-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id15">1</a>, <a class="fn-backref" href="#id259">2</a>, <a class="fn-backref" href="#id260">3</a>)</em> Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
Exploring the 3D geometry of the diffusion kurtosis tensor -
Impact on the development of robust tractography procedures and
novel biomarkers, NeuroImage 111: 85-99</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id261">
<h3>directional_kurtosis<a class="headerlink" href="#id261" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.directional_kurtosis">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">directional_kurtosis</code><span class="sig-paren">(</span><em>dt</em>, <em>md</em>, <em>kt</em>, <em>V</em>, <em>min_diffusivity=0</em>, <em>min_kurtosis=-0.42857142857142855</em>, <em>adc=None</em>, <em>adv=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.directional_kurtosis" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the apparent kurtosis coefficient (akc) in each direction
of a sphere for a single voxel <a class="reference internal" href="#r014624b5ce79-1" id="id262">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (6,)</span></dt>
<dd><p class="first last">elements of the diffusion tensor of the voxel.</p>
</dd>
<dt><strong>md</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">mean diffusivity of the voxel</p>
</dd>
<dt><strong>kt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (15,)</span></dt>
<dd><p class="first last">elements of the kurtosis tensor of the voxel.</p>
</dd>
<dt><strong>V</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 3)</span></dt>
<dd><p class="first last">g directions of a Sphere in Cartesian coordinates</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">Because negative eigenvalues are not physical and small eigenvalues
cause quite a lot of noise in diffusion-based metrics, diffusivity
values smaller than <cite>min_diffusivity</cite> are replaced with
<cite>min_diffusivity</cite>. Default = 0</p>
</dd>
<dt><strong>min_kurtosis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">Because high-amplitude negative values of kurtosis are not physicaly
and biologicaly pluasible, and these cause artefacts in
kurtosis-based measures, directional kurtosis values smaller than
<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7
(theoretical kurtosis limit for regions that consist of water confined
to spherical pores <a class="reference internal" href="#r014624b5ce79-2" id="id263">[2]</a>)</p>
</dd>
<dt><strong>adc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray(g,) (optional)</span></dt>
<dd><p class="first last">Apparent diffusion coefficient (adc) in all g directions of a sphere
for a single voxel.</p>
</dd>
<dt><strong>adv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray(g,) (optional)</span></dt>
<dd><p class="first last">Apparent diffusion variance (advc) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>akc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (g,)</span></dt>
<dd><p class="first last">Apparent kurtosis coefficient (AKC) in all g directions of a sphere for
a single voxel.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r014624b5ce79-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id16">1</a>, <a class="fn-backref" href="#id262">2</a>, <a class="fn-backref" href="#id264">3</a>)</em> Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).
Exploring the 3D geometry of the diffusion kurtosis tensor -
Impact on the development of robust tractography procedures and
novel biomarkers, NeuroImage 111: 85-99</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r014624b5ce79-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id263">1</a>, <a class="fn-backref" href="#id265">2</a>)</em> Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:
Robust estimation from DW-MRI using homogeneous polynomials.
Proceedings of the 8th {IEEE} International Symposium on
Biomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.
doi: 10.1109/ISBI.2011.5872402</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="dkimicro-prediction">
<h3>dkimicro_prediction<a class="headerlink" href="#dkimicro-prediction" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.dkimicro_prediction">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">dkimicro_prediction</code><span class="sig-paren">(</span><em>params</em>, <em>gtab</em>, <em>S0=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.dkimicro_prediction" title="Permalink to this definition"></a></dt>
<dd><p>Signal prediction given the DKI microstructure model parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 40) or (n, 40)</span></dt>
<dd></dd>
<dt><strong>All parameters estimated from the diffusion kurtosis microstructure model.</strong></dt>
<dd><dl class="first last docutils">
<dt>Parameters are ordered as follows:</dt>
<dd><ol class="first last arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
<li>Six elements of the hindered diffusion tensor</li>
<li>Six elements of the restricted diffusion tensor</li>
<li>Axonal water fraction</li>
</ol>
</dd>
</dl>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, N) ndarray</span></dt>
<dd><p class="first last">Simulated signal based on the DKI microstructure model</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>1) The predicted signal is given by:
<span class="math notranslate nohighlight">\(S(\theta, b) = S_0 * [f * e^{-b ADC_{r}} + (1-f) * e^{-b ADC_{h}]\)</span>, where
:math:` ADC_{r} and ADC_{h} are the apparent diffusion coefficients of the
diffusion hindered and restricted compartment for a given direction
<cite>theta:math:</cite>, <cite>b:math:</cite> is the b value provided in the GradientTable input for that
direction, <a href="#id266"><span class="problematic" id="id267">`</span></a>f$ is the volume fraction of the restricted diffusion
compartment (also known as the axonal water fraction).</p>
<p>2) In the original article of DKI microstructural model <a class="footnote-reference" href="#id344" id="id268">[1]</a>, the hindered
and restricted tensors were definde as the intra-cellular and
extra-cellular diffusion compartments respectively.</p>
</dd></dl>

</div>
<div class="section" id="dti-design-matrix">
<h3>dti_design_matrix<a class="headerlink" href="#dti-design-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.dti_design_matrix">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">dti_design_matrix</code><span class="sig-paren">(</span><em>gtab</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.dti_design_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Constructs design matrix for DTI weighted least squares or
least squares fitting. (Basser et al., 1994a)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">A GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Parameter to control the dtype of returned designed matrix</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g,7)</span></dt>
<dd><p class="first last">Design matrix or B matrix assuming Gaussian distributed tensor model
design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id269">
<h3>from_lower_triangular<a class="headerlink" href="#id269" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.from_lower_triangular">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">from_lower_triangular</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.from_lower_triangular" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tensor given the six unique tensor elements</p>
<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,
Dyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are
ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, (, &gt;6)</span></dt>
<dd><p class="first last">Unique elements of the tensors</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (, 3, 3)</span></dt>
<dd><p class="first last">3 by 3 tensors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id270">
<h3>get_sphere<a class="headerlink" href="#id270" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.get_sphere">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">get_sphere</code><span class="sig-paren">(</span><em>name='symmetric362'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.get_sphere" title="Permalink to this definition"></a></dt>
<dd><p>provide triangulated spheres</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">which sphere - one of:
* symmetric362
* symmetric642
* symmetric724
* repulsion724
* repulsion100
* repulsion200</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a dipy.core.sphere.Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;symmetric362&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">sphere</span><span class="o">.</span><span class="n">faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">362</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">720</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;not a sphere name&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">DataError</span>: <span class="n">No sphere called &quot;not a sphere name&quot;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id271">
<h3>kurtosis_maximum<a class="headerlink" href="#id271" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.kurtosis_maximum">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">kurtosis_maximum</code><span class="sig-paren">(</span><em>dki_params</em>, <em>sphere='repulsion100'</em>, <em>gtol=0.01</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.kurtosis_maximum" title="Permalink to this definition"></a></dt>
<dd><p>Computes kurtosis maximum value</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eingenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance, optional</span></dt>
<dd><p class="first last">The sphere providing sample directions for the initial search of the
maximal value of kurtosis.</p>
</dd>
<dt><strong>gtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">This input is to refine kurtosis maximum under the precision of the
directions sampled on the sphere class instance. The gradient of the
convergence procedure must be less than gtol before successful
termination. If gtol is None, fiber direction is directly taken from
the initial sampled directions of the given sphere object</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that should be
analyzed that has the shape dki_params.shape[:-1]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>max_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">kurtosis tensor maximum value</p>
</dd>
<dt><strong>max_dir</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (3,)</span></dt>
<dd><p class="first last">Cartesian coordinates of the direction of the maximal kurtosis value</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id272">
<h3>lower_triangular<a class="headerlink" href="#id272" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.lower_triangular">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">lower_triangular</code><span class="sig-paren">(</span><em>tensor</em>, <em>b0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.lower_triangular" title="Permalink to this definition"></a></dt>
<dd><p>Returns the six lower triangular values of the tensor and a dummy variable
if b0 is not None</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, 3, 3)</span></dt>
<dd><p class="first last">a collection of 3, 3 diffusion tensors</p>
</dd>
<dt><strong>b0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">if b0 is not none log(b0) is returned as the dummy variable</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">If b0 is none, then the shape will be (, 6) otherwise (, 7)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id273">
<h3>mean_diffusivity<a class="headerlink" href="#id273" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.mean_diffusivity">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">mean_diffusivity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.mean_diffusivity" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Mean Diffusivity (MD) of a diffusion tensor.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated MD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1 + lambda_2 + lambda_3}{3}</p>
</dd></dl>

</div>
<div class="section" id="id274">
<h3>ndindex<a class="headerlink" href="#id274" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.ndindex">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">ndindex</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.ndindex" title="Permalink to this definition"></a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd><p class="first last">The dimensions of the array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="k">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="radial-diffusivity">
<h3>radial_diffusivity<a class="headerlink" href="#radial-diffusivity" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.radial_diffusivity">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">radial_diffusivity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.radial_diffusivity" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Radial Diffusivity (RD) of a diffusion tensor.
Also called perpendicular diffusivity.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rd</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated RD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_2 + lambda_3}{2}</p>
</dd></dl>

</div>
<div class="section" id="id275">
<h3>split_dki_param<a class="headerlink" href="#id275" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.split_dki_param">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">split_dki_param</code><span class="sig-paren">(</span><em>dki_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.split_dki_param" title="Permalink to this definition"></a></dt>
<dd><p>Extract the diffusion tensor eigenvalues, the diffusion tensor
eigenvector matrix, and the 15 independent elements of the kurtosis tensor
from the model parameters estimated from the DKI model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dki_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 27) or (n, 27)</span></dt>
<dd><p class="first">All parameters estimated from the diffusion kurtosis model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the first,
second and third coordinates of the eigenvector</li>
<li>Fifteen elements of the kurtosis tensor</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (x, y, z, 3) or (n, 3)</span></dt>
<dd><p class="first last">Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt><strong>eigvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (x, y, z, 3, 3) or (n, 3, 3)</span></dt>
<dd><p class="first last">Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
<dt><strong>kt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (x, y, z, 15) or (n, 15)</span></dt>
<dd><p class="first last">Fifteen elements of the kurtosis tensor</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="tortuosity">
<h3>tortuosity<a class="headerlink" href="#tortuosity" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.tortuosity">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">tortuosity</code><span class="sig-paren">(</span><em>hindered_ad</em>, <em>hindered_rd</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.tortuosity" title="Permalink to this definition"></a></dt>
<dd><p>Computes the tortuosity of the hindered diffusion compartment given
its axial and radial diffusivities</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hindered_ad: ndarray</strong></dt>
<dd><p class="first last">Array containing the values of the hindered axial diffusivity.</p>
</dd>
<dt><strong>hindered_rd: ndarray</strong></dt>
<dd><p class="first last">Array containing the values of the hindered radial diffusivity.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="trace">
<h3>trace<a class="headerlink" href="#trace" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.trace">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">trace</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.trace" title="Permalink to this definition"></a></dt>
<dd><p>Trace of a diffusion tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><p class="first last">Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated trace of the diffusion tensor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Trace is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Trace = \lambda_1 + \lambda_2 + \lambda_3\]</div>
</dd></dl>

</div>
<div class="section" id="id276">
<h3>vec_val_vect<a class="headerlink" href="#id276" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dki_micro.vec_val_vect">
<code class="descclassname">dipy.reconst.dki_micro.</code><code class="descname">vec_val_vect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dki_micro.vec_val_vect" title="Permalink to this definition"></a></dt>
<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, N) array</span></dt>
<dd><p class="first last">containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>
</dd>
<dt><strong>vals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, N) array</span></dt>
<dd><p class="first last">diagonal values carried in last dimension, <code class="docutils literal notranslate"><span class="pre">...</span></code> shape above must
match that for <cite>vecs</cite></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, M) array</span></dt>
<dd><p class="first last">For all the dimensions ellided by <code class="docutils literal notranslate"><span class="pre">...</span></code>, loops to get (M, N) <code class="docutils literal notranslate"><span class="pre">vec</span></code>
matrix, and (N,) <code class="docutils literal notranslate"><span class="pre">vals</span></code> vector, and calculates
<code class="docutils literal notranslate"><span class="pre">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Make a 3D array where the first dimension is only 1</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_val_vect</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="go">array([[[   9.,   24.,   39.],</span>
<span class="go">        [  24.,   66.,  108.],</span>
<span class="go">        [  39.,  108.,  177.]]])</span>
</pre></div>
</div>
<p>Thats the same as the 2D case (apart from the float casting):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">vecs</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">array([[  9,  24,  39],</span>
<span class="go">       [ 24,  66, 108],</span>
<span class="go">       [ 39, 108, 177]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id277">
<h3><a class="reference internal" href="#dipy.reconst.dsi.Cache" title="dipy.reconst.dsi.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#id277" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.Cache">
<em class="property">class </em><code class="descclassname">dipy.reconst.dsi.</code><code class="descname">Cache</code><a class="headerlink" href="#dipy.reconst.dsi.Cache" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.Cache.cache_clear" title="dipy.reconst.dsi.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.Cache.cache_get" title="dipy.reconst.dsi.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.Cache.cache_set" title="dipy.reconst.dsi.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.Cache.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.Cache.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.Cache.cache_clear">
<code class="descname">cache_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.Cache.cache_clear" title="Permalink to this definition"></a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.Cache.cache_get">
<code class="descname">cache_get</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.Cache.cache_get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.Cache.cache_set">
<code class="descname">cache_set</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.Cache.cache_set" title="Permalink to this definition"></a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffusionspectrumdeconvfit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvFit</span></code></a><a class="headerlink" href="#diffusionspectrumdeconvfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.dsi.</code><code class="descname">DiffusionSpectrumDeconvFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.dsi.DiffusionSpectrumFit</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd_discrete</span></code>([normalized])</td>
<td>Calculates the mean squared displacement on the discrete propagator</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</td>
<td>Calculates the real discrete odf for a given discrete sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf" title="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>()</td>
<td>Applies the 3D FFT in the q-space grid to generate the DSI diffusion propagator, remove the background noise with a hard threshold and then deconvolve the propagator with the Lucy-Richardson deconvolution algorithm</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_pdf</span></code>([normalized])</td>
<td>Calculates the return to origin probability from the propagator, which is the propagator evaluated at zero (see Descoteaux et Al.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_signal</span></code>([filtering])</td>
<td>Calculates the return to origin probability (rtop) from the signal rtop equals to the sum of all signal values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Calculates PDF and ODF and other properties for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">DiffusionSpectrumModel</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">signal values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf">
<code class="descname">pdf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf" title="Permalink to this definition"></a></dt>
<dd><p>Applies the 3D FFT in the q-space grid to generate
the DSI diffusion propagator, remove the background noise with a
hard threshold and then deconvolve the propagator with the
Lucy-Richardson deconvolution algorithm</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffusionspectrumdeconvmodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumDeconvModel</span></code></a><a class="headerlink" href="#diffusionspectrumdeconvmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.dsi.</code><code class="descname">DiffusionSpectrumDeconvModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>qgrid_size=35</em>, <em>r_start=4.1</em>, <em>r_end=13.0</em>, <em>r_step=0.4</em>, <em>filter_width=inf</em>, <em>normalize_peaks=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.dsi.DiffusionSpectrumModel</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit" title="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>qgrid_size=35</em>, <em>r_start=4.1</em>, <em>r_end=13.0</em>, <em>r_step=0.4</em>, <em>filter_width=inf</em>, <em>normalize_peaks=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Diffusion Spectrum Deconvolution</p>
<p>The idea is to remove the convolution on the DSI propagator that is
caused by the truncation of the q-space in the DSI sampling.</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{eqnarray*}</dt>
<dd><p class="first last">P_{dsi}(mathbf{r}) &amp; = &amp; S_{0}^{-1}iiintlimits_{| mathbf{q} | le mathbf{q_{max}}} S(mathbf{q})exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} \
&amp; = &amp; S_{0}^{-1}iiintlimits_{mathbf{q}} left( S(mathbf{q}) cdot M(mathbf{q}) right) exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} \
&amp; = &amp; P(mathbf{r}) otimes left( S_{0}^{-1}iiintlimits_{mathbf{q}}  M(mathbf{q}) exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} right) \</p>
</dd>
</dl>
<p class="last">end{eqnarray*}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\mathbf{r}\)</span> is the displacement vector and <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> is the
wave vector which corresponds to different gradient directions,
<span class="math notranslate nohighlight">\(M(\mathbf{q})\)</span> is a mask corresponding to your q-space sampling and
<span class="math notranslate nohighlight">\(\otimes\)</span> is the convolution operator <a class="reference internal" href="#rb9b5836384d2-1" id="id278">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable,</span></dt>
<dd><p class="first last">Gradient directions and bvalues container class</p>
</dd>
<dt><strong>qgrid_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int,</span></dt>
<dd><p class="first last">has to be an odd number. Sets the size of the q_space grid.
For example if qgrid_size is 35 then the shape of the grid will be
<code class="docutils literal notranslate"><span class="pre">(35,</span> <span class="pre">35,</span> <span class="pre">35)</span></code>.</p>
</dd>
<dt><strong>r_start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">ODF is sampled radially in the PDF. This parameters shows where the
sampling should start.</p>
</dd>
<dt><strong>r_end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Radial endpoint of ODF sampling</p>
</dd>
<dt><strong>r_step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Step size of the ODf sampling from r_start to r_end</p>
</dd>
<dt><strong>filter_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Strength of the hanning filter</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb9b5836384d2-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id278">1</a>, <a class="fn-backref" href="#id279">2</a>)</em> Canales-Rodriguez E.J et al., Deconvolution in Diffusion</td></tr>
</tbody>
</table>
<p>Spectrum Imaging, Neuroimage, 2010.</p>
<table class="docutils citation" frame="void" id="rb9b5836384d2-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id280">[2]</a></td><td>Biggs David S.C. et al., Acceleration of Iterative Image</td></tr>
</tbody>
</table>
<p>Restoration Algorithms, Applied Optics, vol. 36, No. 8, p. 1766-1775,
1997.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffusionspectrumfit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="dipy.reconst.dsi.DiffusionSpectrumFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumFit</span></code></a><a class="headerlink" href="#diffusionspectrumfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.dsi.</code><code class="descname">DiffusionSpectrumFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfFit</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete" title="dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd_discrete</span></code></a>([normalized])</td>
<td>Calculates the mean squared displacement on the discrete propagator</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.odf" title="dipy.reconst.dsi.DiffusionSpectrumFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>Calculates the real discrete odf for a given discrete sphere</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.pdf" title="dipy.reconst.dsi.DiffusionSpectrumFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>([normalized])</td>
<td>Applies the 3D FFT in the q-space grid to generate the diffusion propagator</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf" title="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_pdf</span></code></a>([normalized])</td>
<td>Calculates the return to origin probability from the propagator, which is the propagator evaluated at zero (see Descoteaux et Al.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal" title="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_signal</span></code></a>([filtering])</td>
<td>Calculates the return to origin probability (rtop) from the signal rtop equals to the sum of all signal values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Calculates PDF and ODF and other properties for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">DiffusionSpectrumModel</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">signal values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete">
<code class="descname">msd_discrete</code><span class="sig-paren">(</span><em>normalized=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the mean squared displacement on the discrete propagator</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">MSD:{DSI}=int_{-infty}^{infty}int_{-infty}^{infty}int_{-infty}^{infty} P(hat{mathbf{r}}) cdot hat{mathbf{r}}^{2} dr_x dr_y dr_z</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\hat{\mathbf{r}}\)</span> is a point in the 3D Propagator space
(see Wu et al. <a class="reference internal" href="#rd62ffbcc354a-1" id="id281">[1]</a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>normalized</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">Whether to normalize the propagator by its sum in order to obtain a
pdf. Default: True</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>msd</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the mean square displacement</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd62ffbcc354a-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id281">1</a>, <a class="fn-backref" href="#id282">2</a>)</em> Wu Y. et al., Hybrid diffusion imaging, NeuroImage, vol 36,</td></tr>
</tbody>
</table>
<ol class="loweralpha simple" start="16">
<li>617-629, 2007.</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the real discrete odf for a given discrete sphere</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">psi_{DSI}(hat{mathbf{u}})=int_{0}^{infty}P(rhat{mathbf{u}})r^{2}dr</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\hat{\mathbf{u}}\)</span> is the unit vector which corresponds to a
sphere point.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.pdf">
<code class="descname">pdf</code><span class="sig-paren">(</span><em>normalized=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.pdf" title="Permalink to this definition"></a></dt>
<dd><p>Applies the 3D FFT in the q-space grid to generate
the diffusion propagator</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf">
<code class="descname">rtop_pdf</code><span class="sig-paren">(</span><em>normalized=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the return to origin probability from the propagator, which is
the propagator evaluated at zero (see Descoteaux et Al. <a class="reference internal" href="#rca1849cdf01b-1" id="id283">[1]</a>,
Tuch <a class="reference internal" href="#rca1849cdf01b-2" id="id284">[2]</a>, Wu et al. <a class="reference internal" href="#rca1849cdf01b-3" id="id285">[3]</a>)
rtop = P(0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>normalized</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">Whether to normalize the propagator by its sum in order to obtain a
pdf. Default: True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rtop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the return to origin probability</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rca1849cdf01b-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id283">1</a>, <a class="fn-backref" href="#id286">2</a>)</em> Descoteaux M. et al., Multiple q-shell diffusion propagator</td></tr>
</tbody>
</table>
<p>imaging, Medical Image Analysis, vol 15, No. 4, p. 603-621, 2011.</p>
<table class="docutils citation" frame="void" id="rca1849cdf01b-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id284">1</a>, <a class="fn-backref" href="#id287">2</a>)</em> Tuch D.S., Diffusion MRI of Complex Tissue Structure,
PhD Thesis, 2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rca1849cdf01b-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id285">1</a>, <a class="fn-backref" href="#id288">2</a>)</em> Wu Y. et al., Computation of Diffusion Function Measures</td></tr>
</tbody>
</table>
<p>in q -Space Using Magnetic Resonance Hybrid Diffusion Imaging,
IEEE TRANSACTIONS ON MEDICAL IMAGING, vol. 27, No. 6, p. 858-865, 2008</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal">
<code class="descname">rtop_signal</code><span class="sig-paren">(</span><em>filtering=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the return to origin probability (rtop) from the signal
rtop equals to the sum of all signal values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filtering</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">Whether to perform Hanning filtering. Default: True</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rtop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the return to origin probability</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffusionspectrummodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffusionSpectrumModel</span></code></a><a class="headerlink" href="#diffusionspectrummodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.DiffusionSpectrumModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.dsi.</code><code class="descname">DiffusionSpectrumModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>qgrid_size=17</em>, <em>r_start=2.1</em>, <em>r_end=6.0</em>, <em>r_step=0.2</em>, <em>filter_width=32</em>, <em>normalize_peaks=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.cache.Cache</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel.fit" title="dipy.reconst.dsi.DiffusionSpectrumModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>qgrid_size=17</em>, <em>r_start=2.1</em>, <em>r_end=6.0</em>, <em>r_step=0.2</em>, <em>filter_width=32</em>, <em>normalize_peaks=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Diffusion Spectrum Imaging</p>
<p>The theoretical idea underlying this method is that the diffusion
propagator <span class="math notranslate nohighlight">\(P(\mathbf{r})\)</span> (probability density function of the average
spin displacements) can be estimated by applying 3D FFT to the signal
values <span class="math notranslate nohighlight">\(S(\mathbf{q})\)</span></p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{eqnarray}</dt>
<dd><p class="first last">P(mathbf{r}) &amp; = &amp; S_{0}^{-1}int S(mathbf{q})exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{r}</p>
</dd>
</dl>
<p class="last">end{eqnarray}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\mathbf{r}\)</span> is the displacement vector and <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> is the
wave vector which corresponds to different gradient directions. Method
used to calculate the ODFs. Here we implement the method proposed by
Wedeen et al. <a class="reference internal" href="#rb4175f35d86a-1" id="id289">[1]</a>.</p>
<p>The main assumption for this model is fast gradient switching and that
the acquisition gradients will sit on a keyhole Cartesian grid in
q_space <a class="reference internal" href="#rb4175f35d86a-3" id="id290">[3]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable,</span></dt>
<dd><p class="first last">Gradient directions and bvalues container class</p>
</dd>
<dt><strong>qgrid_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int,</span></dt>
<dd><p class="first last">has to be an odd number. Sets the size of the q_space grid.
For example if qgrid_size is 17 then the shape of the grid will be
<code class="docutils literal notranslate"><span class="pre">(17,</span> <span class="pre">17,</span> <span class="pre">17)</span></code>.</p>
</dd>
<dt><strong>r_start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">ODF is sampled radially in the PDF. This parameters shows where the
sampling should start.</p>
</dd>
<dt><strong>r_end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Radial endpoint of ODF sampling</p>
</dd>
<dt><strong>r_step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Step size of the ODf sampling from r_start to r_end</p>
</dd>
<dt><strong>filter_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Strength of the hanning filter</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dipy.reconst.gqi.GeneralizedQSampling</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>A. Have in mind that DSI expects gradients on both hemispheres. If your
gradients span only one hemisphere you need to duplicate the data and
project them to the other hemisphere before calling this class. The
function dipy.reconst.dsi.half_to_full_qspace can be used for this
purpose.</p>
<p>B. If you increase the size of the grid (parameter qgrid_size) you will
most likely also need to update the r_* parameters. This is because
the added zero padding from the increase of gqrid_size also introduces
a scaling of the PDF.</p>
<ol class="upperalpha simple" start="3">
<li>We assume that data only one b0 volume is provided.</li>
</ol>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb4175f35d86a-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id289">1</a>, <a class="fn-backref" href="#id291">2</a>)</em> Wedeen V.J et al., Mapping Complex Tissue Architecture With</td></tr>
</tbody>
</table>
<p>Diffusion Spectrum Magnetic Resonance Imaging, MRM 2005.</p>
<table class="docutils citation" frame="void" id="rb4175f35d86a-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id292">[2]</a></td><td>Canales-Rodriguez E.J et al., Deconvolution in Diffusion</td></tr>
</tbody>
</table>
<p>Spectrum Imaging, Neuroimage, 2010.</p>
<table class="docutils citation" frame="void" id="rb4175f35d86a-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id290">1</a>, <a class="fn-backref" href="#id293">2</a>)</em> Garyfallidis E, Towards an accurate brain tractography, PhD</td></tr>
</tbody>
</table>
<p>thesis, University of Cambridge, 2012.</p>
<p class="rubric">Examples</p>
<p>In this example where we provide the data, a gradient table
and a reconstruction sphere, we calculate generalized FA for the first
voxel in the data with the reconstruction performed using DSI.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">dsi_voxels</span><span class="p">,</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">gtab</span> <span class="o">=</span> <span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;symmetric724&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.dsi</span> <span class="k">import</span> <span class="n">DiffusionSpectrumModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span> <span class="o">=</span> <span class="n">DiffusionSpectrumModel</span><span class="p">(</span><span class="n">gtab</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsfit</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.odf</span> <span class="k">import</span> <span class="n">gfa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">gfa</span><span class="p">(</span><span class="n">dsfit</span><span class="o">.</span><span class="n">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0.11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.DiffusionSpectrumModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.DiffusionSpectrumModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="odffit">
<h3><a class="reference internal" href="#dipy.reconst.dsi.OdfFit" title="dipy.reconst.dsi.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a><a class="headerlink" href="#odffit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.OdfFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.dsi.</code><code class="descname">OdfFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.OdfFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstFit</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.OdfFit.odf" title="dipy.reconst.dsi.OdfFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>To be implemented but specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.OdfFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.OdfFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.OdfFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.OdfFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="odfmodel">
<h3><a class="reference internal" href="#dipy.reconst.dsi.OdfModel" title="dipy.reconst.dsi.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a><a class="headerlink" href="#odfmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dsi.OdfModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.dsi.</code><code class="descname">OdfModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.OdfModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as its
first and only argument.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dsi.OdfModel.fit" title="dipy.reconst.dsi.OdfModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dsi.OdfModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.OdfModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dsi.OdfModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.OdfModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lr-deconv">
<h3>LR_deconv<a class="headerlink" href="#lr-deconv" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.LR_deconv">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">LR_deconv</code><span class="sig-paren">(</span><em>prop</em>, <em>psf</em>, <em>numit=5</em>, <em>acc_factor=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.LR_deconv" title="Permalink to this definition"></a></dt>
<dd><p>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>prop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3-D ndarray of dtype float</span></dt>
<dd><p class="first last">The 3D volume to be deconvolve</p>
</dd>
<dt><strong>psf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3-D ndarray of dtype float</span></dt>
<dd><p class="first last">The filter that will be used for the deconvolution.</p>
</dd>
<dt><strong>numit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of Lucy-Richardson iteration to perform.</p>
</dd>
<dt><strong>acc_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Exponential acceleration factor as in <a class="reference internal" href="#rc26f028c341d-1" id="id294">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rc26f028c341d-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id294">1</a>, <a class="fn-backref" href="#id295">2</a>)</em> Biggs David S.C. et al., Acceleration of Iterative Image
Restoration Algorithms, Applied Optics, vol. 36, No. 8, p. 1766-1775,
1997.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-qspace">
<h3>create_qspace<a class="headerlink" href="#create-qspace" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.create_qspace">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">create_qspace</code><span class="sig-paren">(</span><em>gtab</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.create_qspace" title="Permalink to this definition"></a></dt>
<dd><p>create the 3D grid which holds the signal values (q-space)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray</span></dt>
<dd><p class="first last">center of qspace</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qgrid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">qspace coordinates</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-qtable">
<h3>create_qtable<a class="headerlink" href="#create-qtable" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.create_qtable">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">create_qtable</code><span class="sig-paren">(</span><em>gtab</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.create_qtable" title="Permalink to this definition"></a></dt>
<dd><p>create a normalized version of gradients</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray</span></dt>
<dd><p class="first last">center of qspace</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qtable</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fftn">
<h3>fftn<a class="headerlink" href="#fftn" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.fftn">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">fftn</code><span class="sig-paren">(</span><em>x</em>, <em>shape=None</em>, <em>axes=None</em>, <em>overwrite_x=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.fftn" title="Permalink to this definition"></a></dt>
<dd><p>Return multidimensional discrete Fourier transform.</p>
<p>The returned array contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">[</span><span class="n">j_1</span><span class="p">,</span><span class="o">..</span><span class="p">,</span><span class="n">j_d</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">k_1</span><span class="o">=</span><span class="mf">0.</span><span class="o">.</span><span class="n">n_1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">k_d</span><span class="o">=</span><span class="mf">0.</span><span class="o">.</span><span class="n">n_d</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
   <span class="n">x</span><span class="p">[</span><span class="n">k_1</span><span class="p">,</span><span class="o">..</span><span class="p">,</span><span class="n">k_d</span><span class="p">]</span> <span class="o">*</span> <span class="n">prod</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mf">1.</span><span class="o">.</span><span class="n">d</span><span class="p">]</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">n_i</span> <span class="o">*</span> <span class="n">j_i</span> <span class="o">*</span> <span class="n">k_i</span><span class="p">)</span>
</pre></div>
</div>
<p>where d = len(x.shape) and n = x.shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">The (n-dimensional) array to transform.</p>
</dd>
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints, optional</span></dt>
<dd><p class="first last">The shape of the result.  If both <cite>shape</cite> and <cite>axes</cite> (see below) are
None, <cite>shape</cite> is <code class="docutils literal notranslate"><span class="pre">x.shape</span></code>; if <cite>shape</cite> is None but <cite>axes</cite> is
not None, then <cite>shape</cite> is <code class="docutils literal notranslate"><span class="pre">scipy.take(x.shape,</span> <span class="pre">axes,</span> <span class="pre">axis=0)</span></code>.
If <code class="docutils literal notranslate"><span class="pre">shape[i]</span> <span class="pre">&gt;</span> <span class="pre">x.shape[i]</span></code>, the i-th dimension is padded with zeros.
If <code class="docutils literal notranslate"><span class="pre">shape[i]</span> <span class="pre">&lt;</span> <span class="pre">x.shape[i]</span></code>, the i-th dimension is truncated to
length <code class="docutils literal notranslate"><span class="pre">shape[i]</span></code>.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of ints, optional</span></dt>
<dd><p class="first last">The axes of <cite>x</cite> (<cite>y</cite> if <cite>shape</cite> is not None) along which the
transform is applied.</p>
</dd>
<dt><strong>overwrite_x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, the contents of <cite>x</cite> can be destroyed.  Default is False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex-valued n-dimensional numpy array</span></dt>
<dd><p class="first last">The (n-dimensional) DFT of the input array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifftn</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is real-valued, then
<code class="docutils literal notranslate"><span class="pre">y[...,</span> <span class="pre">j_i,</span> <span class="pre">...]</span> <span class="pre">==</span> <span class="pre">y[...,</span> <span class="pre">n_i-j_i,</span> <span class="pre">...].conjugate()</span></code>.</p>
<p>Both single and double precision routines are implemented.  Half precision
inputs will be converted to single precision.  Non floating-point inputs
will be converted to double precision.  Long-double precision inputs are
not supported.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="k">import</span> <span class="n">fftn</span><span class="p">,</span> <span class="n">ifftn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">fftn</span><span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="fftshift">
<h3>fftshift<a class="headerlink" href="#fftshift" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.fftshift">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">fftshift</code><span class="sig-paren">(</span><em>x</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.fftshift" title="Permalink to this definition"></a></dt>
<dd><p>Shift the zero-frequency component to the center of the spectrum.</p>
<p>This function swaps half-spaces for all axes listed (defaults to all).
Note that <code class="docutils literal notranslate"><span class="pre">y[0]</span></code> is the Nyquist component only if <code class="docutils literal notranslate"><span class="pre">len(x)</span></code> is even.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Input array.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or shape tuple, optional</span></dt>
<dd><p class="first last">Axes over which to shift.  Default is None, which shifts all axes.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The shifted array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#dipy.reconst.dsi.ifftshift" title="dipy.reconst.dsi.ifftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifftshift</span></code></a></dt>
<dd>The inverse of <cite>fftshift</cite>.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>
<span class="go">array([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
<span class="go">array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</span>
</pre></div>
</div>
<p>Shift the zero-frequency component only along the second axis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -4.],</span>
<span class="go">       [-3., -2., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="go">array([[ 2.,  0.,  1.],</span>
<span class="go">       [-4.,  3.,  4.],</span>
<span class="go">       [-1., -3., -2.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gen-psf">
<h3>gen_PSF<a class="headerlink" href="#gen-psf" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.gen_PSF">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">gen_PSF</code><span class="sig-paren">(</span><em>qgrid_sampling</em>, <em>siz_x</em>, <em>siz_y</em>, <em>siz_z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.gen_PSF" title="Permalink to this definition"></a></dt>
<dd><p>Generate a PSF for DSI Deconvolution by taking the ifft of the binary
q-space sampling mask and truncating it to keep only the center.</p>
</dd></dl>

</div>
<div class="section" id="half-to-full-qspace">
<h3>half_to_full_qspace<a class="headerlink" href="#half-to-full-qspace" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.half_to_full_qspace">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">half_to_full_qspace</code><span class="sig-paren">(</span><em>data</em>, <em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.half_to_full_qspace" title="Permalink to this definition"></a></dt>
<dd><p>Half to full Cartesian grid mapping</p>
<p>Useful when dMRI data are provided in one qspace hemisphere as
DiffusionSpectrum expects data to be in full qspace.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (X, Y, Z, W)</span></dt>
<dd><p class="first last">where (X, Y, Z) volume size and W number of gradient directions</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd><p class="first last">container for b-values and b-vectors (gradient directions)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (X, Y, Z, 2 * W -1)</span></dt>
<dd></dd>
<dt><strong>new_gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We assume here that only on b0 is provided with the initial data. If that
is not the case then you will need to write your own preparation function
before providing the gradients and the data to the DiffusionSpectrumModel
class.</p>
</dd></dl>

</div>
<div class="section" id="hanning-filter">
<h3>hanning_filter<a class="headerlink" href="#hanning-filter" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.hanning_filter">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">hanning_filter</code><span class="sig-paren">(</span><em>gtab</em>, <em>filter_width</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.hanning_filter" title="Permalink to this definition"></a></dt>
<dd><p>create a hanning window</p>
<p>The signal is premultiplied by a Hanning window before
Fourier transform in order to ensure a smooth attenuation
of the signal at high q values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd></dd>
<dt><strong>filter_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd></dd>
<dt><strong>origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray</span></dt>
<dd><p class="first last">center of qspace</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last">where N is the number of non-b0 gradient directions</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ifftshift">
<h3>ifftshift<a class="headerlink" href="#ifftshift" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.ifftshift">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">ifftshift</code><span class="sig-paren">(</span><em>x</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.ifftshift" title="Permalink to this definition"></a></dt>
<dd><p>The inverse of <cite>fftshift</cite>. Although identical for even-length <cite>x</cite>, the
functions differ by one sample for odd-length <cite>x</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Input array.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or shape tuple, optional</span></dt>
<dd><p class="first last">Axes over which to calculate.  Defaults to None, which shifts all axes.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The shifted array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#dipy.reconst.dsi.fftshift" title="dipy.reconst.dsi.fftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fftshift</span></code></a></dt>
<dd>Shift zero-frequency component to the center of the spectrum.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -4.],</span>
<span class="go">       [-3., -2., -1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -4.],</span>
<span class="go">       [-3., -2., -1.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="map-coordinates">
<h3>map_coordinates<a class="headerlink" href="#map-coordinates" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.map_coordinates">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">map_coordinates</code><span class="sig-paren">(</span><em>input</em>, <em>coordinates</em>, <em>output=None</em>, <em>order=3</em>, <em>mode='constant'</em>, <em>cval=0.0</em>, <em>prefilter=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.map_coordinates" title="Permalink to this definition"></a></dt>
<dd><p>Map the input array to new coordinates by interpolation.</p>
<p>The array of coordinates is used to find, for each point in the output,
the corresponding coordinates in the input. The value of the input at
those coordinates is determined by spline interpolation of the
requested order.</p>
<p>The shape of the output is derived from that of the coordinate
array by dropping the first axis. The values of the array along
the first axis are the coordinates in the input array at which the
output value is found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>input</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">The input array.</p>
</dd>
<dt><strong>coordinates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">The coordinates at which <cite>input</cite> is evaluated.</p>
</dd>
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or dtype, optional</span></dt>
<dd><p class="first last">The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{reflect, constant, nearest, mirror, wrap}, optional</span></dt>
<dd><p class="first">The <cite>mode</cite> parameter determines how the input array is extended
when the filter overlaps a border. Default is reflect. Behavior
for each valid value is as follows:</p>
<dl class="last docutils">
<dt>reflect (<cite>d c b a | a b c d | d c b a</cite>)</dt>
<dd><p class="first last">The input is extended by reflecting about the edge of the last
pixel.</p>
</dd>
<dt>constant (<cite>k k k k | a b c d | k k k k</cite>)</dt>
<dd><p class="first last">The input is extended by filling all values beyond the edge with
the same constant value, defined by the <cite>cval</cite> parameter.</p>
</dd>
<dt>nearest (<cite>a a a a | a b c d | d d d d</cite>)</dt>
<dd><p class="first last">The input is extended by replicating the last pixel.</p>
</dd>
<dt>mirror (<cite>d c b | a b c d | c b a</cite>)</dt>
<dd><p class="first last">The input is extended by reflecting about the center of the last
pixel.</p>
</dd>
<dt>wrap (<cite>a b c d | a b c d | a b c d</cite>)</dt>
<dd><p class="first last">The input is extended by wrapping around to the opposite edge.</p>
</dd>
</dl>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first last">Value to fill past edges of input if <cite>mode</cite> is constant. Default
is 0.0.</p>
</dd>
<dt><strong>prefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Determines if the input array is prefiltered with <cite>spline_filter</cite>
before interpolation. The default is True, which will create a
temporary <cite>float64</cite> array of filtered values if <cite>order &gt; 1</cite>. If
setting this to False, the output will be slightly blurred if
<cite>order &gt; 1</cite>, unless the input is prefiltered, i.e. it is the result
of calling <cite>spline_filter</cite> on the original input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>map_coordinates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The result of transforming the input. The shape of the output is
derived from that of <cite>coordinates</cite> by dropping the first axis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spline_filter</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">geometric_transform</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.interpolate</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[  0.,   1.,   2.],</span>
<span class="go">       [  3.,   4.,   5.],</span>
<span class="go">       [  6.,   7.,   8.],</span>
<span class="go">       [  9.,  10.,  11.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 2.,  7.])</span>
</pre></div>
</div>
<p>Above, the interpolated value of a[0.5, 0.5] gives output[0], while
a[2, 1] is output[1].</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=-</span><span class="mf">33.3</span><span class="p">)</span>
<span class="go">array([  2. , -33.3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
<span class="go">array([ 2.,  8.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="go">array([ True, False], dtype=bool)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id296">
<h3>multi_voxel_fit<a class="headerlink" href="#id296" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.multi_voxel_fit">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="pdf-interp-coords">
<h3>pdf_interp_coords<a class="headerlink" href="#pdf-interp-coords" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.pdf_interp_coords">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">pdf_interp_coords</code><span class="sig-paren">(</span><em>sphere</em>, <em>rradius</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.pdf_interp_coords" title="Permalink to this definition"></a></dt>
<dd><p>Precompute coordinates for ODF calculation from the PDF</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">Sphere</p>
</dd>
<dt><strong>rradius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,)</span></dt>
<dd><p class="first last">line interpolation points</p>
</dd>
<dt><strong>origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (3,)</span></dt>
<dd><p class="first last">center of the grid</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pdf-odf">
<h3>pdf_odf<a class="headerlink" href="#pdf-odf" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.pdf_odf">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">pdf_odf</code><span class="sig-paren">(</span><em>Pr</em>, <em>rradius</em>, <em>interp_coords</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.pdf_odf" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the real ODF from the diffusion propagator(PDF) Pr</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Pr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (X, X, X)</span></dt>
<dd><p class="first last">probability density function</p>
</dd>
<dt><strong>rradius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,)</span></dt>
<dd><p class="first last">interpolation range on the radius</p>
</dd>
<dt><strong>interp_coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (3, M, N)</span></dt>
<dd><p class="first last">coordinates in the pdf for interpolating the odf</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="project-hemisph-bvecs">
<h3>project_hemisph_bvecs<a class="headerlink" href="#project-hemisph-bvecs" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.project_hemisph_bvecs">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">project_hemisph_bvecs</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.project_hemisph_bvecs" title="Permalink to this definition"></a></dt>
<dd><p>Project any near identical bvecs to the other hemisphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">GradientTable</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Useful only when working with some types of dsi data.</p>
</dd></dl>

</div>
<div class="section" id="setup-test">
<h3>setup_test<a class="headerlink" href="#setup-test" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.setup_test">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">setup_test</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.setup_test" title="Permalink to this definition"></a></dt>
<dd><p>Set numpy print options to legacy for new versions of numpy</p>
<p>If imported into a file, nosetest will run this before any doctests.</p>
<p class="rubric">References</p>
<p><a class="reference external" href="https://github.com/numpy/numpy/commit/710e0327687b9f7653e5ac02d222ba62c657a718">https://github.com/numpy/numpy/commit/710e0327687b9f7653e5ac02d222ba62c657a718</a>
<a class="reference external" href="https://github.com/numpy/numpy/commit/734b907fc2f7af6e40ec989ca49ee6d87e21c495">https://github.com/numpy/numpy/commit/734b907fc2f7af6e40ec989ca49ee6d87e21c495</a>
<a class="reference external" href="https://github.com/nipy/nibabel/pull/556">https://github.com/nipy/nibabel/pull/556</a></p>
</dd></dl>

</div>
<div class="section" id="threshold-propagator">
<h3>threshold_propagator<a class="headerlink" href="#threshold-propagator" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dsi.threshold_propagator">
<code class="descclassname">dipy.reconst.dsi.</code><code class="descname">threshold_propagator</code><span class="sig-paren">(</span><em>P</em>, <em>estimated_snr=15.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dsi.threshold_propagator" title="Permalink to this definition"></a></dt>
<dd><p>Applies hard threshold on the propagator to remove background noise for the
deconvolution.</p>
</dd></dl>

</div>
<div class="section" id="id297">
<h3><a class="reference internal" href="#dipy.reconst.dti.ReconstModel" title="dipy.reconst.dti.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#id297" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dti.ReconstModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.dti.</code><code class="descname">ReconstModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.ReconstModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dti.ReconstModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.ReconstModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.ReconstModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.ReconstModel.fit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id298">
<h3><a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a><a class="headerlink" href="#id298" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dti.TensorFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.dti.</code><code class="descname">TensorFit</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em>, <em>model_S0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S0_hat</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.dti.TensorFit.directions" title="dipy.reconst.dti.TensorFit.directions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></a></dt>
<dd><p class="first last">For tracking - return the primary direction in each voxel</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dti.TensorFit.evals" title="dipy.reconst.dti.TensorFit.evals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></a></dt>
<dd><p class="first last">Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dti.TensorFit.evecs" title="dipy.reconst.dti.TensorFit.evecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></a></dt>
<dd><p class="first last">Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.dti.TensorFit.quadratic_form" title="dipy.reconst.dti.TensorFit.quadratic_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></a></dt>
<dd><p class="first last">Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.ad" title="dipy.reconst.dti.TensorFit.ad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code></a>()</td>
<td>Axial diffusivity (AD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.adc" title="dipy.reconst.dti.TensorFit.adc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code></a>(sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction on</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.color_fa" title="dipy.reconst.dti.TensorFit.color_fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code></a>()</td>
<td>Color fractional anisotropy of diffusion tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.fa" title="dipy.reconst.dti.TensorFit.fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code></a>()</td>
<td>Fractional anisotropy (FA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.ga" title="dipy.reconst.dti.TensorFit.ga"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code></a>()</td>
<td>Geodesic anisotropy (GA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.linearity" title="dipy.reconst.dti.TensorFit.linearity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.md" title="dipy.reconst.dti.TensorFit.md"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code></a>()</td>
<td>Mean diffusivity (MD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.mode" title="dipy.reconst.dti.TensorFit.mode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code></a>()</td>
<td>Tensor mode calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.odf" title="dipy.reconst.dti.TensorFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>The diffusion orientation distribution function (dODF).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.planarity" title="dipy.reconst.dti.TensorFit.planarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.predict" title="dipy.reconst.dti.TensorFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab[,&nbsp;S0,&nbsp;step])</td>
<td>Given a model fit, predict the signal on the vertices of a sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.rd" title="dipy.reconst.dti.TensorFit.rd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code></a>()</td>
<td>Radial diffusivity (RD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.sphericity" title="dipy.reconst.dti.TensorFit.sphericity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorFit.trace" title="dipy.reconst.dti.TensorFit.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>()</td>
<td>Trace of the tensor calculated from cached eigenvalues.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>lower_triangular</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em>, <em>model_S0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a TensorFit class instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.S0_hat">
<code class="descname">S0_hat</code><a class="headerlink" href="#dipy.reconst.dti.TensorFit.S0_hat" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.ad">
<code class="descname">ad</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.ad" title="Permalink to this definition"></a></dt>
<dd><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated AD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>RD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[AD = \lambda_1\]</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.adc">
<code class="descname">adc</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.adc" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Calculate the apparent diffusion coefficient (ADC) in each direction on
the sphere for each voxel in the data</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The estimates of the apparent diffusion coefficient in every
direction on the input sphere</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>ec{b} Q 
ec{b}^T</p>
<blockquote>
<div>Where Q is the quadratic form of the tensor.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.color_fa">
<code class="descname">color_fa</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.color_fa" title="Permalink to this definition"></a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.directions">
<code class="descname">directions</code><a class="headerlink" href="#dipy.reconst.dti.TensorFit.directions" title="Permalink to this definition"></a></dt>
<dd><p>For tracking - return the primary direction in each voxel</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.evals">
<code class="descname">evals</code><a class="headerlink" href="#dipy.reconst.dti.TensorFit.evals" title="Permalink to this definition"></a></dt>
<dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.evecs">
<code class="descname">evecs</code><a class="headerlink" href="#dipy.reconst.dti.TensorFit.evecs" title="Permalink to this definition"></a></dt>
<dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.fa">
<code class="descname">fa</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.fa" title="Permalink to this definition"></a></dt>
<dd><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.ga">
<code class="descname">ga</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.ga" title="Permalink to this definition"></a></dt>
<dd><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.linearity">
<code class="descname">linearity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.linearity" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>linearity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated linearity of the diffusion tensor <a class="footnote-reference" href="#id344" id="id299">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1-lambda_2}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.lower_triangular">
<code class="descname">lower_triangular</code><span class="sig-paren">(</span><em>b0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.lower_triangular" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.md">
<code class="descname">md</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.md" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Mean diffusivity (MD) calculated from cached eigenvalues.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated MD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1+lambda_2+lambda_3}{3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.mode">
<code class="descname">mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.mode" title="Permalink to this definition"></a></dt>
<dd><p>Tensor mode calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>The diffusion orientation distribution function (dODF). This is an
estimate of the diffusion distance in each direction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance.</span></dt>
<dd><p class="first last">The dODF is calculated in the vertices of this input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The diffusion distance in every direction of the sphere in every
voxel in the input data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is based on equation 3 in <a class="reference internal" href="#r0c640848df6f-aganj2010" id="id300">[Aganj2010]</a>. To re-derive it from
scratch, follow steps in <a class="reference internal" href="#r0c640848df6f-descoteaux2008" id="id301">[Descoteaux2008]</a>, Section 7.9 Equation
7.24 but with an <span class="math notranslate nohighlight">\(r^2\)</span> term in the integral.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r0c640848df6f-aganj2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Aganj2010]</td><td><em>(<a class="fn-backref" href="#id300">1</a>, <a class="fn-backref" href="#id302">2</a>)</em> Aganj, I., Lenglet, C., Sapiro, G., Yacoub, E., Ugurbil,
K., &amp; Harel, N. (2010). Reconstruction of the orientation
distribution function in single- and multiple-shell q-ball imaging
within constant solid angle. Magnetic Resonance in Medicine, 64(2),
554-566. doi:DOI: 10.1002/mrm.22365</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r0c640848df6f-descoteaux2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Descoteaux2008]</td><td><em>(<a class="fn-backref" href="#id301">1</a>, <a class="fn-backref" href="#id303">2</a>)</em> Descoteaux, M. (2008). PhD Thesis: High Angular
Resolution Diffusion MRI: from Local Estimation to Segmentation and
Tractography. <a class="reference external" href="ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf">ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.planarity">
<code class="descname">planarity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.planarity" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphericity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated sphericity of the diffusion tensor <a class="footnote-reference" href="#id344" id="id304">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{2 (lambda_2 - lambda_3)}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab</em>, <em>S0=None</em>, <em>step=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Given a model fit, predict the signal on the vertices of a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">This encodes the directions for which a prediction is made</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">The mean non-diffusion weighted signal in each voxel. Default:
The fitted S0 value in all voxels if it was fitted. Otherwise 1 in
all voxels.</p>
</dd>
<dt><strong>step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">The chunk size as a number of voxels. Optional parameter with
default value 10,000.</p>
<p class="last">In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. This parameter sets the number of
voxels that will be fit at once in each iteration. A larger step
value should speed things up, but it will also take up more memory.
It is advisable to keep an eye on memory consumption as this value
is increased.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S(  heta, b) = S_0 * e^{-b ADC}\]</div>
<p>Where:
.. math</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ADC</span> <span class="o">=</span>       <span class="n">heta</span> <span class="n">Q</span>  <span class="n">heta</span><span class="o">^</span><span class="n">T</span>
</pre></div>
</div>
<p>:math:`       heta` is a unit vector pointing at any direction on the sphere for
which a signal is to be predicted and <span class="math notranslate nohighlight">\(b\)</span> is the b value provided in
the GradientTable input for that direction</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.quadratic_form">
<code class="descname">quadratic_form</code><a class="headerlink" href="#dipy.reconst.dti.TensorFit.quadratic_form" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.rd">
<code class="descname">rd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.rd" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Radial diffusivity (RD) calculated from cached eigenvalues.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rd</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated RD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_2 + lambda_3}{2}</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.TensorFit.shape">
<code class="descname">shape</code><a class="headerlink" href="#dipy.reconst.dti.TensorFit.shape" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.sphericity">
<code class="descname">sphericity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.sphericity" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphericity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated sphericity of the diffusion tensor <a class="footnote-reference" href="#id344" id="id305">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{3 lambda_3}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorFit.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorFit.trace" title="Permalink to this definition"></a></dt>
<dd><p>Trace of the tensor calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated trace.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The trace is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[trace = \lambda_1 + \lambda_2 + \lambda_3\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id306">
<h3><a class="reference internal" href="#dipy.reconst.dti.TensorModel" title="dipy.reconst.dti.TensorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorModel</span></code></a><a class="headerlink" href="#id306" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dti.TensorModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.dti.</code><code class="descname">TensorModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>return_S0_hat=False</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>Diffusion Tensor</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.TensorModel.fit" title="dipy.reconst.dti.TensorModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method of the DTI model class</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.TensorModel.predict" title="dipy.reconst.dti.TensorModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(dti_params[,&nbsp;S0])</td>
<td>Predict a signal for this TensorModel class instance given parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dti.TensorModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='WLS'</em>, <em>return_S0_hat=False</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>A Diffusion Tensor Model <a class="reference internal" href="#r9aa998fac9a2-1" id="id307">[1]</a>, <a class="reference internal" href="#r9aa998fac9a2-2" id="id308">[2]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>fit_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or callable</span></dt>
<dd><p class="first">str can be one of the following:</p>
<dl class="last docutils">
<dt>WLS for weighted least squares</dt>
<dd><p class="first last"><code class="xref py py-func docutils literal notranslate"><span class="pre">dti.wls_fit_tensor()</span></code></p>
</dd>
<dt>LS or OLS for ordinary least squares</dt>
<dd><p class="first last"><code class="xref py py-func docutils literal notranslate"><span class="pre">dti.ols_fit_tensor()</span></code></p>
</dd>
<dt>NLLS for non-linear least-squares</dt>
<dd><p class="first last"><code class="xref py py-func docutils literal notranslate"><span class="pre">dti.nlls_fit_tensor()</span></code></p>
</dd>
<dt>RT or restore or RESTORE for RESTORE robust tensor</dt>
<dd><p class="first last">fitting <a class="reference internal" href="#r9aa998fac9a2-3" id="id309">[3]</a>
<code class="xref py py-func docutils literal notranslate"><span class="pre">dti.restore_fit_tensor()</span></code></p>
</dd>
<dt>callable has to have the signature:</dt>
<dd><p class="first last">fit_method(design_matrix, data, <a href="#id310"><span class="problematic" id="id311">*</span></a>args, <a href="#id312"><span class="problematic" id="id313">**</span></a>kwargs)</p>
</dd>
</dl>
</dd>
<dt><strong>return_S0_hat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
<dt><strong>args, kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">arguments and key-word arguments passed to the</span></dt>
<dd><p class="first last">fit_method. See dti.wls_fit_tensor, dti.ols_fit_tensor for details</p>
</dd>
<dt><strong>min_signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum signal value. Needs to be a strictly positive
number. Default: minimal signal in the data provided to <cite>fit</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. Many fit_methods use the step
parameter to set the number of voxels that will be fit at once in each
iteration. This is the chunk size as a number of voxels. A larger step
value should speed things up, but it will also take up more memory. It
is advisable to keep an eye on memory consumption as this value is
increased.</p>
<p>Example : In <a class="reference internal" href="#dipy.reconst.dti.iter_fit_tensor" title="dipy.reconst.dti.iter_fit_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter_fit_tensor()</span></code></a> we have a default step value of
1e4</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r9aa998fac9a2-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id307">1</a>, <a class="fn-backref" href="#id314">2</a>)</em> Basser, P.J., Mattiello, J., LeBihan, D., 1994. Estimation of
the effective self-diffusion tensor from the NMR spin echo. J Magn
Reson B 103, 247-254.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r9aa998fac9a2-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id308">1</a>, <a class="fn-backref" href="#id315">2</a>)</em> Basser, P., Pierpaoli, C., 1996. Microstructural and
physiological features of tissues elucidated by quantitative
diffusion-tensor MRI.  Journal of Magnetic Resonance 111, 209-219.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r9aa998fac9a2-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id309">1</a>, <a class="fn-backref" href="#id316">2</a>)</em> Lin-Ching C., Jones D.K., Pierpaoli, C. 2005. RESTORE: Robust
estimation of tensors by outlier rejection. MRM 53: 1088-1095</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method of the DTI model class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The measured signal from one voxel.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that
should be analyzed that has the shape data.shape[:-1]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.TensorModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>dti_params</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.TensorModel.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict a signal for this TensorModel class instance given parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dti_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The last dimension should have 12 tensor parameters: 3
eigenvalues, followed by the 3 eigenvectors</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id317">
<h3><a class="reference internal" href="#dipy.reconst.dti.range" title="dipy.reconst.dti.range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a><a class="headerlink" href="#id317" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.dti.range">
<em class="property">class </em><code class="descclassname">dipy.reconst.dti.</code><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span> &#x2192; range object<a class="headerlink" href="#dipy.reconst.dti.range" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>range(start, stop[, step]) -&gt; range object</p>
<p>Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, , j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>start</strong></dt>
<dd></dd>
<dt><strong>step</strong></dt>
<dd></dd>
<dt><strong>stop</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.dti.range.count" title="dipy.reconst.dti.range.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(value)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.dti.range.index" title="dipy.reconst.dti.range.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(value,&nbsp;[start,&nbsp;[stop]])</td>
<td>Raise ValueError if the value is not present.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.dti.range.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.range.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.range.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span> &#x2192; integer -- return number of occurrences of value<a class="headerlink" href="#dipy.reconst.dti.range.count" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.dti.range.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>stop</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; integer -- return index of value.<a class="headerlink" href="#dipy.reconst.dti.range.index" title="Permalink to this definition"></a></dt>
<dd><p>Raise ValueError if the value is not present.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.range.start">
<code class="descname">start</code><a class="headerlink" href="#dipy.reconst.dti.range.start" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.range.step">
<code class="descname">step</code><a class="headerlink" href="#dipy.reconst.dti.range.step" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.dti.range.stop">
<code class="descname">stop</code><a class="headerlink" href="#dipy.reconst.dti.range.stop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="apparent-diffusion-coef">
<h3>apparent_diffusion_coef<a class="headerlink" href="#apparent-diffusion-coef" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.apparent_diffusion_coef">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">apparent_diffusion_coef</code><span class="sig-paren">(</span><em>q_form</em>, <em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.apparent_diffusion_coef" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Calculate the apparent diffusion coefficient (ADC) in each direction of a
sphere.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>q_form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><blockquote class="first">
<div><p>The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (, 3, 3)</p>
</div></blockquote>
<dl class="last docutils">
<dt>sphere <span class="classifier-delimiter">:</span> <span class="classifier">a Sphere class instance</span></dt>
<dd><p class="first last">The ADC will be calculated for each of the vertices in the sphere</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>ec{b} Q 
ec{b}^T</p>
<blockquote>
<div>Where Q is the quadratic form of the tensor.</div></blockquote>
</dd></dl>

</div>
<div class="section" id="id318">
<h3>auto_attr<a class="headerlink" href="#id318" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.auto_attr">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">auto_attr</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.auto_attr" title="Permalink to this definition"></a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">The method that will be called the first time to compute a value.
Afterwards, the methods name will be a standard attribute holding the
value of this computation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id319">
<h3>axial_diffusivity<a class="headerlink" href="#id319" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.axial_diffusivity">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">axial_diffusivity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.axial_diffusivity" title="Permalink to this definition"></a></dt>
<dd><p>Axial Diffusivity (AD) of a diffusion tensor.
Also called parallel diffusivity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><p class="first last">Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated AD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>AD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[AD = \lambda_1\]</div>
</dd></dl>

</div>
<div class="section" id="color-fa">
<h3>color_fa<a class="headerlink" href="#color-fa" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.color_fa">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">color_fa</code><span class="sig-paren">(</span><em>fa</em>, <em>evecs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.color_fa" title="Permalink to this definition"></a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Array of the fractional anisotropy (can be 1D, 2D or 3D)</p>
</div></blockquote>
<dl class="last docutils">
<dt>evecs <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><p class="first last">eigen vectors from the tensor model</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rgb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Array with 3 channels for each color as the last dimension.</span></dt>
<dd><p class="first last">Colormap of the FA with red for the x value, y for the green
value and z for the blue value.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>ec{e}))  imes fa</p>
</dd></dl>

</div>
<div class="section" id="id320">
<h3>decompose_tensor<a class="headerlink" href="#id320" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.decompose_tensor">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">decompose_tensor</code><span class="sig-paren">(</span><em>tensor</em>, <em>min_diffusivity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.decompose_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>
<p>Computes tensor eigen decomposition to calculate eigenvalues and
eigenvectors (Basser et al., 1994a).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Hermitian matrix representing a diffusion tensor.</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3)</span></dt>
<dd><p class="first last">Eigenvalues from eigen decomposition of the tensor. Negative
eigenvalues are replaced by zero. Sorted from largest to smallest.</p>
</dd>
<dt><strong>eigvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[, :, j] is associated with
eigvals[, j])</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id321">
<h3>design_matrix<a class="headerlink" href="#id321" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.design_matrix">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">design_matrix</code><span class="sig-paren">(</span><em>gtab</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.design_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Constructs design matrix for DTI weighted least squares or
least squares fitting. (Basser et al., 1994a)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">A GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Parameter to control the dtype of returned designed matrix</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g,7)</span></dt>
<dd><p class="first last">Design matrix or B matrix assuming Gaussian distributed tensor model
design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="determinant">
<h3>determinant<a class="headerlink" href="#determinant" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.determinant">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">determinant</code><span class="sig-paren">(</span><em>q_form</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.determinant" title="Permalink to this definition"></a></dt>
<dd><p>The determinant of a tensor, given in quadratic form</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q_form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>det</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The determinant of the tensor in each spatial coordinate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="deviatoric">
<h3>deviatoric<a class="headerlink" href="#deviatoric" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.deviatoric">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">deviatoric</code><span class="sig-paren">(</span><em>q_form</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.deviatoric" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the deviatoric (anisotropic) part of the tensor <a class="reference internal" href="#rfe2215338679-1" id="id322">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q_form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A_squiggle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The deviatoric part of the tensor in each spatial coordinate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The deviatoric part of the tensor is defined as (equations 3-5 in <a class="reference internal" href="#rfe2215338679-1" id="id323">[1]</a>):</p>
<div class="math notranslate nohighlight">
\[\widetilde{A} = A - ar{A}\]</div>
<p>Where <span class="math notranslate nohighlight">\(A\)</span> is the tensor quadratic form and <span class="math notranslate nohighlight">\(ar{A}\)</span> is the anisotropic
part of the tensor.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rfe2215338679-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id17">1</a>, <a class="fn-backref" href="#id322">2</a>, <a class="fn-backref" href="#id323">3</a>, <a class="fn-backref" href="#id324">4</a>)</em> Daniel B. Ennis and G. Kindlmann, Orthogonal Tensor
Invariants and the Analysis of Diffusion Tensor Magnetic Resonance
Images, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,
2006.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="eig-from-lo-tri">
<h3>eig_from_lo_tri<a class="headerlink" href="#eig-from-lo-tri" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.eig_from_lo_tri">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">eig_from_lo_tri</code><span class="sig-paren">(</span><em>data</em>, <em>min_diffusivity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.eig_from_lo_tri" title="Permalink to this definition"></a></dt>
<dd><p>Calculates tensor eigenvalues/eigenvectors from an array containing the
lower diagonal form of the six unique tensor elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, 6)</span></dt>
<dd><p class="first last">diffusion tensors elements stored in lower triangular order</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">See decompose_tensor()</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dti_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 12)</span></dt>
<dd><p class="first last">Eigen-values and eigen-vectors of the same array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="eigh">
<h3>eigh<a class="headerlink" href="#eigh" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.eigh">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">eigh</code><span class="sig-paren">(</span><em>a</em>, <em>UPLO='L'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.eigh" title="Permalink to this definition"></a></dt>
<dd><p>Iterate over <cite>np.linalg.eigh</cite> if it doesnt support vectorized operation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, M, M)</span></dt>
<dd><p class="first last">Hermitian/Symmetric matrices whose eigenvalues and
eigenvectors are to be computed.</p>
</dd>
<dt><strong>UPLO</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{L, U}, optional</span></dt>
<dd><p class="first last">Specifies whether the calculation is done with the lower triangular
part of <cite>a</cite> (L, default) or the upper triangular part (U).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>w</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (, M)</span></dt>
<dd><p class="first last">The eigenvalues in ascending order, each repeated according to
its multiplicity.</p>
</dd>
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (, M, M)</span></dt>
<dd><p class="first last">The column <code class="docutils literal notranslate"><span class="pre">v[...,</span> <span class="pre">:,</span> <span class="pre">i]</span></code> is the normalized eigenvector corresponding
to the eigenvalue <code class="docutils literal notranslate"><span class="pre">w[...,</span> <span class="pre">i]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>LinAlgError</strong></dt>
<dd><p class="first last">If the eigenvalue computation does not converge.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.linalg.eigh</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="id325">
<h3>fractional_anisotropy<a class="headerlink" href="#id325" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.fractional_anisotropy">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">fractional_anisotropy</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.fractional_anisotropy" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Fractional anisotropy (FA) of a diffusion tensor.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{1}{2}
rac{(lambda_1-lambda_2)^2+(lambda_1-</p>
<blockquote>
<div>lambda_3)^2+(lambda_2-lambda_3)^2}{lambda_1^2+
lambda_2^2+lambda_3^2}}</div></blockquote>
</dd></dl>

</div>
<div class="section" id="id326">
<h3>from_lower_triangular<a class="headerlink" href="#id326" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.from_lower_triangular">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">from_lower_triangular</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.from_lower_triangular" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tensor given the six unique tensor elements</p>
<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,
Dyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are
ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, (, &gt;6)</span></dt>
<dd><p class="first last">Unique elements of the tensors</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (, 3, 3)</span></dt>
<dd><p class="first last">3 by 3 tensors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="geodesic-anisotropy">
<h3>geodesic_anisotropy<a class="headerlink" href="#geodesic-anisotropy" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.geodesic_anisotropy">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">geodesic_anisotropy</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.geodesic_anisotropy" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Geodesic anisotropy (GA) of a diffusion tensor.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ga</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated GA. In the range 0 to +infinity</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>ight )}},</dt>
<dd><blockquote class="first">
<div>quad   extrm{where} quad &lt;mathbf{D}&gt; =
(lambda_1lambda_2lambda_3)^{1/3}</div></blockquote>
<p class="last">Note that the notation, <span class="math notranslate nohighlight">\(&lt;D&gt;\)</span>, is often used as the mean diffusivity (MD)
of the diffusion tensor and can lead to confusions in the literature
(see [R12155c045a58-1] versus [R12155c045a58-2] versus [R12155c045a58-3] for example). Reference [R12155c045a58-2] defines
geodesic anisotropy (GA) with <span class="math notranslate nohighlight">\(&lt;D&gt;\)</span> as the MD in the denominator of the
sum. This is wrong. The original paper [R12155c045a58-1] defines GA with
<span class="math notranslate nohighlight">\(&lt;D&gt; = det(D)^{1/3}\)</span>, as the isotropic part of the distance. This might be
an explanation for the confusion. The isotropic part of the diffusion
tensor in Euclidean space is the MD whereas the isotropic part of the
tensor in log-Euclidean space is <span class="math notranslate nohighlight">\(det(D)^{1/3}\)</span>. The Appendix of [R12155c045a58-1] and
log-Euclidean derivations from [R12155c045a58-3] are clear on this. Hence, all that to
say that <span class="math notranslate nohighlight">\(&lt;D&gt; = det(D)^{1/3}\)</span> here for the GA definition and not MD.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id334">
<h3>get_sphere<a class="headerlink" href="#id334" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.get_sphere">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">get_sphere</code><span class="sig-paren">(</span><em>name='symmetric362'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.get_sphere" title="Permalink to this definition"></a></dt>
<dd><p>provide triangulated spheres</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">which sphere - one of:
* symmetric362
* symmetric642
* symmetric724
* repulsion724
* repulsion100
* repulsion200</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a dipy.core.sphere.Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;symmetric362&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">sphere</span><span class="o">.</span><span class="n">faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">362</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">720</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;not a sphere name&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">DataError</span>: <span class="n">No sphere called &quot;not a sphere name&quot;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gradient-table">
<h3>gradient_table<a class="headerlink" href="#gradient-table" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.gradient_table">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">gradient_table</code><span class="sig-paren">(</span><em>bvals</em>, <em>bvecs=None</em>, <em>big_delta=None</em>, <em>small_delta=None</em>, <em>b0_threshold=50</em>, <em>atol=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.gradient_table" title="Permalink to this definition"></a></dt>
<dd><p>A general function for creating diffusion MR gradients.</p>
<p>It reads, loads and prepares scanner parameters like the b-values and
b-vectors so that they can be useful during the reconstruction process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">can be any of the four options</span></dt>
<dd><ol class="first last arabic simple">
<li>an array of shape (N,) or (1, N) or (N, 1) with the b-values.</li>
<li>a path for the file which contains an array like the above (1).</li>
<li>an array of shape (N, 4) or (4, N). Then this parameter is
considered to be a b-table which contains both bvals and bvecs. In
this case the next parameter is skipped.</li>
<li>a path for the file which contains an array like the one at (3).</li>
</ol>
</dd>
<dt><strong>bvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">can be any of two options</span></dt>
<dd><ol class="first last arabic simple">
<li>an array of shape (N, 3) or (3, N) with the b-vectors.</li>
<li>a path for the file which contains an array like the previous.</li>
</ol>
</dd>
<dt><strong>big_delta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">acquisition pulse separation time in seconds (default None)</p>
</dd>
<dt><strong>small_delta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">acquisition pulse duration time in seconds (default None)</p>
</dd>
<dt><strong>b0_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">All b-values with values less than or equal to <cite>bo_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</dd>
<dt><strong>atol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">All b-vectors need to be unit vectors up to a tolerance.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gradients</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd><p class="first last">A GradientTable with all the gradient information.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li>Often b0s (b-values which correspond to images without diffusion
weighting) have 0 values however in some cases the scanner cannot
provide b0s of an exact 0 value and it gives a bit higher values
e.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</li>
<li>We assume that the minimum number of b-values is 7.</li>
<li>B-vectors should be unit vectors.</li>
</ol>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="k">import</span> <span class="n">gradient_table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span> <span class="o">=</span> <span class="mi">1500</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sq2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="isotropic">
<h3>isotropic<a class="headerlink" href="#isotropic" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.isotropic">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">isotropic</code><span class="sig-paren">(</span><em>q_form</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.isotropic" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Calculate the isotropic part of the tensor [Rd0568a744381-1].</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q_form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A_hat: ndarray</strong></dt>
<dd><p class="first last">The isotropic part of the tensor in each spatial coordinate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{1}{2} tr(A) I</p>
</dd></dl>

</div>
<div class="section" id="iter-fit-tensor">
<h3>iter_fit_tensor<a class="headerlink" href="#iter-fit-tensor" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.iter_fit_tensor">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">iter_fit_tensor</code><span class="sig-paren">(</span><em>step=10000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.iter_fit_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Wrap a fit_tensor func and iterate over chunks of data with given length</p>
<p>Splits data into a number of chunks of specified size and iterates the
decorated fit_tensor function over them. This is useful to counteract the
temporary but significant memory usage increase in fit_tensor functions
that use vectorized operations and need to store large temporary arrays for
their vectorized operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">The chunk size as a number of voxels. Optional parameter with default
value 10,000.</p>
<p class="last">In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. This parameter sets the number of
voxels that will be fit at once in each iteration. A larger step value
should speed things up, but it will also take up more memory. It is
advisable to keep an eye on memory consumption as this value is
increased.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="linearity">
<h3>linearity<a class="headerlink" href="#linearity" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.linearity">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">linearity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.linearity" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>The linearity of the tensor <a class="footnote-reference" href="#id344" id="id336">[1]</a></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>linearity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated linearity of the diffusion tensor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1-lambda_2}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

</div>
<div class="section" id="id337">
<h3>lower_triangular<a class="headerlink" href="#id337" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.lower_triangular">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">lower_triangular</code><span class="sig-paren">(</span><em>tensor</em>, <em>b0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.lower_triangular" title="Permalink to this definition"></a></dt>
<dd><p>Returns the six lower triangular values of the tensor and a dummy variable
if b0 is not None</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, 3, 3)</span></dt>
<dd><p class="first last">a collection of 3, 3 diffusion tensors</p>
</dd>
<dt><strong>b0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">if b0 is not none log(b0) is returned as the dummy variable</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">If b0 is none, then the shape will be (, 6) otherwise (, 7)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id338">
<h3>mean_diffusivity<a class="headerlink" href="#id338" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.mean_diffusivity">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">mean_diffusivity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.mean_diffusivity" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Mean Diffusivity (MD) of a diffusion tensor.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated MD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1 + lambda_2 + lambda_3}{3}</p>
</dd></dl>

</div>
<div class="section" id="mode">
<h3>mode<a class="headerlink" href="#mode" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.mode">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">mode</code><span class="sig-paren">(</span><em>q_form</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.mode" title="Permalink to this definition"></a></dt>
<dd><p>Mode (MO) of a diffusion tensor <a class="reference internal" href="#rae241588dfcd-1" id="id339">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q_form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated tensor mode in each spatial coordinate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Mode ranges between -1 (planar anisotropy) and +1 (linear anisotropy)
with 0 representing orthotropy. Mode is calculated with the
following equation (equation 9 in <a class="reference internal" href="#rae241588dfcd-1" id="id340">[1]</a>):</p>
<div class="math notranslate nohighlight">
\[Mode = 3*\sqrt{6}*det(\widetilde{A}/norm(\widetilde{A}))\]</div>
<p>Where <span class="math notranslate nohighlight">\(\widetilde{A}\)</span> is the deviatoric part of the tensor quadratic form.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rae241588dfcd-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id20">1</a>, <a class="fn-backref" href="#id339">2</a>, <a class="fn-backref" href="#id340">3</a>, <a class="fn-backref" href="#id341">4</a>)</em> Daniel B. Ennis and G. Kindlmann, Orthogonal Tensor
Invariants and the Analysis of Diffusion Tensor Magnetic Resonance
Images, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,
2006.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="nlls-fit-tensor">
<h3>nlls_fit_tensor<a class="headerlink" href="#nlls-fit-tensor" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.nlls_fit_tensor">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">nlls_fit_tensor</code><span class="sig-paren">(</span><em>design_matrix</em>, <em>data</em>, <em>weighting=None</em>, <em>sigma=None</em>, <em>jac=True</em>, <em>return_S0_hat=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.nlls_fit_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Fit the tensor params using non-linear least-squares.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 7)</span></dt>
<dd><p class="first last">Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array ([X, Y, Z, ], g)</span></dt>
<dd><p class="first last">Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>weighting: str</strong></dt>
<dd><p class="first last">the weighting scheme to use in considering the
squared-error. Default behavior is to use uniform weighting. Other
options: sigma gmm</p>
</dd>
<dt><strong>sigma: float</strong></dt>
<dd><p class="first last">If the sigma weighting scheme is used, a value of sigma needs to be
provided here. According to <a class="reference internal" href="../examples_built/restore_dti.html#chang2005" id="id342">[Chang2005]</a>, a good value to use is
1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).</p>
</dd>
<dt><strong>jac</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use the Jacobian? Default: True</p>
</dd>
<dt><strong>return_S0_hat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nlls_params: the eigen-values and eigen-vectors of the tensor in each</strong></dt>
<dd><p class="first last">voxel.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="norm">
<h3>norm<a class="headerlink" href="#norm" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.norm">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">norm</code><span class="sig-paren">(</span><em>q_form</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.norm" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the Frobenius norm of a tensor quadratic form</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q_form: ndarray</strong></dt>
<dd><p class="first last">The quadratic form of a tensor, or an array with quadratic forms of
tensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The Frobenius norm of the 3,3 tensor q_form in each spatial
coordinate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.linalg.norm</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The Frobenius norm is defined as:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Math:</th><td class="field-body">||A||_F = [sum_{i,j} abs(a_{i,j})^2]^{1/2}</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ols-fit-tensor">
<h3>ols_fit_tensor<a class="headerlink" href="#ols-fit-tensor" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.ols_fit_tensor">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">ols_fit_tensor</code><span class="sig-paren">(</span><em>design_matrix</em>, <em>data</em>, <em>return_S0_hat=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.ols_fit_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Computes ordinary least squares (OLS) fit to calculate self-diffusion
tensor using a linear regression model <a class="footnote-reference" href="#id344" id="id343">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 7)</span></dt>
<dd><p class="first last">Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array ([X, Y, Z, ], g)</span></dt>
<dd><p class="first last">Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>return_S0_hat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3)</span></dt>
<dd><p class="first last">Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt><strong>eigvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WLS_fit_tensor</span></code>, <a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a>, <a class="reference internal" href="#dipy.reconst.dti.design_matrix" title="dipy.reconst.dti.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}y = \mathrm{data} \
X = \mathrm{design matrix} \\\\hat{eta}_\mathrm{OLS} = (X^T X)^{-1} X^T y\end{aligned}\end{align} \]</div>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id344" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id12">2</a>, <a class="fn-backref" href="#id19">3</a>, <a class="fn-backref" href="#id21">4</a>, <a class="fn-backref" href="#id22">5</a>, <a class="fn-backref" href="#id24">6</a>, <a class="fn-backref" href="#id32">7</a>, <a class="fn-backref" href="#id167">8</a>, <a class="fn-backref" href="#id172">9</a>, <a class="fn-backref" href="#id173">10</a>, <a class="fn-backref" href="#id201">11</a>, <a class="fn-backref" href="#id202">12</a>, <a class="fn-backref" href="#id209">13</a>, <a class="fn-backref" href="#id210">14</a>, <a class="fn-backref" href="#id232">15</a>, <a class="fn-backref" href="#id233">16</a>, <a class="fn-backref" href="#id268">17</a>, <a class="fn-backref" href="#id299">18</a>, <a class="fn-backref" href="#id304">19</a>, <a class="fn-backref" href="#id305">20</a>, <a class="fn-backref" href="#id336">21</a>, <a class="fn-backref" href="#id343">22</a>, <a class="fn-backref" href="#id345">23</a>, <a class="fn-backref" href="#id349">24</a>, <a class="fn-backref" href="#id382">25</a>, <a class="fn-backref" href="#id387">26</a>, <a class="fn-backref" href="#id388">27</a>, <a class="fn-backref" href="#id530">28</a>)</em> Chung, SW., Lu, Y., Henry, R.G., 2006. Comparison of bootstrap
approaches for estimation of uncertainties of DTI parameters.
NeuroImage 33, 531-541.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pinv">
<h3>pinv<a class="headerlink" href="#pinv" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.pinv">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">pinv</code><span class="sig-paren">(</span><em>a</em>, <em>rcond=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.pinv" title="Permalink to this definition"></a></dt>
<dd><p>Vectorized version of <cite>numpy.linalg.pinv</cite></p>
<p>If numpy version is less than 1.8, it falls back to iterating over
<cite>np.linalg.pinv</cite> since there isnt a vectorized version of <cite>np.linalg.svd</cite>
available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, M, N)</span></dt>
<dd><p class="first last">Matrix to be pseudo-inverted.</p>
</dd>
<dt><strong>rcond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Cutoff for small singular values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (, N, M)</span></dt>
<dd><p class="first last">The pseudo-inverse of <cite>a</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>LinAlgError</strong></dt>
<dd><p class="first last">If the SVD computation does not converge.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.linalg.pinv</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="planarity">
<h3>planarity<a class="headerlink" href="#planarity" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.planarity">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">planarity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.planarity" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>The planarity of the tensor <a class="footnote-reference" href="#id344" id="id345">[1]</a></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>linearity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated linearity of the diffusion tensor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{2 (lambda_2-lambda_3)}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

</div>
<div class="section" id="quantize-evecs">
<h3>quantize_evecs<a class="headerlink" href="#quantize-evecs" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.quantize_evecs">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">quantize_evecs</code><span class="sig-paren">(</span><em>evecs</em>, <em>odf_vertices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.quantize_evecs" title="Permalink to this definition"></a></dt>
<dd><p>Find the closest orientation of an evenly distributed sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd></dd>
<dt><strong>odf_vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or ndarray</span></dt>
<dd><p class="first last">If None, then set vertices from symmetric362 sphere.  Otherwise use
passed ndarray as vertices</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>IN</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id346">
<h3>radial_diffusivity<a class="headerlink" href="#id346" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.radial_diffusivity">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">radial_diffusivity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.radial_diffusivity" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Radial Diffusivity (RD) of a diffusion tensor.
Also called perpendicular diffusivity.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor, must be sorted in descending order
along <cite>axis</cite>.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rd</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated RD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_2 + lambda_3}{2}</p>
</dd></dl>

</div>
<div class="section" id="restore-fit-tensor">
<h3>restore_fit_tensor<a class="headerlink" href="#restore-fit-tensor" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.restore_fit_tensor">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">restore_fit_tensor</code><span class="sig-paren">(</span><em>design_matrix</em>, <em>data</em>, <em>sigma=None</em>, <em>jac=True</em>, <em>return_S0_hat=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.restore_fit_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Use the RESTORE algorithm <a class="reference internal" href="../examples_built/restore_dti.html#chang2005" id="id347">[Chang2005]</a> to calculate a robust tensor fit</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of shape (g, 7)</span></dt>
<dd><p class="first last">Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of shape ([X, Y, Z, n_directions], g)</span></dt>
<dd><p class="first last">Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">An estimate of the variance. <a class="reference internal" href="../examples_built/restore_dti.html#chang2005" id="id348">[Chang2005]</a> recommend to use
1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).</p>
</dd>
<dt><strong>jac</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to use the Jacobian of the tensor to speed the non-linear
optimization procedure used to fit the tensor parameters (see also
<a class="reference internal" href="#dipy.reconst.dti.nlls_fit_tensor" title="dipy.reconst.dti.nlls_fit_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">nlls_fit_tensor()</span></code></a>). Default: True</p>
</dd>
<dt><strong>return_S0_hat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>restore_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">an estimate of the tensor parameters in each voxel.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Chang, L-C, Jones, DK and Pierpaoli, C (2005). RESTORE: robust estimation
of tensors by outlier rejection. MRM, 53: 1088-95.</p>
</dd></dl>

</div>
<div class="section" id="sphericity">
<h3>sphericity<a class="headerlink" href="#sphericity" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.sphericity">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">sphericity</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.sphericity" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>The sphericity of the tensor <a class="footnote-reference" href="#id344" id="id349">[1]</a></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><blockquote class="first">
<div><p>Eigenvalues of a diffusion tensor.</p>
</div></blockquote>
<dl class="last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphericity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated sphericity of the diffusion tensor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{3 lambda_3)}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

</div>
<div class="section" id="tensor-prediction">
<h3>tensor_prediction<a class="headerlink" href="#tensor-prediction" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.tensor_prediction">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">tensor_prediction</code><span class="sig-paren">(</span><em>dti_params</em>, <em>gtab</em>, <em>S0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.tensor_prediction" title="Permalink to this definition"></a></dt>
<dd><p>Predict a signal given tensor parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dti_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Tensor parameters. The last dimension should have 12 tensor
parameters: 3 eigenvalues, followed by the 3 corresponding
eigenvectors.</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The predicted signal is given by: <span class="math notranslate nohighlight">\(S(       heta, b) = S_0 * e^{-b ADC}\)</span>, where
<span class="math notranslate nohighlight">\(ADC =      heta Q  heta^T\)</span>, :math:`      heta` is a unit vector pointing at any
direction on the sphere for which a signal is to be predicted, <span class="math notranslate nohighlight">\(b\)</span> is the b
value provided in the GradientTable input for that direction, <span class="math notranslate nohighlight">\(Q\)</span> is the
quadratic form of the tensor determined by the input parameters.</p>
</dd></dl>

</div>
<div class="section" id="id350">
<h3>trace<a class="headerlink" href="#id350" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.trace">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">trace</code><span class="sig-paren">(</span><em>evals</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.trace" title="Permalink to this definition"></a></dt>
<dd><p>Trace of a diffusion tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span></dt>
<dd><p class="first last">Eigenvalues of a diffusion tensor.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated trace of the diffusion tensor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Trace is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[Trace = \lambda_1 + \lambda_2 + \lambda_3\]</div>
</dd></dl>

</div>
<div class="section" id="id351">
<h3>vec_val_vect<a class="headerlink" href="#id351" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.vec_val_vect">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">vec_val_vect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.vec_val_vect" title="Permalink to this definition"></a></dt>
<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, N) array</span></dt>
<dd><p class="first last">containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>
</dd>
<dt><strong>vals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, N) array</span></dt>
<dd><p class="first last">diagonal values carried in last dimension, <code class="docutils literal notranslate"><span class="pre">...</span></code> shape above must
match that for <cite>vecs</cite></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, M) array</span></dt>
<dd><p class="first last">For all the dimensions ellided by <code class="docutils literal notranslate"><span class="pre">...</span></code>, loops to get (M, N) <code class="docutils literal notranslate"><span class="pre">vec</span></code>
matrix, and (N,) <code class="docutils literal notranslate"><span class="pre">vals</span></code> vector, and calculates
<code class="docutils literal notranslate"><span class="pre">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Make a 3D array where the first dimension is only 1</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_val_vect</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="go">array([[[   9.,   24.,   39.],</span>
<span class="go">        [  24.,   66.,  108.],</span>
<span class="go">        [  39.,  108.,  177.]]])</span>
</pre></div>
</div>
<p>Thats the same as the 2D case (apart from the float casting):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">vecs</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">array([[  9,  24,  39],</span>
<span class="go">       [ 24,  66, 108],</span>
<span class="go">       [ 39, 108, 177]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="vector-norm">
<h3>vector_norm<a class="headerlink" href="#vector-norm" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.vector_norm">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">vector_norm</code><span class="sig-paren">(</span><em>vec</em>, <em>axis=-1</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.vector_norm" title="Permalink to this definition"></a></dt>
<dd><p>Return vector Euclidean (L2) norm</p>
<p>See <a class="reference internal" href="../glossary.html#term-unit-vector"><span class="xref std std-term">unit vector</span></a> and <a class="reference internal" href="../glossary.html#term-euclidean-norm"><span class="xref std std-term">Euclidean norm</span></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Vectors to norm.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis over which to norm. By default norm over last axis. If <cite>axis</cite> is
None, <cite>vec</cite> is flattened then normed.</p>
</dd>
<dt><strong>keepdims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, the output will have the same number of dimensions as <cite>vec</cite>,
with shape 1 on <cite>axis</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Euclidean norms of vectors.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">77</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="go">array([ 17.,  85.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 17.],</span>
<span class="go">       [ 85.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([  8.,  39.,  77.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="wls-fit-tensor">
<h3>wls_fit_tensor<a class="headerlink" href="#wls-fit-tensor" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.dti.wls_fit_tensor">
<code class="descclassname">dipy.reconst.dti.</code><code class="descname">wls_fit_tensor</code><span class="sig-paren">(</span><em>design_matrix</em>, <em>data</em>, <em>return_S0_hat=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.dti.wls_fit_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Computes weighted least squares (WLS) fit to calculate self-diffusion
tensor using a linear regression model <a class="reference internal" href="#rba397ddf7dbd-1" id="id352">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 7)</span></dt>
<dd><p class="first last">Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array ([X, Y, Z, ], g)</span></dt>
<dd><p class="first last">Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>return_S0_hat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Boolean to return (True) or not (False) the S0 values for the fit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3)</span></dt>
<dd><p class="first last">Eigenvalues from eigen decomposition of the tensor.</p>
</dd>
<dt><strong>eigvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[:,j] is associated with
eigvals[j])</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.dti.decompose_tensor" title="dipy.reconst.dti.decompose_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_tensor</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>In Chung, et al. 2006, the regression of the WLS fit needed an unbiased
preliminary estimate of the weights and therefore the ordinary least
squares (OLS) estimates were used. A two pass method was implemented:</p>
<blockquote>
<div><ol class="arabic simple">
<li>calculate OLS estimates of the data</li>
<li>apply the OLS estimates as weights to the WLS fit of the data</li>
</ol>
</div></blockquote>
<p>This ensured heteroscedasticity could be properly modeled for various
types of bootstrap resampling (namely residual bootstrap).</p>
<div class="math notranslate nohighlight">
\[y = \mathrm{data} \
X = \mathrm{design matrix} \
\hat{eta}_\mathrm{WLS} =
\mathrm{desired regression coefficients (e.g. tensor)}\
\
\hat{eta}_\mathrm{WLS} = (X^T W X)^{-1} X^T W y \
\
W = \mathrm{diag}((X \hat{eta}_\mathrm{OLS})^2),
\mathrm{where} \hat{eta}_\mathrm{OLS} = (X^T X)^{-1} X^T y\]</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rba397ddf7dbd-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id25">1</a>, <a class="fn-backref" href="#id352">2</a>, <a class="fn-backref" href="#id353">3</a>)</em> Chung, SW., Lu, Y., Henry, R.G., 2006. Comparison of bootstrap
approaches for estimation of uncertainties of DTI parameters.
NeuroImage 33, 531-541.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id354">
<h3><a class="reference internal" href="#dipy.reconst.forecast.Cache" title="dipy.reconst.forecast.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#id354" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.forecast.Cache">
<em class="property">class </em><code class="descclassname">dipy.reconst.forecast.</code><code class="descname">Cache</code><a class="headerlink" href="#dipy.reconst.forecast.Cache" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.Cache.cache_clear" title="dipy.reconst.forecast.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.Cache.cache_get" title="dipy.reconst.forecast.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.Cache.cache_set" title="dipy.reconst.forecast.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.forecast.Cache.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.Cache.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.Cache.cache_clear">
<code class="descname">cache_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.Cache.cache_clear" title="Permalink to this definition"></a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.Cache.cache_get">
<code class="descname">cache_get</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.Cache.cache_get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.Cache.cache_set">
<code class="descname">cache_set</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.Cache.cache_set" title="Permalink to this definition"></a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="forecastfit">
<h3><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit" title="dipy.reconst.forecast.ForecastFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastFit</span></code></a><a class="headerlink" href="#forecastfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.forecast.ForecastFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.forecast.</code><code class="descname">ForecastFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em>, <em>sh_coef</em>, <em>d_par</em>, <em>d_perp</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfFit</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.dpar" title="dipy.reconst.forecast.ForecastFit.dpar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dpar</span></code></a></dt>
<dd><p class="first last">The parallel diffusivity</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.dperp" title="dipy.reconst.forecast.ForecastFit.dperp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dperp</span></code></a></dt>
<dd><p class="first last">The perpendicular diffusivity</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.sh_coeff" title="dipy.reconst.forecast.ForecastFit.sh_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sh_coeff</span></code></a></dt>
<dd><p class="first last">The FORECAST SH coefficients</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.fractional_anisotropy" title="dipy.reconst.forecast.ForecastFit.fractional_anisotropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractional_anisotropy</span></code></a>()</td>
<td>Calculates the fractional anisotropy.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.mean_diffusivity" title="dipy.reconst.forecast.ForecastFit.mean_diffusivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_diffusivity</span></code></a>()</td>
<td>Calculates the mean diffusivity.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.odf" title="dipy.reconst.forecast.ForecastFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere[,&nbsp;clip_negative])</td>
<td>Calculates the fODF for a given discrete sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.ForecastFit.predict" title="dipy.reconst.forecast.ForecastFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>([gtab,&nbsp;S0])</td>
<td>Calculates the fODF for a given discrete sphere.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.forecast.ForecastFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em>, <em>sh_coef</em>, <em>d_par</em>, <em>d_perp</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Calculates diffusion properties for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">AnalyticalModel</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">fitted data</p>
</dd>
<dt><strong>sh_coef</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">forecast sh coefficients</p>
</dd>
<dt><strong>d_par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">parallel diffusivity</p>
</dd>
<dt><strong>d_perp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">perpendicular diffusivity</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.forecast.ForecastFit.dpar">
<code class="descname">dpar</code><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.dpar" title="Permalink to this definition"></a></dt>
<dd><p>The parallel diffusivity</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.forecast.ForecastFit.dperp">
<code class="descname">dperp</code><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.dperp" title="Permalink to this definition"></a></dt>
<dd><p>The perpendicular diffusivity</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.ForecastFit.fractional_anisotropy">
<code class="descname">fractional_anisotropy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.fractional_anisotropy" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the fractional anisotropy.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.ForecastFit.mean_diffusivity">
<code class="descname">mean_diffusivity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.mean_diffusivity" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the mean diffusivity.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.ForecastFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em>, <em>clip_negative=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the fODF for a given discrete sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere,</span></dt>
<dd><p class="first last">the odf sphere</p>
</dd>
<dt><strong>clip_negative</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">if True clip the negative odf values to 0, default True</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.ForecastFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab=None</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the fODF for a given discrete sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable, optional</span></dt>
<dd><p class="first last">gradient directions and bvalues container class.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">the signal at b-value=0</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.forecast.ForecastFit.sh_coeff">
<code class="descname">sh_coeff</code><a class="headerlink" href="#dipy.reconst.forecast.ForecastFit.sh_coeff" title="Permalink to this definition"></a></dt>
<dd><p>The FORECAST SH coefficients</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="forecastmodel">
<h3><a class="reference internal" href="#dipy.reconst.forecast.ForecastModel" title="dipy.reconst.forecast.ForecastModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForecastModel</span></code></a><a class="headerlink" href="#forecastmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.forecast.ForecastModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.forecast.</code><code class="descname">ForecastModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order=8</em>, <em>lambda_lb=0.001</em>, <em>dec_alg='CSD'</em>, <em>sphere=None</em>, <em>lambda_csd=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.cache.Cache</span></code></a></p>
<p>Fiber ORientation Estimated using Continuous Axially Symmetric Tensors
(FORECAST) [1,2,3]_. FORECAST is a Spherical Deconvolution reconstruction
model for multi-shell diffusion data which enables the calculation of a
voxel adaptive response function using the Spherical Mean Tecnique (SMT)
[2,3]_.</p>
<p>With FORECAST it is possible to calculate crossing invariant parallel
diffusivity, perpendicular diffusivity, mean diffusivity, and fractional
anisotropy <a class="reference internal" href="#r1340df73dba1-2" id="id355">[2]</a></p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1340df73dba1-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id356">[1]</a></td><td>Anderson A. W., Measurement of Fiber Orientation Distributions
Using High Angular Resolution Diffusion Imaging, Magnetic
Resonance in Medicine, 2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1340df73dba1-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id355">1</a>, <a class="fn-backref" href="#id357">2</a>)</em> Kaden E. et al., Quantitative Mapping of the Per-Axon Diffusion
Coefficients in Brain White Matter, Magnetic Resonance in
Medicine, 2016.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1340df73dba1-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id358">[3]</a></td><td>Zucchelli E. et al., A generalized SMT-based framework for
Diffusion MRI microstructural model estimation, MICCAI Workshop
on Computational DIFFUSION MRI (CDMRI), 2017.</td></tr>
</tbody>
</table>
<p>The implementation of FORECAST may require CVXPY (<a class="reference external" href="http://www.cvxpy.org/">http://www.cvxpy.org/</a>).</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.forecast.ForecastModel.fit" title="dipy.reconst.forecast.ForecastModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.forecast.ForecastModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order=8</em>, <em>lambda_lb=0.001</em>, <em>dec_alg='CSD'</em>, <em>sphere=None</em>, <em>lambda_csd=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Analytical and continuous modeling of the diffusion signal with
respect to the FORECAST basis [1,2,3]_.
This implementation is a modification of the original FORECAST
model presented in <a class="reference internal" href="#rb72cc5c16677-1" id="id359">[1]</a> adapted for multi-shell data as in [2,3]_ .</p>
<p>The main idea is to model the diffusion signal as the combination of a
single fiber response function <span class="math notranslate nohighlight">\(F(\mathbf{b})\)</span> times the fODF
<span class="math notranslate nohighlight">\(\rho(\mathbf{v})\)</span></p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">E(mathbf{b}) = int_{mathbf{v} in mathcal{S}^2} rho(mathbf{v}) F({mathbf{b}} | mathbf{v}) d mathbf{v}</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is the b-vector (b-value times gradient direction)
and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is an unit vector representing a fiber direction.</p>
<p>In FORECAST <span class="math notranslate nohighlight">\(\rho\)</span> is modeled using real symmetric Spherical Harmonics
(SH) and <span class="math notranslate nohighlight">\(F(\mathbf(b))\)</span> is an axially symmetric tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable,</span></dt>
<dd><p class="first last">gradient directions and bvalues container class.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the SH order of the basis (max 12)</p>
</dd>
<dt><strong>lambda_lb: float,</strong></dt>
<dd><p class="first last">Laplace-Beltrami regularization weight.</p>
</dd>
<dt><strong>dec_alg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str,</span></dt>
<dd><p class="first last">Spherical deconvolution algorithm. The possible values are Weighted Least Squares (WLS),
Positivity Constraints using CVXPY (POS) and the Constraint
Spherical Deconvolution algorithm (CSD). Default is CSD.</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3),</span></dt>
<dd><p class="first last">sphere points where to enforce positivity when POS or CSD
dec_alg are selected.</p>
</dd>
<dt><strong>lambda_csd</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">CSD regularization weight.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb72cc5c16677-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id359">1</a>, <a class="fn-backref" href="#id360">2</a>)</em> Anderson A. W., Measurement of Fiber Orientation Distributions
Using High Angular Resolution Diffusion Imaging, Magnetic
Resonance in Medicine, 2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb72cc5c16677-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id361">[2]</a></td><td>Kaden E. et al., Quantitative Mapping of the Per-Axon Diffusion
Coefficients in Brain White Matter, Magnetic Resonance in
Medicine, 2016.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb72cc5c16677-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id362">[3]</a></td><td>Zucchelli M. et al., A generalized SMT-based framework for
Diffusion MRI microstructural model estimation, MICCAI Workshop
on Computational DIFFUSION MRI (CDMRI), 2017.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In this example, where the data, gradient table and sphere tessellation
used for reconstruction are provided, we model the diffusion signal
with respect to the FORECAST and compute the fODF, parallel and
perpendicular diffusivity.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_sphere</span><span class="p">,</span> <span class="n">get_3shell_gtab</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gtab</span> <span class="o">=</span> <span class="n">get_3shell_gtab</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.sims.voxel</span> <span class="k">import</span> <span class="n">MultiTensor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mevals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="mf">0.0017</span><span class="p">,</span> <span class="mf">0.0003</span><span class="p">,</span> <span class="mf">0.0003</span><span class="p">],</span> 
<span class="gp">... </span>                   <span class="p">[</span><span class="mf">0.0017</span><span class="p">,</span> <span class="mf">0.0003</span><span class="p">,</span> <span class="mf">0.0003</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angl</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">sticks</span> <span class="o">=</span> <span class="n">MultiTensor</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">mevals</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">S0</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">angles</span><span class="o">=</span><span class="n">angl</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">fractions</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="n">snr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.forecast</span> <span class="k">import</span> <span class="n">ForecastModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fm</span> <span class="o">=</span> <span class="n">ForecastModel</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">sh_order</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_fit</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_par</span> <span class="o">=</span> <span class="n">f_fit</span><span class="o">.</span><span class="n">dpar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_perp</span> <span class="o">=</span> <span class="n">f_fit</span><span class="o">.</span><span class="n">dperp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;symmetric724&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fodf</span> <span class="o">=</span> <span class="n">f_fit</span><span class="o">.</span><span class="n">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.ForecastModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.ForecastModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id363">
<h3><a class="reference internal" href="#dipy.reconst.forecast.OdfFit" title="dipy.reconst.forecast.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a><a class="headerlink" href="#id363" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.forecast.OdfFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.forecast.</code><code class="descname">OdfFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.OdfFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstFit</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.OdfFit.odf" title="dipy.reconst.forecast.OdfFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>To be implemented but specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.forecast.OdfFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.OdfFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.OdfFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.OdfFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id364">
<h3><a class="reference internal" href="#dipy.reconst.forecast.OdfModel" title="dipy.reconst.forecast.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a><a class="headerlink" href="#id364" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.forecast.OdfModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.forecast.</code><code class="descname">OdfModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.OdfModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as its
first and only argument.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.forecast.OdfModel.fit" title="dipy.reconst.forecast.OdfModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.forecast.OdfModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.OdfModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.forecast.OdfModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.OdfModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id365">
<h3>cart2sphere<a class="headerlink" href="#id365" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.cart2sphere">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">cart2sphere</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.cart2sphere" title="Permalink to this definition"></a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions and derivation
of the formulae.</p>
<p><span class="math notranslate nohighlight">\(0\le\theta\mathrm{(theta)}\le\pi\)</span> and <span class="math notranslate nohighlight">\(-\pi\le\phi\mathrm{(phi)}\le\pi\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">x coordinate in Cartesian space</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">z coordinate</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">radius</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">inclination (polar) angle</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">azimuth angle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id366">
<h3>csdeconv<a class="headerlink" href="#id366" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.csdeconv">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">csdeconv</code><span class="sig-paren">(</span><em>dwsignal</em>, <em>X</em>, <em>B_reg</em>, <em>tau=0.1</em>, <em>convergence=50</em>, <em>P=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.csdeconv" title="Permalink to this definition"></a></dt>
<dd><p>Constrained-regularized spherical deconvolution (CSD) <a class="reference internal" href="#r89c481eb6cb9-1" id="id367">[1]</a></p>
<p>Deconvolves the axially symmetric single fiber response function <cite>r_rh</cite> in
rotational harmonics coefficients from the diffusion weighted signal in
<cite>dwsignal</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dwsignal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Diffusion weighted signals to be deconvolved.</p>
</dd>
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Prediction matrix which estimates diffusion weighted signals from FOD
coefficients.</p>
</dd>
<dt><strong>B_reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, B)</span></dt>
<dd><p class="first last">SH basis matrix which maps FOD coefficients to FOD values on the
surface of the sphere. B_reg should be scaled to account for lambda.</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Threshold controlling the amplitude below which the corresponding fODF
is assumed to be zero.  Ideally, tau should be set to zero. However, to
improve the stability of the algorithm, tau is set to tau*100 % of the
max fODF amplitude (here, 10% by default). This is similar to peak
detection where peaks below 0.1 amplitude are usually considered noise
peaks. Because SDT is based on a q-ball ODF deconvolution, and not
signal deconvolution, using the max instead of mean (as in CSD), is
more stable.</p>
</dd>
<dt><strong>convergence</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations to allow the deconvolution to converge.</p>
</dd>
<dt><strong>P</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">This is an optimization to avoid computing <code class="docutils literal notranslate"><span class="pre">dot(X.T,</span> <span class="pre">X)</span></code> many times.
If the same <code class="docutils literal notranslate"><span class="pre">X</span></code> is used many times, <code class="docutils literal notranslate"><span class="pre">P</span></code> can be precomputed and
passed to this function.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fodf_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt>
<dd><p class="first last">Spherical harmonics coefficients of the constrained-regularized fiber
ODF.</p>
</dd>
<dt><strong>num_it</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of iterations in the constrained-regularization used for
convergence.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This section describes how the fitting of the SH coefficients is done.
Problem is to minimise per iteration:</p>
<p><span class="math notranslate nohighlight">\(F(f_n) = ||Xf_n - S||^2 + \lambda^2 ||H_{n-1} f_n||^2\)</span></p>
<p>Where <span class="math notranslate nohighlight">\(X\)</span> maps current FOD SH coefficients <span class="math notranslate nohighlight">\(f_n\)</span> to DW signals <span class="math notranslate nohighlight">\(s\)</span> and
<span class="math notranslate nohighlight">\(H_{n-1}\)</span> maps FOD SH coefficients <span class="math notranslate nohighlight">\(f_n\)</span> to amplitudes along set of
negative directions identified in previous iteration, i.e. the matrix
formed by the rows of <span class="math notranslate nohighlight">\(B_{reg}\)</span> for which <span class="math notranslate nohighlight">\(Hf_{n-1}&lt;0\)</span> where <span class="math notranslate nohighlight">\(B_{reg}\)</span>
maps <span class="math notranslate nohighlight">\(f_n\)</span> to FOD amplitude on a sphere.</p>
<p>Solve by differentiating and setting to zero:</p>
<p><span class="math notranslate nohighlight">\(\Rightarrow \frac{\delta F}{\delta f_n} = 2X^T(Xf_n - S) + 2 \lambda^2
H_{n-1}^TH_{n-1}f_n=0\)</span></p>
<p>Or:</p>
<p><span class="math notranslate nohighlight">\((X^TX + \lambda^2 H_{n-1}^TH_{n-1})f_n = X^Ts\)</span></p>
<p>Define <span class="math notranslate nohighlight">\(Q = X^TX + \lambda^2 H_{n-1}^TH_{n-1}\)</span> , which by construction is a
square positive definite symmetric matrix of size <span class="math notranslate nohighlight">\(n_{SH} by n_{SH}\)</span>. If
needed, positive definiteness can be enforced with a small minimum norm
regulariser (helps a lot with poorly conditioned direction sets and/or
superresolution):</p>
<p><span class="math notranslate nohighlight">\(Q = X^TX + (\lambda H_{n-1}^T) (\lambda H_{n-1}) + \mu I\)</span></p>
<p>Solve <span class="math notranslate nohighlight">\(Qf_n = X^Ts\)</span> using Cholesky decomposition:</p>
<p><span class="math notranslate nohighlight">\(Q = LL^T\)</span></p>
<p>where <span class="math notranslate nohighlight">\(L\)</span> is lower triangular. Then problem can be solved by
back-substitution:</p>
<p><span class="math notranslate nohighlight">\(L_y = X^Ts\)</span></p>
<p><span class="math notranslate nohighlight">\(L^Tf_n = y\)</span></p>
<p>To speeds things up further, form <span class="math notranslate nohighlight">\(P = X^TX + \mu I\)</span>, and update to form
<span class="math notranslate nohighlight">\(Q\)</span> by rankn update with <span class="math notranslate nohighlight">\(H_{n-1}\)</span>. The dipy implementation looks like:</p>
<blockquote>
<div><p>form initially <span class="math notranslate nohighlight">\(P = X^T X + \mu I\)</span> and <span class="math notranslate nohighlight">\(\lambda B_{reg}\)</span></p>
<p>for each voxel: form <span class="math notranslate nohighlight">\(z = X^Ts\)</span></p>
<blockquote>
<div><p>estimate <span class="math notranslate nohighlight">\(f_0\)</span> by solving <span class="math notranslate nohighlight">\(Pf_0=z\)</span>. We use a simplified <span class="math notranslate nohighlight">\(l_{max}=4\)</span>
solution here, but it might not make a big difference.</p>
<p>Then iterate until no change in rows of <span class="math notranslate nohighlight">\(H\)</span> used in <span class="math notranslate nohighlight">\(H_n\)</span></p>
<blockquote>
<div><p>form <span class="math notranslate nohighlight">\(H_{n}\)</span> given <span class="math notranslate nohighlight">\(f_{n-1}\)</span></p>
<p>form <span class="math notranslate nohighlight">\(Q = P + (\lambda H_{n-1}^T) (\lambda H_{n-1}\)</span>) (this can
be done by rankn update, but we currently do not use rankn
update).</p>
<p>solve <span class="math notranslate nohighlight">\(Qf_n = z\)</span> using Cholesky decomposition</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>Wed like to thanks Donald Tournier for his help with describing and
implementing this algorithm.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r89c481eb6cb9-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id26">1</a>, <a class="fn-backref" href="#id367">2</a>, <a class="fn-backref" href="#id368">3</a>)</em> Tournier, J.D., et al. NeuroImage 2007. Robust determination of the
fibre orientation distribution in diffusion MRI: Non-negativity
constrained super-resolved spherical deconvolution.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="find-signal-means">
<h3>find_signal_means<a class="headerlink" href="#find-signal-means" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.find_signal_means">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">find_signal_means</code><span class="sig-paren">(</span><em>b_unique</em>, <em>data_norm</em>, <em>bvals</em>, <em>rho</em>, <em>lb_matrix</em>, <em>w=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.find_signal_means" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the mean signal for each shell.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>b_unique</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">unique b-values in a vector excluding zero</p>
</dd>
<dt><strong>data_norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">normalized diffusion signal</p>
</dd>
<dt><strong>bvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">the b-values</p>
</dd>
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2d ndarray,</span></dt>
<dd><p class="first last">SH basis matrix for fitting the signal on each shell</p>
</dd>
<dt><strong>lb_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2d ndarray,</span></dt>
<dd><p class="first last">Laplace-Beltrami regularization matrix</p>
</dd>
<dt><strong>w</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">weight for the Laplace-Beltrami regularization</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>means</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray</span></dt>
<dd><p class="first last">the average of the signal for each b-values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="forecast-error-func">
<h3>forecast_error_func<a class="headerlink" href="#forecast-error-func" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.forecast_error_func">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">forecast_error_func</code><span class="sig-paren">(</span><em>x</em>, <em>b_unique</em>, <em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.forecast_error_func" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the difference between the mean signal calculated using 
the parameter vector x and the average signal E using FORECAST and SMT</p>
</dd></dl>

</div>
<div class="section" id="forecast-matrix">
<h3>forecast_matrix<a class="headerlink" href="#forecast-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.forecast_matrix">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">forecast_matrix</code><span class="sig-paren">(</span><em>sh_order</em>, <em>d_par</em>, <em>d_perp</em>, <em>bvals</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.forecast_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the FORECAST radial matrix</p>
</dd></dl>

</div>
<div class="section" id="id369">
<h3>get_sphere<a class="headerlink" href="#id369" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.get_sphere">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">get_sphere</code><span class="sig-paren">(</span><em>name='symmetric362'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.get_sphere" title="Permalink to this definition"></a></dt>
<dd><p>provide triangulated spheres</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">which sphere - one of:
* symmetric362
* symmetric642
* symmetric724
* repulsion724
* repulsion100
* repulsion200</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a dipy.core.sphere.Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;symmetric362&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">sphere</span><span class="o">.</span><span class="n">faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">362</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">720</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;not a sphere name&#39;</span><span class="p">)</span> 
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">DataError</span>: <span class="n">No sphere called &quot;not a sphere name&quot;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="lb-forecast">
<h3>lb_forecast<a class="headerlink" href="#lb-forecast" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.lb_forecast">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">lb_forecast</code><span class="sig-paren">(</span><em>sh_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.lb_forecast" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Laplace-Beltrami regularization matrix for FORECAST</p>
</dd></dl>

</div>
<div class="section" id="leastsq">
<h3>leastsq<a class="headerlink" href="#leastsq" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.leastsq">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">leastsq</code><span class="sig-paren">(</span><em>func</em>, <em>x0</em>, <em>args=()</em>, <em>Dfun=None</em>, <em>full_output=0</em>, <em>col_deriv=0</em>, <em>ftol=1.49012e-08</em>, <em>xtol=1.49012e-08</em>, <em>gtol=0.0</em>, <em>maxfev=0</em>, <em>epsfcn=None</em>, <em>factor=100</em>, <em>diag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.leastsq" title="Permalink to this definition"></a></dt>
<dd><p>Minimize the sum of squares of a set of equations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">arg</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
         <span class="n">y</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">should take at least one (possibly length N vector) argument and
returns M floating point numbers. It must not return NaNs or
fitting might fail.</p>
</dd>
<dt><strong>x0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The starting estimate for the minimization.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, optional</span></dt>
<dd><p class="first last">Any extra arguments to func are placed in this tuple.</p>
</dd>
<dt><strong>Dfun</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd><p class="first last">A function or method to compute the Jacobian of func with derivatives
across the rows. If this is None, the Jacobian will be estimated.</p>
</dd>
<dt><strong>full_output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">non-zero to return all optional outputs.</p>
</dd>
<dt><strong>col_deriv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">non-zero to specify that the Jacobian function computes derivatives
down the columns (faster, because there is no transpose operation).</p>
</dd>
<dt><strong>ftol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Relative error desired in the sum of squares.</p>
</dd>
<dt><strong>xtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Relative error desired in the approximate solution.</p>
</dd>
<dt><strong>gtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Orthogonality desired between the function vector and the columns of
the Jacobian.</p>
</dd>
<dt><strong>maxfev</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The maximum number of calls to the function. If <cite>Dfun</cite> is provided
then the default <cite>maxfev</cite> is 100*(N+1) where N is the number of elements
in x0, otherwise the default <cite>maxfev</cite> is 200*(N+1).</p>
</dd>
<dt><strong>epsfcn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">A variable used in determining a suitable step length for the forward-
difference approximation of the Jacobian (for Dfun=None).
Normally the actual step length will be sqrt(epsfcn)*x
If epsfcn is less than the machine precision, it is assumed that the
relative errors are of the order of the machine precision.</p>
</dd>
<dt><strong>factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">A parameter determining the initial step bound
(<code class="docutils literal notranslate"><span class="pre">factor</span> <span class="pre">*</span> <span class="pre">||</span> <span class="pre">diag</span> <span class="pre">*</span> <span class="pre">x||</span></code>). Should be in interval <code class="docutils literal notranslate"><span class="pre">(0.1,</span> <span class="pre">100)</span></code>.</p>
</dd>
<dt><strong>diag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">N positive entries that serve as a scale factors for the variables.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The solution (or the result of the last iteration for an unsuccessful
call).</p>
</dd>
<dt><strong>cov_x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Uses the fjac and ipvt optional outputs to construct an
estimate of the jacobian around the solution. None if a
singular matrix encountered (indicates very flat curvature in
some direction).  This matrix must be multiplied by the
residual variance to get the covariance of the
parameter estimates  see curve_fit.</p>
</dd>
<dt><strong>infodict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">a dictionary of optional outputs with the key s:</p>
<dl class="last docutils">
<dt><code class="docutils literal notranslate"><span class="pre">nfev</span></code></dt>
<dd><p class="first last">The number of function calls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fvec</span></code></dt>
<dd><p class="first last">The function evaluated at the output</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fjac</span></code></dt>
<dd><p class="first last">A permutation of the R matrix of a QR
factorization of the final approximate
Jacobian matrix, stored column wise.
Together with ipvt, the covariance of the
estimate can be approximated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipvt</span></code></dt>
<dd><p class="first last">An integer array of length N which defines
a permutation matrix, p, such that
fjac*p = q*r, where r is upper triangular
with diagonal elements of nonincreasing
magnitude. Column j of p is column ipvt(j)
of the identity matrix.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qtf</span></code></dt>
<dd><p class="first last">The vector (transpose(q) * fvec).</p>
</dd>
</dl>
</dd>
<dt><strong>mesg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">A string message giving information about the cause of failure.</p>
</dd>
<dt><strong>ier</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">An integer flag.  If it is equal to 1, 2, 3 or 4, the solution was
found.  Otherwise, the solution was not found. In either case, the
optional output variable mesg gives more information.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>leastsq is a wrapper around MINPACKs lmdif and lmder algorithms.</p>
<p>cov_x is a Jacobian approximation to the Hessian of the least squares
objective function.
This approximation assumes that the objective function is based on the
difference between some observed target data (ydata) and a (non-linear)
function of the parameters <cite>f(xdata, params)</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">=</span> <span class="n">ydata</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>so that the objective function is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">min</span>   <span class="nb">sum</span><span class="p">((</span><span class="n">ydata</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">params</span>
</pre></div>
</div>
<p>The solution, <cite>x</cite>, is always a 1D array, regardless of the shape of <cite>x0</cite>,
or whether <cite>x0</cite> is a scalar.</p>
</dd></dl>

</div>
<div class="section" id="id370">
<h3>multi_voxel_fit<a class="headerlink" href="#id370" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.multi_voxel_fit">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="optional-package">
<h3>optional_package<a class="headerlink" href="#optional-package" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.optional_package">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">optional_package</code><span class="sig-paren">(</span><em>name</em>, <em>trip_msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.optional_package" title="Permalink to this definition"></a></dt>
<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">package name</p>
</dd>
<dt><strong>trip_msg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or str</span></dt>
<dd><p class="first last">message to give when someone tries to use the return package, but we
could not import it, and have returned a TripWire object instead.
Default message if None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pkg_like</strong> <span class="classifier-delimiter">:</span> <span class="classifier">module or <code class="docutils literal notranslate"><span class="pre">TripWire</span></code> instance</span></dt>
<dd><p class="first last">If we can import the package, return it.  Otherwise return an object
raising an error when accessed</p>
</dd>
<dt><strong>have_pkg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if import for package was successful, false otherwise</p>
</dd>
<dt><strong>module_setup</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">callable usually set as <code class="docutils literal notranslate"><span class="pre">setup_module</span></code> in calling namespace, to allow
skipping tests.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="psi-l">
<h3>psi_l<a class="headerlink" href="#psi-l" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.psi_l">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">psi_l</code><span class="sig-paren">(</span><em>l</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.psi_l" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id371">
<h3>real_sph_harm<a class="headerlink" href="#id371" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.real_sph_harm">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">real_sph_harm</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.real_sph_harm" title="Permalink to this definition"></a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>Where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:</p>
<blockquote>
<div>Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
<span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code></span></dt>
<dd><p class="first last">The order of the harmonic.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt>
<dd><p class="first last">The degree of the harmonic.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">real float</span></dt>
<dd><p class="first last">The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.special.sph_harm</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="rho-matrix">
<h3>rho_matrix<a class="headerlink" href="#rho-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.rho_matrix">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">rho_matrix</code><span class="sig-paren">(</span><em>sh_order</em>, <em>vecs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.rho_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the SH matrix <span class="math notranslate nohighlight">\(\rho\)</span></p>
</dd></dl>

</div>
<div class="section" id="warn">
<h3>warn<a class="headerlink" href="#warn" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.forecast.warn">
<code class="descclassname">dipy.reconst.forecast.</code><code class="descname">warn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.forecast.warn" title="Permalink to this definition"></a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
<div class="section" id="freewatertensorfit">
<h3><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit" title="dipy.reconst.fwdti.FreeWaterTensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorFit</span></code></a><a class="headerlink" href="#freewatertensorfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.fwdti.FreeWaterTensorFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">FreeWaterTensorFit</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.dti.TensorFit" title="dipy.reconst.dti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.dti.TensorFit</span></code></a></p>
<p>Class for fitting the Free Water Tensor Model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S0_hat</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></dt>
<dd><p class="first last">For tracking - return the primary direction in each voxel</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></dt>
<dd><p class="first last">Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></dt>
<dd><p class="first last">Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit.f" title="dipy.reconst.fwdti.FreeWaterTensorFit.f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">f</span></code></a></dt>
<dd><p class="first last">Returns the free water diffusion volume fraction f</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></dt>
<dd><p class="first last">Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code>()</td>
<td>Axial diffusivity (AD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code>(sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction on</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code>()</td>
<td>Color fractional anisotropy of diffusion tensor</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code>()</td>
<td>Fractional anisotropy (FA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code>()</td>
<td>Geodesic anisotropy (GA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code>()</td>
<td>Mean diffusivity (MD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code>()</td>
<td>Tensor mode calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code>(sphere)</td>
<td>The diffusion orientation distribution function (dODF).</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorFit.predict" title="dipy.reconst.fwdti.FreeWaterTensorFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab[,&nbsp;S0])</td>
<td>Given a free water tensor model fit, predict the signal on the vertices of a gradient table</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code>()</td>
<td>Radial diffusivity (RD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>()</td>
<td>Trace of the tensor calculated from cached eigenvalues.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>lower_triangular</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.fwdti.FreeWaterTensorFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a FreeWaterTensorFit class instance.
Since the free water tensor model is an extension of DTI, class
instance is defined as subclass of the TensorFit from dti.py</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">FreeWaterTensorModel Class instance</span></dt>
<dd><p class="first last">Class instance containing the free water tensor model for the fit</p>
</dd>
<dt><strong>model_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 13) or (n, 13)</span></dt>
<dd><p class="first">All parameters estimated from the free water tensor model.
Parameters are ordered as follows:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>The volume fraction of the free water compartment</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.fwdti.FreeWaterTensorFit.f">
<code class="descname">f</code><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit.f" title="Permalink to this definition"></a></dt>
<dd><p>Returns the free water diffusion volume fraction f</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.FreeWaterTensorFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab</em>, <em>S0=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Given a free water tensor model fit, predict the signal on the
vertices of a gradient table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">The mean non-diffusion weighted signal in each voxel. Default: 1 in
all voxels.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, N) ndarray</span></dt>
<dd><p class="first last">Simulated signal based on the free water DTI model</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="freewatertensormodel">
<h3><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel" title="dipy.reconst.fwdti.FreeWaterTensorModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeWaterTensorModel</span></code></a><a class="headerlink" href="#freewatertensormodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.fwdti.FreeWaterTensorModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">FreeWaterTensorModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='NLS'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>Class for the Free Water Elimination Diffusion Tensor Model</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel.fit" title="dipy.reconst.fwdti.FreeWaterTensorModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.FreeWaterTensorModel.predict" title="dipy.reconst.fwdti.FreeWaterTensorModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(fwdti_params[,&nbsp;S0])</td>
<td>Predict a signal for this TensorModel class instance given parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.fwdti.FreeWaterTensorModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>fit_method='NLS'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Free Water Diffusion Tensor Model <a class="reference internal" href="#r557833582831-1" id="id372">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>fit_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or callable</span></dt>
<dd><p class="first">str can be one of the following:</p>
<dl class="last docutils">
<dt>WLS for weighted linear least square fit according to <a class="reference internal" href="#r557833582831-1" id="id373">[1]</a></dt>
<dd><p class="first last"><code class="xref py py-func docutils literal notranslate"><span class="pre">fwdti.wls_iter()</span></code></p>
</dd>
<dt>NLS for non-linear least square fit according to <a class="reference internal" href="#r557833582831-1" id="id374">[1]</a></dt>
<dd><p class="first last"><code class="xref py py-func docutils literal notranslate"><span class="pre">fwdti.nls_iter()</span></code></p>
</dd>
<dt>callable has to have the signature:</dt>
<dd><p class="first last">fit_method(design_matrix, data, <a href="#id375"><span class="problematic" id="id376">*</span></a>args, <a href="#id377"><span class="problematic" id="id378">**</span></a>kwargs)</p>
</dd>
</dl>
</dd>
<dt><strong>args, kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">arguments and key-word arguments passed to the</span></dt>
<dd><p class="first last">fit_method. See fwdti.wls_iter, fwdti.nls_iter for
details</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r557833582831-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id372">1</a>, <a class="fn-backref" href="#id373">2</a>, <a class="fn-backref" href="#id374">3</a>, <a class="fn-backref" href="#id379">4</a>)</em> Hoy, A.R., Koay, C.G., Kecskemeti, S.R., Alexander, A.L., 2014.
Optimization of a free water elimination two-compartmental model
for diffusion tensor imaging. NeuroImage 103, 323-333.
doi: 10.1016/j.neuroimage.2014.09.053</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.FreeWaterTensorModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.FreeWaterTensorModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>fwdti_params</em>, <em>S0=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.FreeWaterTensorModel.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict a signal for this TensorModel class instance given
parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fwdti_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, 13) ndarray</span></dt>
<dd><p class="first last">The last dimension should have 13 parameters: the 12 tensor
parameters (3 eigenvalues, followed by the 3 corresponding
eigenvectors) and the free water volume fraction.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, N) ndarray</span></dt>
<dd><p class="first last">Simulated signal based on the free water DTI model</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id380">
<h3><a class="reference internal" href="#dipy.reconst.fwdti.ReconstModel" title="dipy.reconst.fwdti.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#id380" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.fwdti.ReconstModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">ReconstModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.ReconstModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.fwdti.ReconstModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.ReconstModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.ReconstModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.ReconstModel.fit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id381">
<h3><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit" title="dipy.reconst.fwdti.TensorFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorFit</span></code></a><a class="headerlink" href="#id381" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.fwdti.TensorFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">TensorFit</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em>, <em>model_S0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S0_hat</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.directions" title="dipy.reconst.fwdti.TensorFit.directions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">directions</span></code></a></dt>
<dd><p class="first last">For tracking - return the primary direction in each voxel</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.evals" title="dipy.reconst.fwdti.TensorFit.evals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evals</span></code></a></dt>
<dd><p class="first last">Returns the eigenvalues of the tensor as an array</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.evecs" title="dipy.reconst.fwdti.TensorFit.evecs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evecs</span></code></a></dt>
<dd><p class="first last">Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.quadratic_form" title="dipy.reconst.fwdti.TensorFit.quadratic_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadratic_form</span></code></a></dt>
<dd><p class="first last">Calculates the 3x3 diffusion tensor for each voxel</p>
</dd>
<dt><strong>shape</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.ad" title="dipy.reconst.fwdti.TensorFit.ad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ad</span></code></a>()</td>
<td>Axial diffusivity (AD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.adc" title="dipy.reconst.fwdti.TensorFit.adc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc</span></code></a>(sphere)</td>
<td>Calculate the apparent diffusion coefficient (ADC) in each direction on</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.color_fa" title="dipy.reconst.fwdti.TensorFit.color_fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">color_fa</span></code></a>()</td>
<td>Color fractional anisotropy of diffusion tensor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.fa" title="dipy.reconst.fwdti.TensorFit.fa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fa</span></code></a>()</td>
<td>Fractional anisotropy (FA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.ga" title="dipy.reconst.fwdti.TensorFit.ga"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ga</span></code></a>()</td>
<td>Geodesic anisotropy (GA) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.linearity" title="dipy.reconst.fwdti.TensorFit.linearity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearity</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.md" title="dipy.reconst.fwdti.TensorFit.md"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md</span></code></a>()</td>
<td>Mean diffusivity (MD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.mode" title="dipy.reconst.fwdti.TensorFit.mode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mode</span></code></a>()</td>
<td>Tensor mode calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.odf" title="dipy.reconst.fwdti.TensorFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>The diffusion orientation distribution function (dODF).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.planarity" title="dipy.reconst.fwdti.TensorFit.planarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">planarity</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.predict" title="dipy.reconst.fwdti.TensorFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab[,&nbsp;S0,&nbsp;step])</td>
<td>Given a model fit, predict the signal on the vertices of a sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.rd" title="dipy.reconst.fwdti.TensorFit.rd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rd</span></code></a>()</td>
<td>Radial diffusivity (RD) calculated from cached eigenvalues.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.sphericity" title="dipy.reconst.fwdti.TensorFit.sphericity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sphericity</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.fwdti.TensorFit.trace" title="dipy.reconst.fwdti.TensorFit.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>()</td>
<td>Trace of the tensor calculated from cached eigenvalues.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>lower_triangular</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em>, <em>model_S0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a TensorFit class instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.fwdti.TensorFit.S0_hat">
<code class="descname">S0_hat</code><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.S0_hat" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.ad">
<code class="descname">ad</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.ad" title="Permalink to this definition"></a></dt>
<dd><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated AD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>RD is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[AD = \lambda_1\]</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.adc">
<code class="descname">adc</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.adc" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Calculate the apparent diffusion coefficient (ADC) in each direction on
the sphere for each voxel in the data</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The estimates of the apparent diffusion coefficient in every
direction on the input sphere</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>ec{b} Q 
ec{b}^T</p>
<blockquote>
<div>Where Q is the quadratic form of the tensor.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.color_fa">
<code class="descname">color_fa</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.color_fa" title="Permalink to this definition"></a></dt>
<dd><p>Color fractional anisotropy of diffusion tensor</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.fwdti.TensorFit.directions">
<code class="descname">directions</code><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.directions" title="Permalink to this definition"></a></dt>
<dd><p>For tracking - return the primary direction in each voxel</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.fwdti.TensorFit.evals">
<code class="descname">evals</code><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.evals" title="Permalink to this definition"></a></dt>
<dd><p>Returns the eigenvalues of the tensor as an array</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.fwdti.TensorFit.evecs">
<code class="descname">evecs</code><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.evecs" title="Permalink to this definition"></a></dt>
<dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.fa">
<code class="descname">fa</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.fa" title="Permalink to this definition"></a></dt>
<dd><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.ga">
<code class="descname">ga</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.ga" title="Permalink to this definition"></a></dt>
<dd><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.linearity">
<code class="descname">linearity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.linearity" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>linearity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated linearity of the diffusion tensor <a class="footnote-reference" href="#id344" id="id382">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1-lambda_2}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.lower_triangular">
<code class="descname">lower_triangular</code><span class="sig-paren">(</span><em>b0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.lower_triangular" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.md">
<code class="descname">md</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.md" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Mean diffusivity (MD) calculated from cached eigenvalues.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated MD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_1+lambda_2+lambda_3}{3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.mode">
<code class="descname">mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.mode" title="Permalink to this definition"></a></dt>
<dd><p>Tensor mode calculated from cached eigenvalues.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>The diffusion orientation distribution function (dODF). This is an
estimate of the diffusion distance in each direction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance.</span></dt>
<dd><p class="first last">The dODF is calculated in the vertices of this input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The diffusion distance in every direction of the sphere in every
voxel in the input data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is based on equation 3 in <a class="reference internal" href="#rad5a83a2738a-aganj2010" id="id383">[Aganj2010]</a>. To re-derive it from
scratch, follow steps in <a class="reference internal" href="#rad5a83a2738a-descoteaux2008" id="id384">[Descoteaux2008]</a>, Section 7.9 Equation
7.24 but with an <span class="math notranslate nohighlight">\(r^2\)</span> term in the integral.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rad5a83a2738a-aganj2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Aganj2010]</td><td><em>(<a class="fn-backref" href="#id383">1</a>, <a class="fn-backref" href="#id385">2</a>)</em> Aganj, I., Lenglet, C., Sapiro, G., Yacoub, E., Ugurbil,
K., &amp; Harel, N. (2010). Reconstruction of the orientation
distribution function in single- and multiple-shell q-ball imaging
within constant solid angle. Magnetic Resonance in Medicine, 64(2),
554-566. doi:DOI: 10.1002/mrm.22365</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rad5a83a2738a-descoteaux2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Descoteaux2008]</td><td><em>(<a class="fn-backref" href="#id384">1</a>, <a class="fn-backref" href="#id386">2</a>)</em> Descoteaux, M. (2008). PhD Thesis: High Angular
Resolution Diffusion MRI: from Local Estimation to Segmentation and
Tractography. <a class="reference external" href="ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf">ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.planarity">
<code class="descname">planarity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.planarity" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphericity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated sphericity of the diffusion tensor <a class="footnote-reference" href="#id344" id="id387">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{2 (lambda_2 - lambda_3)}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab</em>, <em>S0=None</em>, <em>step=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Given a model fit, predict the signal on the vertices of a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">This encodes the directions for which a prediction is made</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">The mean non-diffusion weighted signal in each voxel. Default:
The fitted S0 value in all voxels if it was fitted. Otherwise 1 in
all voxels.</p>
</dd>
<dt><strong>step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">The chunk size as a number of voxels. Optional parameter with
default value 10,000.</p>
<p class="last">In order to increase speed of processing, tensor fitting is done
simultaneously over many voxels. This parameter sets the number of
voxels that will be fit at once in each iteration. A larger step
value should speed things up, but it will also take up more memory.
It is advisable to keep an eye on memory consumption as this value
is increased.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:</p>
<div class="math notranslate nohighlight">
\[S(  heta, b) = S_0 * e^{-b ADC}\]</div>
<p>Where:
.. math</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ADC</span> <span class="o">=</span>       <span class="n">heta</span> <span class="n">Q</span>  <span class="n">heta</span><span class="o">^</span><span class="n">T</span>
</pre></div>
</div>
<p>:math:`       heta` is a unit vector pointing at any direction on the sphere for
which a signal is to be predicted and <span class="math notranslate nohighlight">\(b\)</span> is the b value provided in
the GradientTable input for that direction</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.fwdti.TensorFit.quadratic_form">
<code class="descname">quadratic_form</code><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.quadratic_form" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.rd">
<code class="descname">rd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.rd" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Radial diffusivity (RD) calculated from cached eigenvalues.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rd</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated RD.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{lambda_2 + lambda_3}{2}</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.fwdti.TensorFit.shape">
<code class="descname">shape</code><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.shape" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.sphericity">
<code class="descname">sphericity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.sphericity" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphericity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Calculated sphericity of the diffusion tensor <a class="footnote-reference" href="#id344" id="id388">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{3 lambda_3}{lambda_1+lambda_2+lambda_3}</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.fwdti.TensorFit.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.TensorFit.trace" title="Permalink to this definition"></a></dt>
<dd><p>Trace of the tensor calculated from cached eigenvalues.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (V, 1)</span></dt>
<dd><p class="first last">Calculated trace.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The trace is calculated with the following equation:</p>
<div class="math notranslate nohighlight">
\[trace = \lambda_1 + \lambda_2 + \lambda_3\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="cholesky-to-lower-triangular">
<h3>cholesky_to_lower_triangular<a class="headerlink" href="#cholesky-to-lower-triangular" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.cholesky_to_lower_triangular">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">cholesky_to_lower_triangular</code><span class="sig-paren">(</span><em>R</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.cholesky_to_lower_triangular" title="Permalink to this definition"></a></dt>
<dd><p>Convert Cholesky decompostion elements to the diffusion tensor elements</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (6,)</span></dt>
<dd><p class="first last">Array containing the six Choleskys decomposition elements
(R0, R1, R2, R3, R4, R5) <a class="reference internal" href="#r3e5c58668b7e-1" id="id389">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tensor_elements</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (6,)</span></dt>
<dd><p class="first last">Array containing the six elements of diffusion tensors lower
triangular.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r3e5c58668b7e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id389">1</a>, <a class="fn-backref" href="#id390">2</a>)</em> Koay, C.G., Carew, J.D., Alexander, A.L., Basser, P.J.,
Meyerand, M.E., 2006. Investigation of anomalous estimates of
tensor-derived quantities in diffusion tensor imaging. Magnetic
Resonance in Medicine, 55(4), 930-936. doi:10.1002/mrm.20832</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id391">
<h3>decompose_tensor<a class="headerlink" href="#id391" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.decompose_tensor">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">decompose_tensor</code><span class="sig-paren">(</span><em>tensor</em>, <em>min_diffusivity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.decompose_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>
<p>Computes tensor eigen decomposition to calculate eigenvalues and
eigenvectors (Basser et al., 1994a).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Hermitian matrix representing a diffusion tensor.</p>
</dd>
<dt><strong>min_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Because negative eigenvalues are not physical and small eigenvalues,
much smaller than the diffusion weighting, cause quite a lot of noise
in metrics such as fa, diffusivity values smaller than
<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3)</span></dt>
<dd><p class="first last">Eigenvalues from eigen decomposition of the tensor. Negative
eigenvalues are replaced by zero. Sorted from largest to smallest.</p>
</dd>
<dt><strong>eigvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (, 3, 3)</span></dt>
<dd><p class="first last">Associated eigenvectors from eigen decomposition of the tensor.
Eigenvectors are columnar (e.g. eigvecs[, :, j] is associated with
eigvals[, j])</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id392">
<h3>design_matrix<a class="headerlink" href="#id392" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.design_matrix">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">design_matrix</code><span class="sig-paren">(</span><em>gtab</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.design_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Constructs design matrix for DTI weighted least squares or
least squares fitting. (Basser et al., 1994a)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">A GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Parameter to control the dtype of returned designed matrix</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g,7)</span></dt>
<dd><p class="first last">Design matrix or B matrix assuming Gaussian distributed tensor model
design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id393">
<h3>from_lower_triangular<a class="headerlink" href="#id393" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.from_lower_triangular">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">from_lower_triangular</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.from_lower_triangular" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tensor given the six unique tensor elements</p>
<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,
Dyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are
ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, (, &gt;6)</span></dt>
<dd><p class="first last">Unique elements of the tensors</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (, 3, 3)</span></dt>
<dd><p class="first last">3 by 3 tensors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fwdti-prediction">
<h3>fwdti_prediction<a class="headerlink" href="#fwdti-prediction" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.fwdti_prediction">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">fwdti_prediction</code><span class="sig-paren">(</span><em>params</em>, <em>gtab</em>, <em>S0=1</em>, <em>Diso=0.003</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.fwdti_prediction" title="Permalink to this definition"></a></dt>
<dd><p>Signal prediction given the free water DTI model parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, 13) ndarray</span></dt>
<dd><p class="first last">Model parameters. The last dimension should have the 12 tensor
parameters (3 eigenvalues, followed by the 3 corresponding
eigenvectors) and the volume fraction of the free water compartment.</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The gradient table for this prediction</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray</span></dt>
<dd><p class="first last">The non diffusion-weighted signal in every voxel, or across all
voxels. Default: 1</p>
</dd>
<dt><strong>Diso</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please adjust this value if you are assuming different
units of diffusion.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, N) ndarray</span></dt>
<dd><p class="first last">Simulated signal based on the free water DTI model</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The predicted signal is given by:
<span class="math notranslate nohighlight">\(S(\theta, b) = S_0 * [(1-f) * e^{-b ADC} + f * e^{-b D_{iso}]\)</span>, where
<span class="math notranslate nohighlight">\(ADC = \theta Q \theta^T\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span> is a unit vector pointing at any
direction on the sphere for which a signal is to be predicted, <span class="math notranslate nohighlight">\(b\)</span> is the b
value provided in the GradientTable input for that direction, <span class="math notranslate nohighlight">\(Q\)</span> is the
quadratic form of the tensor determined by the input parameters, <span class="math notranslate nohighlight">\(f\)</span> is the
free water diffusion compartment, <span class="math notranslate nohighlight">\(D_{iso}\)</span> is the free water diffusivity
which is equal to $3 * 10^{-3} mm^{2}s^{-1} <a class="reference internal" href="#r20a3e875d073-1" id="id394">[1]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r20a3e875d073-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id394">1</a>, <a class="fn-backref" href="#id395">2</a>)</em> Hoy, A.R., Koay, C.G., Kecskemeti, S.R., Alexander, A.L., 2014.
Optimization of a free water elimination two-compartmental model
for diffusion tensor imaging. NeuroImage 103, 323-333.
doi: 10.1016/j.neuroimage.2014.09.053</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id396">
<h3>lower_triangular<a class="headerlink" href="#id396" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.lower_triangular">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">lower_triangular</code><span class="sig-paren">(</span><em>tensor</em>, <em>b0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.lower_triangular" title="Permalink to this definition"></a></dt>
<dd><p>Returns the six lower triangular values of the tensor and a dummy variable
if b0 is not None</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tensor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (, 3, 3)</span></dt>
<dd><p class="first last">a collection of 3, 3 diffusion tensors</p>
</dd>
<dt><strong>b0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">if b0 is not none log(b0) is returned as the dummy variable</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">If b0 is none, then the shape will be (, 6) otherwise (, 7)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="lower-triangular-to-cholesky">
<h3>lower_triangular_to_cholesky<a class="headerlink" href="#lower-triangular-to-cholesky" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.lower_triangular_to_cholesky">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">lower_triangular_to_cholesky</code><span class="sig-paren">(</span><em>tensor_elements</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.lower_triangular_to_cholesky" title="Permalink to this definition"></a></dt>
<dd><p>Perfoms Cholesky decomposition of the diffusion tensor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tensor_elements</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (6,)</span></dt>
<dd><p class="first last">Array containing the six elements of diffusion tensors lower
triangular.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cholesky_elements</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (6,)</span></dt>
<dd><p class="first last">Array containing the six Choleskys decomposition elements
(R0, R1, R2, R3, R4, R5) <a class="reference internal" href="#r9884b97dd08e-1" id="id397">[1]</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r9884b97dd08e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id397">1</a>, <a class="fn-backref" href="#id398">2</a>)</em> Koay, C.G., Carew, J.D., Alexander, A.L., Basser, P.J.,
Meyerand, M.E., 2006. Investigation of anomalous estimates of
tensor-derived quantities in diffusion tensor imaging. Magnetic
Resonance in Medicine, 55(4), 930-936. doi:10.1002/mrm.20832</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id399">
<h3>multi_voxel_fit<a class="headerlink" href="#id399" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.multi_voxel_fit">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="id400">
<h3>ndindex<a class="headerlink" href="#id400" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.ndindex">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">ndindex</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.ndindex" title="Permalink to this definition"></a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd><p class="first last">The dimensions of the array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="k">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nls-fit-tensor">
<h3>nls_fit_tensor<a class="headerlink" href="#nls-fit-tensor" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.nls_fit_tensor">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">nls_fit_tensor</code><span class="sig-paren">(</span><em>gtab</em>, <em>data</em>, <em>mask=None</em>, <em>Diso=0.003</em>, <em>mdreg=0.0027</em>, <em>min_signal=1e-06</em>, <em>f_transform=True</em>, <em>cholesky=False</em>, <em>jac=False</em>, <em>weighting=None</em>, <em>sigma=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.nls_fit_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Fit the water elimination tensor model using the non-linear least-squares.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The gradient table containing diffusion acquisition parameters.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray ([X, Y, Z, ], g)</span></dt>
<dd><p class="first last">Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that should
be analyzed that has the shape data.shape[:-1]</p>
</dd>
<dt><strong>Diso</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please ajust this value if you are assuming different
units of diffusion.</p>
</dd>
<dt><strong>mdreg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optimal</span></dt>
<dd><p class="first last">DTIs mean diffusivity regularization threshold. If standard DTI
diffusion tensors mean diffusivity is almost near the free water
diffusion value, the diffusion signal is assumed to be only free water
diffusion (i.e. volume fraction will be set to 1 and tissues diffusion
parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
(corresponding to 90% of the free water diffusion value).</p>
</dd>
<dt><strong>min_signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum signal value. Needs to be a strictly positive
number. Default: 1.0e-6.</p>
</dd>
<dt><strong>f_transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If true, the water volume fractions is converted during the convergence
procedure to ft = arcsin(2*f - 1) + pi/2, insuring f estimates between
0 and 1.
Default: True</p>
</dd>
<dt><strong>cholesky</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If true it uses cholesky decomposition to insure that diffusion tensor
is positive define.
Default: False</p>
</dd>
<dt><strong>jac</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use the Jacobian? Default: False</p>
</dd>
<dt><strong>weighting: str, optional</strong></dt>
<dd><p class="first last">the weighting scheme to use in considering the
squared-error. Default behavior is to use uniform weighting. Other
options: sigma gmm</p>
</dd>
<dt><strong>sigma: float, optional</strong></dt>
<dd><p class="first last">If the sigma weighting scheme is used, a value of sigma needs to be
provided here. According to <a class="reference internal" href="../examples_built/restore_dti.html#chang2005" id="id401">[Chang2005]</a>, a good value to use is
1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fw_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 13)</span></dt>
<dd><p class="first">Matrix containing in the dimention the free water model parameters in
the following order:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>The volume fraction of the free water compartment</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="nls-iter">
<h3>nls_iter<a class="headerlink" href="#nls-iter" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.nls_iter">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">nls_iter</code><span class="sig-paren">(</span><em>design_matrix</em>, <em>sig</em>, <em>S0</em>, <em>Diso=0.003</em>, <em>mdreg=0.0027</em>, <em>min_signal=1e-06</em>, <em>cholesky=False</em>, <em>f_transform=True</em>, <em>jac=False</em>, <em>weighting=None</em>, <em>sigma=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.nls_iter" title="Permalink to this definition"></a></dt>
<dd><p>Applies non linear least squares fit of the water free elimination
model to single voxel signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 7)</span></dt>
<dd><p class="first last">Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>sig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, )</span></dt>
<dd><p class="first last">Diffusion-weighted signal for a single voxel data.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Non diffusion weighted signal (i.e. signal for b-value=0).</p>
</dd>
<dt><strong>Diso</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please ajust this value if you are assuming different
units of diffusion.</p>
</dd>
<dt><strong>mdreg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optimal</span></dt>
<dd><p class="first last">DTIs mean diffusivity regularization threshold. If standard DTI
diffusion tensors mean diffusivity is almost near the free water
diffusion value, the diffusion signal is assumed to be only free water
diffusion (i.e. volume fraction will be set to 1 and tissues diffusion
parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
(corresponding to 90% of the free water diffusion value).</p>
</dd>
<dt><strong>min_signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum signal value. Needs to be a strictly positive
number.</p>
</dd>
<dt><strong>cholesky</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If true it uses cholesky decomposition to insure that diffusion tensor
is positive define.
Default: False</p>
</dd>
<dt><strong>f_transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If true, the water volume fractions is converted during the convergence
procedure to ft = arcsin(2*f - 1) + pi/2, insuring f estimates between
0 and 1.
Default: True</p>
</dd>
<dt><strong>jac</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use the Jacobian? Default: False</p>
</dd>
<dt><strong>weighting: str, optional</strong></dt>
<dd><p class="first last">the weighting scheme to use in considering the
squared-error. Default behavior is to use uniform weighting. Other
options: sigma gmm</p>
</dd>
<dt><strong>sigma: float, optional</strong></dt>
<dd><p class="first last">If the sigma weighting scheme is used, a value of sigma needs to be
provided here. According to <a class="reference internal" href="../examples_built/restore_dti.html#chang2005" id="id402">[Chang2005]</a>, a good value to use is
1.5267 * std(background_noise), where background_noise is estimated
from some part of the image known to contain no signal (only noise).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>All parameters estimated from the free water tensor model.</strong></dt>
<dd></dd>
<dt><strong>Parameters are ordered as follows:</strong></dt>
<dd><ol class="first last arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>The volume fraction of the free water compartment.</li>
</ol>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id403">
<h3>vec_val_vect<a class="headerlink" href="#id403" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.vec_val_vect">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">vec_val_vect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.vec_val_vect" title="Permalink to this definition"></a></dt>
<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, N) array</span></dt>
<dd><p class="first last">containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>
</dd>
<dt><strong>vals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, N) array</span></dt>
<dd><p class="first last">diagonal values carried in last dimension, <code class="docutils literal notranslate"><span class="pre">...</span></code> shape above must
match that for <cite>vecs</cite></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">shape (, M, M) array</span></dt>
<dd><p class="first last">For all the dimensions ellided by <code class="docutils literal notranslate"><span class="pre">...</span></code>, loops to get (M, N) <code class="docutils literal notranslate"><span class="pre">vec</span></code>
matrix, and (N,) <code class="docutils literal notranslate"><span class="pre">vals</span></code> vector, and calculates
<code class="docutils literal notranslate"><span class="pre">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">non-matching <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Make a 3D array where the first dimension is only 1</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_val_vect</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="go">array([[[   9.,   24.,   39.],</span>
<span class="go">        [  24.,   66.,  108.],</span>
<span class="go">        [  39.,  108.,  177.]]])</span>
</pre></div>
</div>
<p>Thats the same as the 2D case (apart from the float casting):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">vecs</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">array([[  9,  24,  39],</span>
<span class="go">       [ 24,  66, 108],</span>
<span class="go">       [ 39, 108, 177]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id404">
<h3>wls_fit_tensor<a class="headerlink" href="#id404" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.wls_fit_tensor">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">wls_fit_tensor</code><span class="sig-paren">(</span><em>gtab</em>, <em>data</em>, <em>Diso=0.003</em>, <em>mask=None</em>, <em>min_signal=1e-06</em>, <em>piterations=3</em>, <em>mdreg=0.0027</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.wls_fit_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Computes weighted least squares (WLS) fit to calculate self-diffusion
tensor using a linear regression model <a class="reference internal" href="#r78c063b823b9-1" id="id405">[1]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The gradient table containing diffusion acquisition parameters.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray ([X, Y, Z, ], g)</span></dt>
<dd><p class="first last">Data or response variables holding the data. Note that the last
dimension should contain the data. It makes no copies of data.</p>
</dd>
<dt><strong>Diso</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please ajust this value if you are assuming different
units of diffusion.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that should
be analyzed that has the shape data.shape[:-1]</p>
</dd>
<dt><strong>min_signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum signal value. Needs to be a strictly positive
number. Default: 1.0e-6.</p>
</dd>
<dt><strong>piterations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">inter, optional</span></dt>
<dd><p class="first last">Number of iterations used to refine the precision of f. Default is set
to 3 corresponding to a precision of 0.01.</p>
</dd>
<dt><strong>mdreg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optimal</span></dt>
<dd><p class="first last">DTIs mean diffusivity regularization threshold. If standard DTI
diffusion tensors mean diffusivity is almost near the free water
diffusion value, the diffusion signal is assumed to be only free water
diffusion (i.e. volume fraction will be set to 1 and tissues diffusion
parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
(corresponding to 90% of the free water diffusion value).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fw_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (x, y, z, 13)</span></dt>
<dd><p class="first">Matrix containing in the last dimention the free water model parameters
in the following order:</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>The volume fraction of the free water compartment.</li>
</ol>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r78c063b823b9-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id27">1</a>, <a class="fn-backref" href="#id405">2</a>, <a class="fn-backref" href="#id406">3</a>)</em> Hoy, A.R., Koay, C.G., Kecskemeti, S.R., Alexander, A.L., 2014.
Optimization of a free water elimination two-compartmental model
for diffusion tensor imaging. NeuroImage 103, 323-333.
doi: 10.1016/j.neuroimage.2014.09.053</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="wls-iter">
<h3>wls_iter<a class="headerlink" href="#wls-iter" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.fwdti.wls_iter">
<code class="descclassname">dipy.reconst.fwdti.</code><code class="descname">wls_iter</code><span class="sig-paren">(</span><em>design_matrix</em>, <em>sig</em>, <em>S0</em>, <em>Diso=0.003</em>, <em>mdreg=0.0027</em>, <em>min_signal=1e-06</em>, <em>piterations=3</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.fwdti.wls_iter" title="Permalink to this definition"></a></dt>
<dd><p>Applies weighted linear least squares fit of the water free elimination
model to single voxel signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, 7)</span></dt>
<dd><p class="first last">Design matrix holding the covariants used to solve for the regression
coefficients.</p>
</dd>
<dt><strong>sig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g, )</span></dt>
<dd><p class="first last">Diffusion-weighted signal for a single voxel data.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Non diffusion weighted signal (i.e. signal for b-value=0).</p>
</dd>
<dt><strong>Diso</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><blockquote class="first">
<div><p>Value of the free water isotropic diffusion. Default is set to 3e-3
<span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>. Please ajust this value if you are assuming different
units of diffusion.</p>
</div></blockquote>
<dl class="last docutils">
<dt>mdreg <span class="classifier-delimiter">:</span> <span class="classifier">float, optimal</span></dt>
<dd><p class="first last">DTIs mean diffusivity regularization threshold. If standard DTI
diffusion tensors mean diffusivity is almost near the free water
diffusion value, the diffusion signal is assumed to be only free water
diffusion (i.e. volume fraction will be set to 1 and tissues diffusion
parameters are set to zero). Default md_reg is 2.7e-3 <span class="math notranslate nohighlight">\(mm^{2}.s^{-1}\)</span>
(corresponding to 90% of the free water diffusion value).</p>
</dd>
</dl>
</dd>
<dt><strong>min_signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum signal value. Needs to be a strictly positive
number. Default: minimal signal in the data provided to <cite>fit</cite>.</p>
</dd>
<dt><strong>piterations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">inter, optional</span></dt>
<dd><p class="first last">Number of iterations used to refine the precision of f. Default is set
to 3 corresponding to a precision of 0.01.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>All parameters estimated from the free water tensor model.</strong></dt>
<dd></dd>
<dt><strong>Parameters are ordered as follows:</strong></dt>
<dd><ol class="first last arabic simple">
<li>Three diffusion tensors eigenvalues</li>
<li>Three lines of the eigenvector matrix each containing the
first, second and third coordinates of the eigenvector</li>
<li>The volume fraction of the free water compartment</li>
</ol>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id407">
<h3><a class="reference internal" href="#dipy.reconst.gqi.Cache" title="dipy.reconst.gqi.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#id407" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.Cache">
<em class="property">class </em><code class="descclassname">dipy.reconst.gqi.</code><code class="descname">Cache</code><a class="headerlink" href="#dipy.reconst.gqi.Cache" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.Cache.cache_clear" title="dipy.reconst.gqi.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.Cache.cache_get" title="dipy.reconst.gqi.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.Cache.cache_set" title="dipy.reconst.gqi.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.Cache.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.Cache.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.Cache.cache_clear">
<code class="descname">cache_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.Cache.cache_clear" title="Permalink to this definition"></a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.Cache.cache_get">
<code class="descname">cache_get</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.Cache.cache_get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.Cache.cache_set">
<code class="descname">cache_set</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.Cache.cache_set" title="Permalink to this definition"></a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="generalizedqsamplingfit">
<h3><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="dipy.reconst.gqi.GeneralizedQSamplingFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingFit</span></code></a><a class="headerlink" href="#generalizedqsamplingfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.gqi.</code><code class="descname">GeneralizedQSamplingFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfFit</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.odf" title="dipy.reconst.gqi.GeneralizedQSamplingFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>Calculates the discrete ODF for a given discrete sphere.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Calculates PDF and ODF for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">DiffusionSpectrumModel</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">signal values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the discrete ODF for a given discrete sphere.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="generalizedqsamplingmodel">
<h3><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="dipy.reconst.gqi.GeneralizedQSamplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedQSamplingModel</span></code></a><a class="headerlink" href="#generalizedqsamplingmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.gqi.</code><code class="descname">GeneralizedQSamplingModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>method='gqi2'</em>, <em>sampling_length=1.2</em>, <em>normalize_peaks=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.cache.Cache</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.fit" title="dipy.reconst.gqi.GeneralizedQSamplingModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>method='gqi2'</em>, <em>sampling_length=1.2</em>, <em>normalize_peaks=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Generalized Q-Sampling Imaging <a class="reference internal" href="#r92e3dfdc494f-1" id="id408">[1]</a></p>
<p>This model has the same assumptions as the DSI method i.e. Cartesian
grid sampling in q-space and fast gradient switching.</p>
<p>Implements equations 2.14 from <a class="reference internal" href="#r92e3dfdc494f-2" id="id409">[2]</a> for standard GQI and equation 2.16
from <a class="reference internal" href="#r92e3dfdc494f-2" id="id410">[2]</a> for GQI2. You can think of GQI2 as an analytical solution of
the DSI ODF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">GradientTable</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str,</span></dt>
<dd><p class="first last">standard or gqi2</p>
</dd>
<dt><strong>sampling_length</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">diffusion sampling length (lambda in eq. 2.14 and 2.16)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.dsi.DiffusionSpectrumModel" title="dipy.reconst.dsi.DiffusionSpectrumModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dipy.reconst.dsi.DiffusionSpectrumModel</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>As of version 0.9, range of the sampling length in GQI2 has changed
to match the same scale used in the standard method <a class="reference internal" href="#r92e3dfdc494f-1" id="id411">[1]</a>. This
means that the value of <cite>sampling_length</cite> should be approximately
1 - 1.3 (see <a class="reference internal" href="#r92e3dfdc494f-1" id="id412">[1]</a>, pg. 1628).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r92e3dfdc494f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id408">1</a>, <a class="fn-backref" href="#id411">2</a>, <a class="fn-backref" href="#id412">3</a>, <a class="fn-backref" href="#id413">4</a>)</em> Yeh F-C et al., Generalized Q-Sampling Imaging, IEEE TMI, 2010</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r92e3dfdc494f-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id409">1</a>, <a class="fn-backref" href="#id410">2</a>, <a class="fn-backref" href="#id414">3</a>)</em> Garyfallidis E, Towards an accurate brain tractography, PhD</td></tr>
</tbody>
</table>
<p>thesis, University of Cambridge, 2012.</p>
<p class="rubric">Examples</p>
<p>Here we create an example where we provide the data, a gradient table
and a reconstruction sphere and calculate the ODF for the first
voxel in the data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">dsi_voxels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">gtab</span> <span class="o">=</span> <span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.subdivide_octahedron</span> <span class="k">import</span> <span class="n">create_unit_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">create_unit_sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.gqi</span> <span class="k">import</span> <span class="n">GeneralizedQSamplingModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gq</span> <span class="o">=</span> <span class="n">GeneralizedQSamplingModel</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="s1">&#39;gqi2&#39;</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">voxel_signal</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf</span> <span class="o">=</span> <span class="n">gq</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">voxel_signal</span><span class="p">)</span><span class="o">.</span><span class="n">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.GeneralizedQSamplingModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.GeneralizedQSamplingModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id415">
<h3><a class="reference internal" href="#dipy.reconst.gqi.OdfFit" title="dipy.reconst.gqi.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a><a class="headerlink" href="#id415" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.OdfFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.gqi.</code><code class="descname">OdfFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.OdfFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstFit</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.OdfFit.odf" title="dipy.reconst.gqi.OdfFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>To be implemented but specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.OdfFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.OdfFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.OdfFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.OdfFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id416">
<h3><a class="reference internal" href="#dipy.reconst.gqi.OdfModel" title="dipy.reconst.gqi.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a><a class="headerlink" href="#id416" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.gqi.OdfModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.gqi.</code><code class="descname">OdfModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.OdfModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as its
first and only argument.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.gqi.OdfModel.fit" title="dipy.reconst.gqi.OdfModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.gqi.OdfModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.OdfModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.gqi.OdfModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.OdfModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="equatorial-maximum">
<h3>equatorial_maximum<a class="headerlink" href="#equatorial-maximum" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.equatorial_maximum">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">equatorial_maximum</code><span class="sig-paren">(</span><em>vertices</em>, <em>odf</em>, <em>pole</em>, <em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.equatorial_maximum" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="equatorial-zone-vertices">
<h3>equatorial_zone_vertices<a class="headerlink" href="#equatorial-zone-vertices" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.equatorial_zone_vertices">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">equatorial_zone_vertices</code><span class="sig-paren">(</span><em>vertices</em>, <em>pole</em>, <em>width=5</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.equatorial_zone_vertices" title="Permalink to this definition"></a></dt>
<dd><p>finds the vertices in the equatorial zone conjugate
to pole with width half width degrees</p>
</dd></dl>

</div>
<div class="section" id="gfa">
<h3>gfa<a class="headerlink" href="#gfa" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.gfa">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">gfa</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.gfa" title="Permalink to this definition"></a></dt>
<dd><p>The general fractional anisotropy of a function evaluated
on the unit sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Values of data on the unit sphere.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gfa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">GFA evaluated in each entry of the array, along the last dimension.
An <cite>np.nan</cite> is returned for coordinates that contain all-zeros in
<cite>samples</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The GFA is defined as <a class="reference internal" href="#r63839d04855f-1" id="id417">[1]</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">sqrt</span><span class="p">{</span>\<span class="n">frac</span><span class="p">{</span><span class="n">n</span> \<span class="n">sum_i</span><span class="p">{(</span>\<span class="n">Psi_i</span> <span class="o">-</span> <span class="o">&lt;</span>\<span class="n">Psi</span><span class="o">&gt;</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">}}{(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> \<span class="nb">sum</span><span class="p">{</span>\<span class="n">Psi_i</span> <span class="o">^</span> <span class="mi">2</span><span class="p">}}}</span>
</pre></div>
</div>
<p>Where <span class="math notranslate nohighlight">\(\Psi\)</span> is an orientation distribution function sampled discretely on
the unit sphere and angle brackets denote average over the samples on the
sphere.</p>
<table class="docutils citation" frame="void" id="r63839d04855f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id417">[1]</a></td><td>Quality assessment of High Angular Resolution Diffusion Imaging
data using bootstrap on Q-ball reconstruction. J. Cohen Adad, M.
Descoteaux, L.L. Wald. JMRI 33: 1194-1208.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id418">
<h3>local_maxima<a class="headerlink" href="#id418" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.local_maxima">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">local_maxima</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.local_maxima" title="Permalink to this definition"></a></dt>
<dd><p>Local maxima of a function evaluated on a discrete set of points.</p>
<p>If a function is evaluated on some set of points where each pair of
neighboring points is an edge in edges, find the local maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, 1d, dtype=double</span></dt>
<dd><p class="first last">The function evaluated on a set of discrete points.</p>
</dd>
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, 2)</span></dt>
<dd><p class="first last">The set of neighbor relations between the points. Every edge, ie
<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>peak_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Value of odf at a maximum point. Peak values is sorted in descending
order.</p>
</dd>
<dt><strong>peak_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so
<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="dipy.core.html#module-dipy.core.sphere" title="dipy.core.sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dipy.core.sphere</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="id419">
<h3>multi_voxel_fit<a class="headerlink" href="#id419" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.multi_voxel_fit">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="normalize-qa">
<h3>normalize_qa<a class="headerlink" href="#normalize-qa" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.normalize_qa">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">normalize_qa</code><span class="sig-paren">(</span><em>qa</em>, <em>max_qa=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.normalize_qa" title="Permalink to this definition"></a></dt>
<dd><p>Normalize quantitative anisotropy.</p>
<p>Used mostly with GQI rather than GQI2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (X, Y, Z, N)</span></dt>
<dd><p class="first last">where N is the maximum number of peaks stored</p>
</dd>
<dt><strong>max_qa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">maximum qa value. Usually found in the CSF (corticospinal fluid).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nqa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (x, Y, Z, N)</span></dt>
<dd><p class="first last">normalized quantitative anisotropy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Normalized quantitative anisotropy has the very useful property
to be very small near gray matter and background areas. Therefore,
it can be used to mask out white matter areas.</p>
</dd></dl>

</div>
<div class="section" id="npa">
<h3>npa<a class="headerlink" href="#npa" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.npa">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">npa</code><span class="sig-paren">(</span><em>self</em>, <em>odf</em>, <em>width=5</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.npa" title="Permalink to this definition"></a></dt>
<dd><p>non-parametric anisotropy</p>
<p>Nimmo-Smith et al.  ISMRM 2011</p>
</dd></dl>

</div>
<div class="section" id="odf-sum">
<h3>odf_sum<a class="headerlink" href="#odf-sum" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.odf_sum">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">odf_sum</code><span class="sig-paren">(</span><em>odf</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.odf_sum" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="patch-maximum">
<h3>patch_maximum<a class="headerlink" href="#patch-maximum" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.patch_maximum">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">patch_maximum</code><span class="sig-paren">(</span><em>vertices</em>, <em>odf</em>, <em>pole</em>, <em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.patch_maximum" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="patch-sum">
<h3>patch_sum<a class="headerlink" href="#patch-sum" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.patch_sum">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">patch_sum</code><span class="sig-paren">(</span><em>vertices</em>, <em>odf</em>, <em>pole</em>, <em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.patch_sum" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="patch-vertices">
<h3>patch_vertices<a class="headerlink" href="#patch-vertices" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.patch_vertices">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">patch_vertices</code><span class="sig-paren">(</span><em>vertices</em>, <em>pole</em>, <em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.patch_vertices" title="Permalink to this definition"></a></dt>
<dd><p>find vertices within the cone of width degrees around pole</p>
</dd></dl>

</div>
<div class="section" id="polar-zone-vertices">
<h3>polar_zone_vertices<a class="headerlink" href="#polar-zone-vertices" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.polar_zone_vertices">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">polar_zone_vertices</code><span class="sig-paren">(</span><em>vertices</em>, <em>pole</em>, <em>width=5</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.polar_zone_vertices" title="Permalink to this definition"></a></dt>
<dd><p>finds the vertices in the equatorial band around
the pole of radius width degrees</p>
</dd></dl>

</div>
<div class="section" id="remove-similar-vertices">
<h3>remove_similar_vertices<a class="headerlink" href="#remove-similar-vertices" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.remove_similar_vertices">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">remove_similar_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.remove_similar_vertices" title="Permalink to this definition"></a></dt>
<dd><p>Remove vertices that are less than <cite>theta</cite> degrees from any other</p>
<p>Returns vertices that are at least theta degrees from any other vertex.
Vertex v and -v are considered the same so if v and -v are both in
<cite>vertices</cite> only one is kept. Also if v and w are both in vertices, w must
be separated by theta degrees from both v and -v to be unique.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 3) ndarray</span></dt>
<dd><p class="first last">N unit vectors.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum separation between vertices in degrees.</p>
</dd>
<dt><strong>return_mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{False, True}, optional</span></dt>
<dd><p class="first last">If True, return <cite>mapping</cite> as well as <cite>vertices</cite> and maybe <cite>indices</cite>
(see below).</p>
</dd>
<dt><strong>return_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{False, True}, optional</span></dt>
<dd><p class="first last">If True, return <cite>indices</cite> as well as <cite>vertices</cite> and maybe <cite>mapping</cite>
(see below).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>unique_vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, 3) ndarray</span></dt>
<dd><p class="first last">Vertices sufficiently separated from one another.</p>
</dd>
<dt><strong>mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last">For each element <code class="docutils literal notranslate"><span class="pre">vertices[i]</span></code> (<span class="math notranslate nohighlight">\(i \in 0..N-1\)</span>), the index <span class="math notranslate nohighlight">\(j\)</span> to a
vertex in <cite>unique_vertices</cite> that is less than <cite>theta</cite> degrees from
<code class="docutils literal notranslate"><span class="pre">vertices[i]</span></code>.  Only returned if <cite>return_mapping</cite> is True.</p>
</dd>
<dt><strong>indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last"><cite>indices</cite> gives the reverse of <cite>mapping</cite>.  For each element
<code class="docutils literal notranslate"><span class="pre">unique_vertices[j]</span></code> (<span class="math notranslate nohighlight">\(j \in 0..M-1\)</span>), the index <span class="math notranslate nohighlight">\(i\)</span> to a vertex in
<cite>vertices</cite> that is less than <cite>theta</cite> degrees from
<code class="docutils literal notranslate"><span class="pre">unique_vertices[j]</span></code>.  If there is more than one element of
<cite>vertices</cite> that is less than theta degrees from <cite>unique_vertices[j]</cite>,
return the first (lowest index) matching value.  Only return if
<cite>return_indices</cite> is True.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="squared-radial-component">
<h3>squared_radial_component<a class="headerlink" href="#squared-radial-component" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.squared_radial_component">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">squared_radial_component</code><span class="sig-paren">(</span><em>x</em>, <em>tol=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.squared_radial_component" title="Permalink to this definition"></a></dt>
<dd><p>Part of the GQI2 integral</p>
<p>Eq.8 in the referenced paper by Yeh et al. 2010</p>
</dd></dl>

</div>
<div class="section" id="triple-odf-maxima">
<h3>triple_odf_maxima<a class="headerlink" href="#triple-odf-maxima" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.triple_odf_maxima">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">triple_odf_maxima</code><span class="sig-paren">(</span><em>vertices</em>, <em>odf</em>, <em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.triple_odf_maxima" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="upper-hemi-map">
<h3>upper_hemi_map<a class="headerlink" href="#upper-hemi-map" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.gqi.upper_hemi_map">
<code class="descclassname">dipy.reconst.gqi.</code><code class="descname">upper_hemi_map</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.gqi.upper_hemi_map" title="Permalink to this definition"></a></dt>
<dd><p>maps a 3-vector into the z-upper hemisphere</p>
</dd></dl>

</div>
<div class="section" id="interpolator">
<h3><a class="reference internal" href="#dipy.reconst.interpolate.Interpolator" title="dipy.reconst.interpolate.Interpolator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Interpolator</span></code></a><a class="headerlink" href="#interpolator" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.interpolate.Interpolator">
<em class="property">class </em><code class="descclassname">dipy.reconst.interpolate.</code><code class="descname">Interpolator</code><span class="sig-paren">(</span><em>data</em>, <em>voxel_size</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.interpolate.Interpolator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class to be subclassed by different interpolator types</p>
<dl class="method">
<dt id="dipy.reconst.interpolate.Interpolator.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data</em>, <em>voxel_size</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.interpolate.Interpolator.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nearestneighborinterpolator">
<h3><a class="reference internal" href="#dipy.reconst.interpolate.NearestNeighborInterpolator" title="dipy.reconst.interpolate.NearestNeighborInterpolator"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborInterpolator</span></code></a><a class="headerlink" href="#nearestneighborinterpolator" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.interpolate.NearestNeighborInterpolator">
<em class="property">class </em><code class="descclassname">dipy.reconst.interpolate.</code><code class="descname">NearestNeighborInterpolator</code><span class="sig-paren">(</span><em>data</em>, <em>voxel_size</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.interpolate.NearestNeighborInterpolator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.interpolate.Interpolator" title="dipy.reconst.interpolate.Interpolator"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.interpolate.Interpolator</span></code></a></p>
<p>Interpolates data using nearest neighbor interpolation</p>
<dl class="method">
<dt id="dipy.reconst.interpolate.NearestNeighborInterpolator.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data</em>, <em>voxel_size</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.interpolate.NearestNeighborInterpolator.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="outsideimage">
<h3><a class="reference internal" href="#dipy.reconst.interpolate.OutsideImage" title="dipy.reconst.interpolate.OutsideImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OutsideImage</span></code></a><a class="headerlink" href="#outsideimage" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.interpolate.OutsideImage">
<em class="property">class </em><code class="descclassname">dipy.reconst.interpolate.</code><code class="descname">OutsideImage</code><a class="headerlink" href="#dipy.reconst.interpolate.OutsideImage" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>args</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">with_traceback</span></code></td>
<td>Exception.with_traceback(tb)  set self.__traceback__ to tb and return self.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.interpolate.OutsideImage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.interpolate.OutsideImage.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="trilinearinterpolator">
<h3><a class="reference internal" href="#dipy.reconst.interpolate.TriLinearInterpolator" title="dipy.reconst.interpolate.TriLinearInterpolator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriLinearInterpolator</span></code></a><a class="headerlink" href="#trilinearinterpolator" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.interpolate.TriLinearInterpolator">
<em class="property">class </em><code class="descclassname">dipy.reconst.interpolate.</code><code class="descname">TriLinearInterpolator</code><span class="sig-paren">(</span><em>data</em>, <em>voxel_size</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.interpolate.TriLinearInterpolator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.interpolate.Interpolator" title="dipy.reconst.interpolate.Interpolator"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.interpolate.Interpolator</span></code></a></p>
<p>Interpolates data using trilinear interpolation</p>
<p>interpolate 4d diffusion volume using 3 indices, ie data[x, y, z]</p>
<dl class="method">
<dt id="dipy.reconst.interpolate.TriLinearInterpolator.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data</em>, <em>voxel_size</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.interpolate.TriLinearInterpolator.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="array">
<h3>array<a class="headerlink" href="#array" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.interpolate.array">
<code class="descclassname">dipy.reconst.interpolate.</code><code class="descname">array</code><span class="sig-paren">(</span><em>object</em>, <em>dtype=None</em>, <em>copy=True</em>, <em>order='K'</em>, <em>subok=False</em>, <em>ndmin=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.interpolate.array" title="Permalink to this definition"></a></dt>
<dd><p>Create an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>object</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">An array, any object exposing the array interface, an object whose
__array__ method returns an array, or any (nested) sequence.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd><p class="first last">The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.  This argument can only be used to upcast the array.  For
downcasting, use the .astype(t) method.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If true (default), then the object is copied.  Otherwise, a copy will
only be made if __array__ returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<cite>dtype</cite>, <cite>order</cite>, etc.).</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{K, A, C, F}, optional</span></dt>
<dd><p class="first">Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless F is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="14%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">order</th>
<th class="head">no copy</th>
<th class="head">copy=True</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>K</td>
<td>unchanged</td>
<td>F &amp; C order preserved, otherwise most similar order</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>unchanged</td>
<td>F order if input is F and not C, otherwise C order</td>
</tr>
<tr class="row-even"><td>C</td>
<td>C order</td>
<td>C order</td>
</tr>
<tr class="row-odd"><td>F</td>
<td>F order</td>
<td>F order</td>
</tr>
</tbody>
</table>
<p class="last">When <code class="docutils literal notranslate"><span class="pre">copy=False</span></code> and a copy is made for other reasons, the result is
the same as if <code class="docutils literal notranslate"><span class="pre">copy=True</span></code>, with some exceptions for <cite>A</cite>, see the
Notes section. The default order is K.</p>
</dd>
<dt><strong>subok</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</p>
</dd>
<dt><strong>ndmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">An array object satisfying the specified requirements.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_like</span></code></dt>
<dd>Return an empty array with shape and type of input.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones_like</span></code></dt>
<dd>Return an array of ones with shape and type of input.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros_like</span></code></dt>
<dd>Return an array of zeros with shape and type of input.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">full_like</span></code></dt>
<dd>Return a new array with shape of input filled with value.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></dt>
<dd>Return a new uninitialized array.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></dt>
<dd>Return a new array setting values to one.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></dt>
<dd>Return a new array setting values to zero.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></dt>
<dd>Return a new array of given shape filled with value.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When order is A and <cite>object</cite> is an array in neither C nor F order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily C as expected. This is likely a bug.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Upcasting:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="go">array([ 1.,  2.,  3.])</span>
</pre></div>
</div>
<p>More than one dimension:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Minimum dimensions 2:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[1, 2, 3]])</span>
</pre></div>
</div>
<p>Type provided:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="go">array([ 1.+0.j,  2.+0.j,  3.+0.j])</span>
</pre></div>
</div>
<p>Data-type consisting of more than one element:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">),(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<p>Creating an array from sub-classes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="trilinear-interp">
<h3>trilinear_interp<a class="headerlink" href="#trilinear-interp" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.interpolate.trilinear_interp">
<code class="descclassname">dipy.reconst.interpolate.</code><code class="descname">trilinear_interp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.interpolate.trilinear_interp" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates vector from 4D <cite>data</cite> at 3D point given by <cite>index</cite></p>
<p>Interpolates a vector of length T from a 4D volume of shape (I, J, K, T),
given point (x, y, z) where (x, y, z) are the coordinates of the point in
real units (not yet adjusted for voxel size).</p>
</dd></dl>

</div>
<div class="section" id="ivimfit">
<h3><a class="reference internal" href="#dipy.reconst.ivim.IvimFit" title="dipy.reconst.ivim.IvimFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimFit</span></code></a><a class="headerlink" href="#ivimfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.ivim.IvimFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.ivim.</code><code class="descname">IvimFit</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>D</strong></dt>
<dd></dd>
<dt><strong>D_star</strong></dt>
<dd></dd>
<dt><strong>S0_predicted</strong></dt>
<dd></dd>
<dt><strong>perfusion_fraction</strong></dt>
<dd></dd>
<dt><strong>shape</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.ivim.IvimFit.predict" title="dipy.reconst.ivim.IvimFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(gtab[,&nbsp;S0])</td>
<td>Given a model fit, predict the signal.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.ivim.IvimFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>model_params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a IvimFit class instance.
Parameters
-
model : Model class
model_params : array</p>
<blockquote>
<div>The parameters of the model. In this case it is an
array of ivim parameters. If the fitting is done
for multi_voxel data, the multi_voxel decorator will
run the fitting on all the voxels and model_params
will be an array of the dimensions (data[:-1], 4),
i.e., there will be 4 parameters for each of the voxels.</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.ivim.IvimFit.D">
<code class="descname">D</code><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.D" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.ivim.IvimFit.D_star">
<code class="descname">D_star</code><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.D_star" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.ivim.IvimFit.S0_predicted">
<code class="descname">S0_predicted</code><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.S0_predicted" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.ivim.IvimFit.perfusion_fraction">
<code class="descname">perfusion_fraction</code><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.perfusion_fraction" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.ivim.IvimFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Given a model fit, predict the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd><p class="first last">Gradient directions and bvalues</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">S0 value here is not necessary and will not be used to predict the
signal. It has been added to conform to the structure of the
predict method in multi_voxel which requires a keyword argument S0.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The signal values predicted for this model using its parameters.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.ivim.IvimFit.shape">
<code class="descname">shape</code><a class="headerlink" href="#dipy.reconst.ivim.IvimFit.shape" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="ivimmodel">
<h3><a class="reference internal" href="#dipy.reconst.ivim.IvimModel" title="dipy.reconst.ivim.IvimModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">IvimModel</span></code></a><a class="headerlink" href="#ivimmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.ivim.IvimModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.ivim.</code><code class="descname">IvimModel</code><span class="sig-paren">(</span><em>gtab, split_b_D=400.0, split_b_S0=200.0, bounds=None, two_stage=True, tol=1e-15, x_scale=[1000.0, 0.1, 0.001, 0.0001], options={'eps': 1e-15, 'ftol': 1e-15, 'gtol': 1e-15, 'maxiter': 1000}</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>Ivim model</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.ivim.IvimModel.estimate_f_D_star" title="dipy.reconst.ivim.IvimModel.estimate_f_D_star"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_f_D_star</span></code></a>(params_f_D_star,&nbsp;data,&nbsp;S0,&nbsp;D)</td>
<td>Estimate f and D_star using the values of all the other parameters obtained from a linear fit.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.ivim.IvimModel.estimate_linear_fit" title="dipy.reconst.ivim.IvimModel.estimate_linear_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_linear_fit</span></code></a>(data,&nbsp;split_b[,&nbsp;less_than])</td>
<td>Estimate a linear fit by taking log of data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.ivim.IvimModel.fit" title="dipy.reconst.ivim.IvimModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.ivim.IvimModel.predict" title="dipy.reconst.ivim.IvimModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(ivim_params,&nbsp;gtab[,&nbsp;S0])</td>
<td>Predict a signal for this IvimModel class instance given parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.ivim.IvimModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab, split_b_D=400.0, split_b_S0=200.0, bounds=None, two_stage=True, tol=1e-15, x_scale=[1000.0, 0.1, 0.001, 0.0001], options={'eps': 1e-15, 'ftol': 1e-15, 'gtol': 1e-15, 'maxiter': 1000}</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize an IVIM model.</p>
<p>The IVIM model assumes that biological tissue includes a volume
fraction f of water flowing with a pseudo-perfusion coefficient
D* and a fraction (1-f) of static (diffusion only), intra and
extracellular water, with a diffusion coefficient D. In this model
the echo attenuation of a signal in a single voxel can be written as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\]</div>
<p>S(b) = S_0[f*e^{(-b*D*)} + (1-f)e^{(-b*D)}]</p>
<p>Where:
.. math:</p>
<p>S_0, f, D* and D are the IVIM parameters.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd><p class="first last">Gradient directions and bvalues</p>
</dd>
<dt><strong>split_b_D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">The b-value to split the data on for two-stage fit. This will be
used while estimating the value of D. The assumption is that at
higher b values the effects of perfusion is less and hence the
signal can be approximated as a mono-exponential decay.
default : 400.</p>
</dd>
<dt><strong>split_b_S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">The b-value to split the data on for two-stage fit for estimation
of S0 and initial guess for D_star. The assumption here is that
at low bvalues the effects of perfusion are more.
default : 200.</p>
</dd>
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of arrays with 4 elements, optional</span></dt>
<dd><p class="first last">Bounds to constrain the fitted model parameters. This is only
supported for Scipy version &gt; 0.17. When using a older Scipy
version, this function will raise an error if bounds are different
from None. This parameter is also used to fill nan values for out
of bounds parameters in the <cite>IvimFit</cite> class using the method
fill_na. default : ([0., 0., 0., 0.], [np.inf, .3, 1., 1.])</p>
</dd>
<dt><strong>two_stage</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Argument to specify whether to perform a non-linear fitting of all
parameters after the linear fitting by splitting the data based on
bvalues. This gives more accurate parameters but takes more time.
The linear fit can be used to get a quick estimation of the
parameters. default : False</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Tolerance for convergence of minimization.
default : 1e-15</p>
</dd>
<dt><strong>x_scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd><p class="first last">Scaling for the parameters. This is passed to <cite>least_squares</cite> which
is only available for Scipy version &gt; 0.17.
default: [1000, 0.01, 0.001, 0.0001]</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first">Dictionary containing gtol, ftol, eps and maxiter. This is passed
to leastsq.
default : options={gtol: 1e-15, ftol: 1e-15, eps: 1e-15,</p>
<blockquote class="last">
<div><p>maxiter: 1000}</p>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r6cfa59d9b0ea-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id420">[1]</a></td><td>Le Bihan, Denis, et al. Separation of diffusion and perfusion
in intravoxel incoherent motion MR imaging. Radiology 168.2
(1988): 497-505.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6cfa59d9b0ea-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id421">[2]</a></td><td>Federau, Christian, et al. Quantitative measurement of brain
perfusion with intravoxel incoherent motion MR imaging.
Radiology 265.3 (2012): 874-881.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.ivim.IvimModel.estimate_f_D_star">
<code class="descname">estimate_f_D_star</code><span class="sig-paren">(</span><em>params_f_D_star</em>, <em>data</em>, <em>S0</em>, <em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModel.estimate_f_D_star" title="Permalink to this definition"></a></dt>
<dd><p>Estimate f and D_star using the values of all the other parameters
obtained from a linear fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>params_f_D_star: array</strong></dt>
<dd><p class="first last">An array containing the value of f and D_star.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array containing the actual signal values.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The parameters S0 obtained from a linear fit.</p>
</dd>
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The parameters D obtained from a linear fit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>f</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Perfusion fraction estimated from the fit.</p>
</dd>
<dt><strong>D_star :</strong></dt>
<dd><p class="first last">The value of D_star estimated from the fit.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.ivim.IvimModel.estimate_linear_fit">
<code class="descname">estimate_linear_fit</code><span class="sig-paren">(</span><em>data</em>, <em>split_b</em>, <em>less_than=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModel.estimate_linear_fit" title="Permalink to this definition"></a></dt>
<dd><p>Estimate a linear fit by taking log of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array containing the data to be fit</p>
</dd>
<dt><strong>split_b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The b value to split the data</p>
</dd>
<dt><strong>less_than</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, splitting occurs for bvalues less than split_b</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The estimated S0 value. (intercept)</p>
</dd>
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The estimated value of D.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.ivim.IvimModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.ivim.IvimModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>ivim_params</em>, <em>gtab</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.IvimModel.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict a signal for this IvimModel class instance given parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ivim_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The ivim parameters as an array [S0, f, D_star and D]</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd><p class="first last">Gradient directions and bvalues.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">This has been added just for consistency with the existing
API. Unlike other models, IVIM predicts S0 and this is over written
by the S0 value in params.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ivim_signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The predicted IVIM signal using given parameters.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="looseversion">
<h3><a class="reference internal" href="#dipy.reconst.ivim.LooseVersion" title="dipy.reconst.ivim.LooseVersion"><code class="xref py py-class docutils literal notranslate"><span class="pre">LooseVersion</span></code></a><a class="headerlink" href="#looseversion" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.ivim.LooseVersion">
<em class="property">class </em><code class="descclassname">dipy.reconst.ivim.</code><code class="descname">LooseVersion</code><span class="sig-paren">(</span><em>vstring=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.LooseVersion" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">distutils.version.Version</span></code></p>
<p>Version numbering for anarchists and software realists.
Implements the standard interface for version number classes as
described above.  A version number consists of a series of numbers,
separated by either periods or strings of letters.  When comparing
version numbers, the numeric components will be compared
numerically, and the alphabetic components lexically.  The following
are all valid version numbers, in no particular order:</p>
<blockquote>
<div>1.5.1
1.5.2b2
161
3.10a
8.02
3.4j
1996.07.12
3.2.pl0
3.1.1.6
2g6
11g
0.960923
2.2beta29
1.13++
5.5.kw
2.0b1pl0</div></blockquote>
<p>In fact, there is no such thing as an invalid version number under
this scheme; the rules for comparison are simple and predictable,
but may not always give the results you want (for some definition
of want).</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>parse</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.ivim.LooseVersion.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>vstring=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.LooseVersion.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.ivim.LooseVersion.component_re">
<code class="descname">component_re</code><em class="property"> = re.compile('(\\d+ | [a-z]+ | \\.)', re.VERBOSE)</em><a class="headerlink" href="#dipy.reconst.ivim.LooseVersion.component_re" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.ivim.LooseVersion.parse">
<code class="descname">parse</code><span class="sig-paren">(</span><em>vstring</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.LooseVersion.parse" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id422">
<h3><a class="reference internal" href="#dipy.reconst.ivim.ReconstModel" title="dipy.reconst.ivim.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#id422" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.ivim.ReconstModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.ivim.</code><code class="descname">ReconstModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.ReconstModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.ivim.ReconstModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.ReconstModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.ivim.ReconstModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.ReconstModel.fit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="f-d-star-error">
<h3>f_D_star_error<a class="headerlink" href="#f-d-star-error" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.ivim.f_D_star_error">
<code class="descclassname">dipy.reconst.ivim.</code><code class="descname">f_D_star_error</code><span class="sig-paren">(</span><em>params</em>, <em>gtab</em>, <em>signal</em>, <em>S0</em>, <em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.f_D_star_error" title="Permalink to this definition"></a></dt>
<dd><p>Error function used to fit f and D_star keeping S0 and D fixed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The value of f and D_star.</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd><p class="first last">Gradient directions and bvalues.</p>
</dd>
<dt><strong>signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array containing the actual signal values.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The parameters S0 obtained from a linear fit.</p>
</dd>
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The parameters D obtained from a linear fit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>residual</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array containing the difference of actual and estimated signal.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="f-d-star-prediction">
<h3>f_D_star_prediction<a class="headerlink" href="#f-d-star-prediction" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.ivim.f_D_star_prediction">
<code class="descclassname">dipy.reconst.ivim.</code><code class="descname">f_D_star_prediction</code><span class="sig-paren">(</span><em>params</em>, <em>gtab</em>, <em>S0</em>, <em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.f_D_star_prediction" title="Permalink to this definition"></a></dt>
<dd><p>Function used to predict IVIM signal when S0 and D are known
by considering f and D_star as the unknown parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The value of f and D_star.</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd><p class="first last">Gradient directions and bvalues.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The parameters S0 obtained from a linear fit.</p>
</dd>
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The parameters D obtained from a linear fit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array containing the IVIM signal estimated using given parameters.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ivim-prediction">
<h3>ivim_prediction<a class="headerlink" href="#ivim-prediction" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.ivim.ivim_prediction">
<code class="descclassname">dipy.reconst.ivim.</code><code class="descname">ivim_prediction</code><span class="sig-paren">(</span><em>params</em>, <em>gtab</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.ivim_prediction" title="Permalink to this definition"></a></dt>
<dd><p>The Intravoxel incoherent motion (IVIM) model function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array of IVIM parameters - [S0, f, D_star, D].</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd><p class="first last">Gradient directions and bvalues.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">This has been added just for consistency with the existing
API. Unlike other models, IVIM predicts S0 and this is over written
by the S0 value in params.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array containing the IVIM signal estimated using given parameters.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="least-squares">
<h3>least_squares<a class="headerlink" href="#least-squares" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.ivim.least_squares">
<code class="descclassname">dipy.reconst.ivim.</code><code class="descname">least_squares</code><span class="sig-paren">(</span><em>fun</em>, <em>x0</em>, <em>jac='2-point'</em>, <em>bounds=(-inf</em>, <em>inf)</em>, <em>method='trf'</em>, <em>ftol=1e-08</em>, <em>xtol=1e-08</em>, <em>gtol=1e-08</em>, <em>x_scale=1.0</em>, <em>loss='linear'</em>, <em>f_scale=1.0</em>, <em>diff_step=None</em>, <em>tr_solver=None</em>, <em>tr_options={}</em>, <em>jac_sparsity=None</em>, <em>max_nfev=None</em>, <em>verbose=0</em>, <em>args=()</em>, <em>kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.least_squares" title="Permalink to this definition"></a></dt>
<dd><p>Solve a nonlinear least-squares problem with bounds on the variables.</p>
<p>Given the residuals f(x) (an m-dimensional real function of n real
variables) and the loss function rho(s) (a scalar function), <cite>least_squares</cite>
finds a local minimum of the cost function F(x):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">minimize</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rho</span><span class="p">(</span><span class="n">f_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">lb</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">ub</span>
</pre></div>
</div>
<p>The purpose of the loss function rho(s) is to reduce the influence of
outliers on the solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fun</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">Function which computes the vector of residuals, with the signature
<code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>, i.e., the minimization proceeds with
respect to its first argument. The argument <code class="docutils literal notranslate"><span class="pre">x</span></code> passed to this
function is an ndarray of shape (n,) (never a scalar, even for n=1).
It must return a 1-d array_like of shape (m,) or a scalar. If the
argument <code class="docutils literal notranslate"><span class="pre">x</span></code> is complex or the function <code class="docutils literal notranslate"><span class="pre">fun</span></code> returns complex
residuals, it must be wrapped in a real function of real arguments,
as shown at the end of the Examples section.</p>
</dd>
<dt><strong>x0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like with shape (n,) or float</span></dt>
<dd><p class="first last">Initial guess on independent variables. If float, it will be treated
as a 1-d array with one element.</p>
</dd>
<dt><strong>jac</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{2-point, 3-point, cs, callable}, optional</span></dt>
<dd><p class="first last">Method of computing the Jacobian matrix (an m-by-n matrix, where
element (i, j) is the partial derivative of f[i] with respect to
x[j]). The keywords select a finite difference scheme for numerical
estimation. The scheme 3-point is more accurate, but requires
twice as much operations compared to 2-point (default). The
scheme cs uses complex steps, and while potentially the most
accurate, it is applicable only when <cite>fun</cite> correctly handles
complex inputs and can be analytically continued to the complex
plane. Method lm always uses the 2-point scheme. If callable,
it is used as <code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> and should return a
good approximation (or the exact value) for the Jacobian as an
array_like (np.atleast_2d is applied), a sparse matrix or a
<cite>scipy.sparse.linalg.LinearOperator</cite>.</p>
</dd>
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-tuple of array_like, optional</span></dt>
<dd><p class="first last">Lower and upper bounds on independent variables. Defaults to no bounds.
Each array must match the size of <cite>x0</cite> or be a scalar, in the latter
case a bound will be the same for all variables. Use <code class="docutils literal notranslate"><span class="pre">np.inf</span></code> with
an appropriate sign to disable bounds on all or some variables.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{trf, dogbox, lm}, optional</span></dt>
<dd><p class="first">Algorithm to perform minimization.</p>
<blockquote>
<div><ul class="simple">
<li>trf : Trust Region Reflective algorithm, particularly suitable
for large sparse problems with bounds. Generally robust method.</li>
<li>dogbox : dogleg algorithm with rectangular trust regions,
typical use case is small problems with bounds. Not recommended
for problems with rank-deficient Jacobian.</li>
<li>lm : Levenberg-Marquardt algorithm as implemented in MINPACK.
Doesnt handle bounds and sparse Jacobians. Usually the most
efficient method for small unconstrained problems.</li>
</ul>
</div></blockquote>
<p class="last">Default is trf. See Notes for more information.</p>
</dd>
<dt><strong>ftol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Tolerance for termination by the change of the cost function. Default
is 1e-8. The optimization process is stopped when  <code class="docutils literal notranslate"><span class="pre">dF</span> <span class="pre">&lt;</span> <span class="pre">ftol</span> <span class="pre">*</span> <span class="pre">F</span></code>,
and there was an adequate agreement between a local quadratic model and
the true model in the last step.</p>
</dd>
<dt><strong>xtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first">Tolerance for termination by the change of the independent variables.
Default is 1e-8. The exact condition depends on the <cite>method</cite> used:</p>
<blockquote class="last">
<div><ul class="simple">
<li>For trf and dogbox : <code class="docutils literal notranslate"><span class="pre">norm(dx)</span> <span class="pre">&lt;</span> <span class="pre">xtol</span> <span class="pre">*</span> <span class="pre">(xtol</span> <span class="pre">+</span> <span class="pre">norm(x))</span></code></li>
<li>For lm : <code class="docutils literal notranslate"><span class="pre">Delta</span> <span class="pre">&lt;</span> <span class="pre">xtol</span> <span class="pre">*</span> <span class="pre">norm(xs)</span></code>, where <code class="docutils literal notranslate"><span class="pre">Delta</span></code> is
a trust-region radius and <code class="docutils literal notranslate"><span class="pre">xs</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">x</span></code>
scaled according to <cite>x_scale</cite> parameter (see below).</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>gtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first">Tolerance for termination by the norm of the gradient. Default is 1e-8.
The exact condition depends on a <cite>method</cite> used:</p>
<blockquote class="last">
<div><ul class="simple">
<li>For trf : <code class="docutils literal notranslate"><span class="pre">norm(g_scaled,</span> <span class="pre">ord=np.inf)</span> <span class="pre">&lt;</span> <span class="pre">gtol</span></code>, where
<code class="docutils literal notranslate"><span class="pre">g_scaled</span></code> is the value of the gradient scaled to account for
the presence of the bounds <a class="reference internal" href="#r1786fd6832dd-stir" id="id423">[STIR]</a>.</li>
<li>For dogbox : <code class="docutils literal notranslate"><span class="pre">norm(g_free,</span> <span class="pre">ord=np.inf)</span> <span class="pre">&lt;</span> <span class="pre">gtol</span></code>, where
<code class="docutils literal notranslate"><span class="pre">g_free</span></code> is the gradient with respect to the variables which
are not in the optimal state on the boundary.</li>
<li>For lm : the maximum absolute value of the cosine of angles
between columns of the Jacobian and the residual vector is less
than <cite>gtol</cite>, or the residual vector is zero.</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>x_scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like or jac, optional</span></dt>
<dd><p class="first last">Characteristic scale of each variable. Setting <cite>x_scale</cite> is equivalent
to reformulating the problem in scaled variables <code class="docutils literal notranslate"><span class="pre">xs</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">/</span> <span class="pre">x_scale</span></code>.
An alternative view is that the size of a trust region along j-th
dimension is proportional to <code class="docutils literal notranslate"><span class="pre">x_scale[j]</span></code>. Improved convergence may
be achieved by setting <cite>x_scale</cite> such that a step of a given size
along any of the scaled variables has a similar effect on the cost
function. If set to jac, the scale is iteratively updated using the
inverse norms of the columns of the Jacobian matrix (as described in
<a class="reference internal" href="#r1786fd6832dd-jjmore" id="id424">[JJMore]</a>).</p>
</dd>
<dt><strong>loss</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or callable, optional</span></dt>
<dd><p class="first">Determines the loss function. The following keyword values are allowed:</p>
<blockquote>
<div><ul class="simple">
<li>linear (default) : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">z</span></code>. Gives a standard
least-squares problem.</li>
<li>soft_l1 : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">((1</span> <span class="pre">+</span> <span class="pre">z)**0.5</span> <span class="pre">-</span> <span class="pre">1)</span></code>. The smooth
approximation of l1 (absolute value) loss. Usually a good
choice for robust least squares.</li>
<li>huber : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">z</span> <span class="pre">if</span> <span class="pre">z</span> <span class="pre">&lt;=</span> <span class="pre">1</span> <span class="pre">else</span> <span class="pre">2*z**0.5</span> <span class="pre">-</span> <span class="pre">1</span></code>. Works
similarly to soft_l1.</li>
<li>cauchy : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">ln(1</span> <span class="pre">+</span> <span class="pre">z)</span></code>. Severely weakens outliers
influence, but may cause difficulties in optimization process.</li>
<li>arctan : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">arctan(z)</span></code>. Limits a maximum loss on
a single residual, has properties similar to cauchy.</li>
</ul>
</div></blockquote>
<p class="last">If callable, it must take a 1-d ndarray <code class="docutils literal notranslate"><span class="pre">z=f**2</span></code> and return an
array_like with shape (3, m) where row 0 contains function values,
row 1 contains first derivatives and row 2 contains second
derivatives. Method lm supports only linear loss.</p>
</dd>
<dt><strong>f_scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value of soft margin between inlier and outlier residuals, default
is 1.0. The loss function is evaluated as follows
<code class="docutils literal notranslate"><span class="pre">rho_(f**2)</span> <span class="pre">=</span> <span class="pre">C**2</span> <span class="pre">*</span> <span class="pre">rho(f**2</span> <span class="pre">/</span> <span class="pre">C**2)</span></code>, where <code class="docutils literal notranslate"><span class="pre">C</span></code> is <cite>f_scale</cite>,
and <code class="docutils literal notranslate"><span class="pre">rho</span></code> is determined by <cite>loss</cite> parameter. This parameter has
no effect with <code class="docutils literal notranslate"><span class="pre">loss='linear'</span></code>, but for other <cite>loss</cite> values it is
of crucial importance.</p>
</dd>
<dt><strong>max_nfev</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or int, optional</span></dt>
<dd><p class="first">Maximum number of function evaluations before the termination.
If None (default), the value is chosen automatically:</p>
<blockquote class="last">
<div><ul class="simple">
<li>For trf and dogbox : 100 * n.</li>
<li>For lm :  100 * n if <cite>jac</cite> is callable and 100 * n * (n + 1)
otherwise (because lm counts function calls in Jacobian
estimation).</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>diff_step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or array_like, optional</span></dt>
<dd><p class="first last">Determines the relative step size for the finite difference
approximation of the Jacobian. The actual step is computed as
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">diff_step</span></code>. If None (default), then <cite>diff_step</cite> is taken to be
a conventional optimal power of machine epsilon for the finite
difference scheme used <a class="reference internal" href="#r1786fd6832dd-nr" id="id425">[NR]</a>.</p>
</dd>
<dt><strong>tr_solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, exact, lsmr}, optional</span></dt>
<dd><p class="first">Method for solving trust-region subproblems, relevant only for trf
and dogbox methods.</p>
<blockquote>
<div><ul class="simple">
<li>exact is suitable for not very large problems with dense
Jacobian matrices. The computational complexity per iteration is
comparable to a singular value decomposition of the Jacobian
matrix.</li>
<li>lsmr is suitable for problems with sparse and large Jacobian
matrices. It uses the iterative procedure
<cite>scipy.sparse.linalg.lsmr</cite> for finding a solution of a linear
least-squares problem and only requires matrix-vector product
evaluations.</li>
</ul>
</div></blockquote>
<p class="last">If None (default) the solver is chosen based on the type of Jacobian
returned on the first iteration.</p>
</dd>
<dt><strong>tr_options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first">Keyword options passed to trust-region solver.</p>
<blockquote class="last">
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">tr_solver='exact'</span></code>: <cite>tr_options</cite> are ignored.</li>
<li><code class="docutils literal notranslate"><span class="pre">tr_solver='lsmr'</span></code>: options for <cite>scipy.sparse.linalg.lsmr</cite>.
Additionally  <code class="docutils literal notranslate"><span class="pre">method='trf'</span></code> supports  regularize option
(bool, default is True) which adds a regularization term to the
normal equation, which improves convergence if the Jacobian is
rank-deficient <a class="reference internal" href="#r1786fd6832dd-byrd" id="id426">[Byrd]</a> (eq. 3.4).</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>jac_sparsity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, array_like, sparse matrix}, optional</span></dt>
<dd><p class="first last">Defines the sparsity structure of the Jacobian matrix for finite
difference estimation, its shape must be (m, n). If the Jacobian has
only few non-zero elements in <em>each</em> row, providing the sparsity
structure will greatly speed up the computations <a class="reference internal" href="#r1786fd6832dd-curtis" id="id427">[Curtis]</a>. A zero
entry means that a corresponding element in the Jacobian is identically
zero. If provided, forces the use of lsmr trust-region solver.
If None (default) then dense differencing will be used. Has no effect
for lm method.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{0, 1, 2}, optional</span></dt>
<dd><p class="first">Level of algorithms verbosity:</p>
<blockquote class="last">
<div><ul class="simple">
<li>0 (default) : work silently.</li>
<li>1 : display a termination report.</li>
<li>2 : display progress during iterations (not supported by lm
method).</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>args, kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple and dict, optional</span></dt>
<dd><p class="first last">Additional arguments passed to <cite>fun</cite> and <cite>jac</cite>. Both empty by default.
The calling signature is <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> and the same for
<cite>jac</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>`OptimizeResult` with the following fields defined:</strong></dt>
<dd></dd>
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n,)</span></dt>
<dd><p class="first last">Solution found.</p>
</dd>
<dt><strong>cost</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Value of the cost function at the solution.</p>
</dd>
<dt><strong>fun</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (m,)</span></dt>
<dd><p class="first last">Vector of residuals at the solution.</p>
</dd>
<dt><strong>jac</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, sparse matrix or LinearOperator, shape (m, n)</span></dt>
<dd><p class="first last">Modified Jacobian matrix at the solution, in the sense that J^T J
is a Gauss-Newton approximation of the Hessian of the cost function.
The type is the same as the one used by the algorithm.</p>
</dd>
<dt><strong>grad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (m,)</span></dt>
<dd><p class="first last">Gradient of the cost function at the solution.</p>
</dd>
<dt><strong>optimality</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">First-order optimality measure. In unconstrained problems, it is always
the uniform norm of the gradient. In constrained problems, it is the
quantity which was compared with <cite>gtol</cite> during iterations.</p>
</dd>
<dt><strong>active_mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of int, shape (n,)</span></dt>
<dd><p class="first">Each component shows whether a corresponding constraint is active
(that is, whether a variable is at the bound):</p>
<blockquote>
<div><ul class="simple">
<li>0 : a constraint is not active.</li>
<li>-1 : a lower bound is active.</li>
<li>1 : an upper bound is active.</li>
</ul>
</div></blockquote>
<p class="last">Might be somewhat arbitrary for trf method as it generates a sequence
of strictly feasible iterates and <cite>active_mask</cite> is determined within a
tolerance threshold.</p>
</dd>
<dt><strong>nfev</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of function evaluations done. Methods trf and dogbox do not
count function calls for numerical Jacobian approximation, as opposed
to lm method.</p>
</dd>
<dt><strong>njev</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd><p class="first last">Number of Jacobian evaluations done. If numerical Jacobian
approximation is used in lm method, it is set to None.</p>
</dd>
<dt><strong>status</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">The reason for algorithm termination:</p>
<blockquote class="last">
<div><ul class="simple">
<li>-1 : improper input parameters status returned from MINPACK.</li>
<li>0 : the maximum number of function evaluations is exceeded.</li>
<li>1 : <cite>gtol</cite> termination condition is satisfied.</li>
<li>2 : <cite>ftol</cite> termination condition is satisfied.</li>
<li>3 : <cite>xtol</cite> termination condition is satisfied.</li>
<li>4 : Both <cite>ftol</cite> and <cite>xtol</cite> termination conditions are satisfied.</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>message</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Verbal description of the termination reason.</p>
</dd>
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if one of the convergence criteria is satisfied (<cite>status</cite> &gt; 0).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">leastsq</span></code></dt>
<dd>A legacy wrapper for the MINPACK implementation of the Levenberg-Marquadt algorithm.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">curve_fit</span></code></dt>
<dd>Least-squares minimization applied to a curve fitting problem.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Method lm (Levenberg-Marquardt) calls a wrapper over least-squares
algorithms implemented in MINPACK (lmder, lmdif). It runs the
Levenberg-Marquardt algorithm formulated as a trust-region type algorithm.
The implementation is based on paper <a class="reference internal" href="#r1786fd6832dd-jjmore" id="id428">[JJMore]</a>, it is very robust and
efficient with a lot of smart tricks. It should be your first choice
for unconstrained problems. Note that it doesnt support bounds. Also
it doesnt work when m &lt; n.</p>
<p>Method trf (Trust Region Reflective) is motivated by the process of
solving a system of equations, which constitute the first-order optimality
condition for a bound-constrained minimization problem as formulated in
<a class="reference internal" href="#r1786fd6832dd-stir" id="id429">[STIR]</a>. The algorithm iteratively solves trust-region subproblems
augmented by a special diagonal quadratic term and with trust-region shape
determined by the distance from the bounds and the direction of the
gradient. This enhancements help to avoid making steps directly into bounds
and efficiently explore the whole space of variables. To further improve
convergence, the algorithm considers search directions reflected from the
bounds. To obey theoretical requirements, the algorithm keeps iterates
strictly feasible. With dense Jacobians trust-region subproblems are
solved by an exact method very similar to the one described in <a class="reference internal" href="#r1786fd6832dd-jjmore" id="id430">[JJMore]</a>
(and implemented in MINPACK). The difference from the MINPACK
implementation is that a singular value decomposition of a Jacobian
matrix is done once per iteration, instead of a QR decomposition and series
of Givens rotation eliminations. For large sparse Jacobians a 2-d subspace
approach of solving trust-region subproblems is used <a class="reference internal" href="#r1786fd6832dd-stir" id="id431">[STIR]</a>, <a class="reference internal" href="#r1786fd6832dd-byrd" id="id432">[Byrd]</a>.
The subspace is spanned by a scaled gradient and an approximate
Gauss-Newton solution delivered by <cite>scipy.sparse.linalg.lsmr</cite>. When no
constraints are imposed the algorithm is very similar to MINPACK and has
generally comparable performance. The algorithm works quite robust in
unbounded and bounded problems, thus it is chosen as a default algorithm.</p>
<p>Method dogbox operates in a trust-region framework, but considers
rectangular trust regions as opposed to conventional ellipsoids <a class="reference internal" href="#r1786fd6832dd-voglis" id="id433">[Voglis]</a>.
The intersection of a current trust region and initial bounds is again
rectangular, so on each iteration a quadratic minimization problem subject
to bound constraints is solved approximately by Powells dogleg method
<a class="reference internal" href="#r1786fd6832dd-numopt" id="id434">[NumOpt]</a>. The required Gauss-Newton step can be computed exactly for
dense Jacobians or approximately by <cite>scipy.sparse.linalg.lsmr</cite> for large
sparse Jacobians. The algorithm is likely to exhibit slow convergence when
the rank of Jacobian is less than the number of variables. The algorithm
often outperforms trf in bounded problems with a small number of
variables.</p>
<p>Robust loss functions are implemented as described in <a class="reference internal" href="#r1786fd6832dd-ba" id="id435">[BA]</a>. The idea
is to modify a residual vector and a Jacobian matrix on each iteration
such that computed gradient and Gauss-Newton Hessian approximation match
the true gradient and Hessian approximation of the cost function. Then
the algorithm proceeds in a normal way, i.e. robust loss functions are
implemented as a simple wrapper over standard least-squares algorithms.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.17.0.</span></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1786fd6832dd-stir" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[STIR]</td><td><em>(<a class="fn-backref" href="#id423">1</a>, <a class="fn-backref" href="#id429">2</a>, <a class="fn-backref" href="#id431">3</a>, <a class="fn-backref" href="#id436">4</a>)</em> M. A. Branch, T. F. Coleman, and Y. Li, A Subspace, Interior,
and Conjugate Gradient Method for Large-Scale Bound-Constrained
Minimization Problems, SIAM Journal on Scientific Computing,
Vol. 21, Number 1, pp 1-23, 1999.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1786fd6832dd-nr" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[NR]</td><td><em>(<a class="fn-backref" href="#id425">1</a>, <a class="fn-backref" href="#id437">2</a>)</em> William H. Press et. al., Numerical Recipes. The Art of Scientific
Computing. 3rd edition, Sec. 5.7.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1786fd6832dd-byrd" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Byrd]</td><td><em>(<a class="fn-backref" href="#id426">1</a>, <a class="fn-backref" href="#id432">2</a>, <a class="fn-backref" href="#id438">3</a>)</em> R. H. Byrd, R. B. Schnabel and G. A. Shultz, Approximate
solution of the trust region problem by minimization over
two-dimensional subspaces, Math. Programming, 40, pp. 247-263,
1988.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1786fd6832dd-curtis" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Curtis]</td><td><em>(<a class="fn-backref" href="#id427">1</a>, <a class="fn-backref" href="#id439">2</a>)</em> A. Curtis, M. J. D. Powell, and J. Reid, On the estimation of
sparse Jacobian matrices, Journal of the Institute of
Mathematics and its Applications, 13, pp. 117-120, 1974.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1786fd6832dd-jjmore" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[JJMore]</td><td><em>(<a class="fn-backref" href="#id424">1</a>, <a class="fn-backref" href="#id428">2</a>, <a class="fn-backref" href="#id430">3</a>, <a class="fn-backref" href="#id440">4</a>)</em> J. J. More, The Levenberg-Marquardt Algorithm: Implementation
and Theory, Numerical Analysis, ed. G. A. Watson, Lecture
Notes in Mathematics 630, Springer Verlag, pp. 105-116, 1977.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1786fd6832dd-voglis" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Voglis]</td><td><em>(<a class="fn-backref" href="#id433">1</a>, <a class="fn-backref" href="#id441">2</a>)</em> C. Voglis and I. E. Lagaris, A Rectangular Trust Region
Dogleg Approach for Unconstrained and Bound Constrained
Nonlinear Optimization, WSEAS International Conference on
Applied Mathematics, Corfu, Greece, 2004.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1786fd6832dd-numopt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[NumOpt]</td><td><em>(<a class="fn-backref" href="#id434">1</a>, <a class="fn-backref" href="#id442">2</a>)</em> J. Nocedal and S. J. Wright, Numerical optimization,
2nd edition, Chapter 4.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1786fd6832dd-ba" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BA]</td><td><em>(<a class="fn-backref" href="#id435">1</a>, <a class="fn-backref" href="#id443">2</a>)</em> B. Triggs et. al., Bundle Adjustment - A Modern Synthesis,
Proceedings of the International Workshop on Vision Algorithms:
Theory and Practice, pp. 298-372, 1999.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In this example we find a minimum of the Rosenbrock function without bounds
on independent variables.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun_rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
</pre></div>
</div>
<p>Notice that we only provide the vector of the residuals. The algorithm
constructs the cost function as a sum of squares of the residuals, which
gives the Rosenbrock function. The exact minimum is at <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[1.0,</span> <span class="pre">1.0]</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">least_squares</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0_rosenbrock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun_rosenbrock</span><span class="p">,</span> <span class="n">x0_rosenbrock</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span><span class="o">.</span><span class="n">cost</span>
<span class="go">9.8669242910846867e-30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span><span class="o">.</span><span class="n">optimality</span>
<span class="go">8.8928864934219529e-14</span>
</pre></div>
</div>
<p>We now constrain the variables, in such a way that the previous solution
becomes infeasible. Specifically, we require that <code class="docutils literal notranslate"><span class="pre">x[1]</span> <span class="pre">&gt;=</span> <span class="pre">1.5</span></code>, and
<code class="docutils literal notranslate"><span class="pre">x[0]</span></code> left unconstrained. To this end, we specify the <cite>bounds</cite> parameter
to <cite>least_squares</cite> in the form <code class="docutils literal notranslate"><span class="pre">bounds=([-np.inf,</span> <span class="pre">1.5],</span> <span class="pre">np.inf)</span></code>.</p>
<p>We also provide the analytic Jacobian:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">jac_rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>        <span class="p">[</span><span class="o">-</span><span class="mi">20</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">10</span><span class="p">],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>Putting this all together, we see that the new solution lies on the bound:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun_rosenbrock</span><span class="p">,</span> <span class="n">x0_rosenbrock</span><span class="p">,</span> <span class="n">jac_rosenbrock</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.22437075,  1.5       ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span><span class="o">.</span><span class="n">cost</span>
<span class="go">0.025213093946805685</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span><span class="o">.</span><span class="n">optimality</span>
<span class="go">1.5885401433157753e-07</span>
</pre></div>
</div>
<p>Now we solve a system of equations (i.e., the cost function should be zero
at a minimum) for a Broyden tridiagonal vector-valued function of 100000
variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun_broyden</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">f</span>
</pre></div>
</div>
<p>The corresponding Jacobian matrix is sparse. We tell the algorithm to
estimate it by finite differences and provide the sparsity structure of
Jacobian to significantly speed up this process.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">lil_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sparsity_broyden</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">sparsity</span> <span class="o">=</span> <span class="n">lil_matrix</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sparsity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sparsity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sparsity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">sparsity</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0_broyden</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_3</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun_broyden</span><span class="p">,</span> <span class="n">x0_broyden</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">jac_sparsity</span><span class="o">=</span><span class="n">sparsity_broyden</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_3</span><span class="o">.</span><span class="n">cost</span>
<span class="go">4.5687069299604613e-23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_3</span><span class="o">.</span><span class="n">optimality</span>
<span class="go">1.1650454296851518e-11</span>
</pre></div>
</div>
<p>Lets also solve a curve fitting problem using robust loss function to
take care of outliers in the data. Define the model function as
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">*</span> <span class="pre">exp(c</span> <span class="pre">*</span> <span class="pre">t)</span></code>, where t is a predictor variable, y is an
observation and a, b, c are parameters to estimate.</p>
<p>First, define the function which generates the data with noise and
outliers, define the model parameters, and generate data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen_data</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_outliers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">y</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">rnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">error</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">rnd</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">outliers</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n_outliers</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">error</span><span class="p">[</span><span class="n">outliers</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">10</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">y</span> <span class="o">+</span> <span class="n">error</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_min</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_max</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_points</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_train</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">n_outliers</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Define function for computing residuals and initial estimate of
parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
</pre></div>
</div>
<p>Compute a standard least-squares solution:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_lsq</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
</pre></div>
</div>
<p>Now compute two solutions with two different robust loss functions. The
parameter <cite>f_scale</cite> is set to 0.1, meaning that inlier residuals should
not significantly exceed 0.1 (the noise level used).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_soft_l1</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;soft_l1&#39;</span><span class="p">,</span> <span class="n">f_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_log</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;cauchy&#39;</span><span class="p">,</span> <span class="n">f_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
</pre></div>
</div>
<p>And finally plot all the curves. We see that by selecting an appropriate
<cite>loss</cite>  we can get estimates close to optimal even in the presence of
strong outliers. But keep in mind that generally it is recommended to try
soft_l1 or huber losses first (if at all necessary) as the other two
options may cause difficulties in optimization process.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">n_points</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_lsq</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="o">*</span><span class="n">res_lsq</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_soft_l1</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="o">*</span><span class="n">res_soft_l1</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_log</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="o">*</span><span class="n">res_log</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_lsq</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;linear loss&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_soft_l1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;soft_l1 loss&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_log</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;cauchy loss&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>In the next example, we show how complex-valued residual functions of
complex variables can be optimized with <code class="docutils literal notranslate"><span class="pre">least_squares()</span></code>. Consider the
following function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">z</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>We wrap it into a function of real variables that returns real residuals
by simply handling the real and imaginary parts as independent variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f_wrap</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">fx</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fx</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">imag</span><span class="p">])</span>
</pre></div>
</div>
<p>Thus, instead of the original m-dimensional complex function of n complex
variables we optimize a 2m-dimensional real function of 2n real variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">least_squares</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_wrapped</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">f_wrap</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">res_wrapped</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">res_wrapped</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span>
<span class="go">(0.49999999999925893+0.49999999999925893j)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id444">
<h3>multi_voxel_fit<a class="headerlink" href="#id444" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.ivim.multi_voxel_fit">
<code class="descclassname">dipy.reconst.ivim.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.ivim.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="id445">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.Cache" title="dipy.reconst.mapmri.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#id445" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.mapmri.Cache">
<em class="property">class </em><code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">Cache</code><a class="headerlink" href="#dipy.reconst.mapmri.Cache" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.Cache.cache_clear" title="dipy.reconst.mapmri.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.Cache.cache_get" title="dipy.reconst.mapmri.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.Cache.cache_set" title="dipy.reconst.mapmri.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.mapmri.Cache.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.Cache.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.Cache.cache_clear">
<code class="descname">cache_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.Cache.cache_clear" title="Permalink to this definition"></a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.Cache.cache_get">
<code class="descname">cache_get</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.Cache.cache_get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.Cache.cache_set">
<code class="descname">cache_set</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.Cache.cache_set" title="Permalink to this definition"></a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mapmrifit">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit" title="dipy.reconst.mapmri.MapmriFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriFit</span></code></a><a class="headerlink" href="#mapmrifit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.mapmri.MapmriFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">MapmriFit</code><span class="sig-paren">(</span><em>model</em>, <em>mapmri_coef</em>, <em>mu</em>, <em>R</em>, <em>lopt</em>, <em>errorcode=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstFit</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.mapmri_R" title="dipy.reconst.mapmri.MapmriFit.mapmri_R"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_R</span></code></a></dt>
<dd><p class="first last">The MAPMRI rotation matrix</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.mapmri_coeff" title="dipy.reconst.mapmri.MapmriFit.mapmri_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_coeff</span></code></a></dt>
<dd><p class="first last">The MAPMRI coefficients</p>
</dd>
<dt><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.mapmri_mu" title="dipy.reconst.mapmri.MapmriFit.mapmri_mu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapmri_mu</span></code></a></dt>
<dd><p class="first last">The MAPMRI scale factors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.fitted_signal" title="dipy.reconst.mapmri.MapmriFit.fitted_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fitted_signal</span></code></a>([gtab])</td>
<td>Recovers the fitted signal for the given gradient table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.msd" title="dipy.reconst.mapmri.MapmriFit.msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd</span></code></a>()</td>
<td>Calculates the analytical Mean Squared Displacement (MSD).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.ng" title="dipy.reconst.mapmri.MapmriFit.ng"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ng</span></code></a>()</td>
<td>Calculates the analytical non-Gaussiannity (NG) <a class="reference internal" href="#re70676512d8d-1" id="id446">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.ng_parallel" title="dipy.reconst.mapmri.MapmriFit.ng_parallel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ng_parallel</span></code></a>()</td>
<td>Calculates the analytical parallel non-Gaussiannity (NG) <a class="reference internal" href="#rb5d84eec88ee-1" id="id447">[1]</a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.ng_perpendicular" title="dipy.reconst.mapmri.MapmriFit.ng_perpendicular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ng_perpendicular</span></code></a>()</td>
<td>Calculates the analytical perpendicular non-Gaussiannity (NG) <a class="reference internal" href="#r24ee8ed2a494-1" id="id448">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal" title="dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm_of_laplacian_signal</span></code></a>()</td>
<td>Calculates the norm of the laplacian of the fitted signal [Rf7f23918a7e7-1].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.odf" title="dipy.reconst.mapmri.MapmriFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere[,&nbsp;s])</td>
<td>Calculates the analytical Orientation Distribution Function (ODF) from the signal <a class="reference internal" href="#r7702701833a7-1" id="id450">[1]</a> Eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.odf_sh" title="dipy.reconst.mapmri.MapmriFit.odf_sh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sh</span></code></a>([s])</td>
<td>Calculates the real analytical odf for a given discrete sphere.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.pdf" title="dipy.reconst.mapmri.MapmriFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>(r_points)</td>
<td>Diffusion propagator on a given set of real points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.predict" title="dipy.reconst.mapmri.MapmriFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(qvals_or_gtab[,&nbsp;S0])</td>
<td>Recovers the reconstructed signal for any qvalue array or gradient table.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.qiv" title="dipy.reconst.mapmri.MapmriFit.qiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qiv</span></code></a>()</td>
<td>Calculates the analytical Q-space Inverse Variance (QIV).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.rtap" title="dipy.reconst.mapmri.MapmriFit.rtap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtap</span></code></a>()</td>
<td>Calculates the analytical return to the axis probability (RTAP) <a class="reference internal" href="#r6f4b363492da-1" id="id451">[1]</a> eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.rtop" title="dipy.reconst.mapmri.MapmriFit.rtop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop</span></code></a>()</td>
<td>Calculates the analytical return to the origin probability (RTOP) <a class="reference internal" href="#re6f1062fb760-1" id="id452">[1]</a> eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriFit.rtpp" title="dipy.reconst.mapmri.MapmriFit.rtpp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtpp</span></code></a>()</td>
<td>Calculates the analytical return to the plane probability (RTPP) <a class="reference internal" href="#rf9cced748cc9-1" id="id453">[1]</a> eq.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>mapmri_coef</em>, <em>mu</em>, <em>R</em>, <em>lopt</em>, <em>errorcode=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Calculates diffusion properties for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">AnalyticalModel</p>
</dd>
<dt><strong>mapmri_coef</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">mapmri coefficients</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (3,)</span></dt>
<dd><p class="first last">scale parameters vector for x, y and z</p>
</dd>
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (3,3)</span></dt>
<dd><p class="first last">rotation matrix</p>
</dd>
<dt><strong>lopt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">regularization weight used for laplacian regularization</p>
</dd>
<dt><strong>errorcode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">provides information on whether errors occurred in the fitting
of each voxel. 0 means no problem, 1 means a LinAlgError
occurred when trying to invert the design matrix. 2 means the
positivity constraint was unable to solve the problem. 3 means
that after positivity constraint failed, also matrix inversion
failed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.fitted_signal">
<code class="descname">fitted_signal</code><span class="sig-paren">(</span><em>gtab=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.fitted_signal" title="Permalink to this definition"></a></dt>
<dd><p>Recovers the fitted signal for the given gradient table. If no gradient
table is given it recovers the signal for the gtab of the model object.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.mapmri.MapmriFit.mapmri_R">
<code class="descname">mapmri_R</code><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.mapmri_R" title="Permalink to this definition"></a></dt>
<dd><p>The MAPMRI rotation matrix</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.mapmri.MapmriFit.mapmri_coeff">
<code class="descname">mapmri_coeff</code><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.mapmri_coeff" title="Permalink to this definition"></a></dt>
<dd><p>The MAPMRI coefficients</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.mapmri.MapmriFit.mapmri_mu">
<code class="descname">mapmri_mu</code><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.mapmri_mu" title="Permalink to this definition"></a></dt>
<dd><p>The MAPMRI scale factors</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.msd">
<code class="descname">msd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.msd" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical Mean Squared Displacement (MSD).
It is defined as the Laplacian of the origin of the estimated signal
<a class="reference internal" href="#r53ed4361a122-1" id="id454">[1]</a>. The analytical formula for the MAP-MRI basis was derived in [R53ed4361a122-2]
eq. (C13, D1).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r53ed4361a122-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id454">1</a>, <a class="fn-backref" href="#id456">2</a>)</em> Cheng, J., 2014. Estimation and Processing of Ensemble Average</td></tr>
</tbody>
</table>
<p>Propagator and Its Features in Diffusion MRI. Ph.D. Thesis.</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.ng">
<code class="descname">ng</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.ng" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical non-Gaussiannity (NG) <a class="reference internal" href="#re70676512d8d-1" id="id458">[1]</a>.
For the NG to be meaningful the mapmri scale factors must be
estimated only on data representing Gaussian diffusion of spins, i.e.,
bvals smaller than about 2000 s/mm^2 <a class="reference internal" href="#re70676512d8d-2" id="id459">[2]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re70676512d8d-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id446">1</a>, <a class="fn-backref" href="#id458">2</a>, <a class="fn-backref" href="#id460">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
<table class="docutils citation" frame="void" id="re70676512d8d-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id459">1</a>, <a class="fn-backref" href="#id461">2</a>)</em> Avram et al. Clinical feasibility of using mean apparent</td></tr>
</tbody>
</table>
<p>propagator (MAP) MRI to characterize brain tissue microstructure.
NeuroImage 2015, in press.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.ng_parallel">
<code class="descname">ng_parallel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.ng_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical parallel non-Gaussiannity (NG) <a class="reference internal" href="#rb5d84eec88ee-1" id="id462">[1]</a>.
For the NG to be meaningful the mapmri scale factors must be
estimated only on data representing Gaussian diffusion of spins, i.e.,
bvals smaller than about 2000 s/mm^2 <a class="reference internal" href="#rb5d84eec88ee-2" id="id463">[2]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb5d84eec88ee-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id447">1</a>, <a class="fn-backref" href="#id462">2</a>, <a class="fn-backref" href="#id464">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
<table class="docutils citation" frame="void" id="rb5d84eec88ee-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id463">1</a>, <a class="fn-backref" href="#id465">2</a>)</em> Avram et al. Clinical feasibility of using mean apparent</td></tr>
</tbody>
</table>
<p>propagator (MAP) MRI to characterize brain tissue microstructure.
NeuroImage 2015, in press.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.ng_perpendicular">
<code class="descname">ng_perpendicular</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.ng_perpendicular" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical perpendicular non-Gaussiannity (NG)
<a class="reference internal" href="#r24ee8ed2a494-1" id="id466">[1]</a>. For the NG to be meaningful the mapmri scale factors must be
estimated only on data representing Gaussian diffusion of spins, i.e.,
bvals smaller than about 2000 s/mm^2 <a class="reference internal" href="#r24ee8ed2a494-2" id="id467">[2]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r24ee8ed2a494-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id448">1</a>, <a class="fn-backref" href="#id466">2</a>, <a class="fn-backref" href="#id468">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
<table class="docutils citation" frame="void" id="r24ee8ed2a494-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id467">1</a>, <a class="fn-backref" href="#id469">2</a>)</em> Avram et al. Clinical feasibility of using mean apparent</td></tr>
</tbody>
</table>
<p>propagator (MAP) MRI to characterize brain tissue microstructure.
NeuroImage 2015, in press.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal">
<code class="descname">norm_of_laplacian_signal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the norm of the laplacian of the fitted signal [Rf7f23918a7e7-1].
This information could be useful to assess if the extrapolation of the
fitted signal contains spurious oscillations. A high laplacian may
indicate that these are present, and any q-space indices that
use integrals of the signal may be corrupted (e.g. RTOP, RTAP, RTPP,
QIV).</p>
<p class="rubric">References</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em>, <em>s=2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical Orientation Distribution Function (ODF)
from the signal <a class="reference internal" href="#r7702701833a7-1" id="id472">[1]</a> Eq. (32).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">radial moment of the ODF</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r7702701833a7-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id450">1</a>, <a class="fn-backref" href="#id472">2</a>, <a class="fn-backref" href="#id473">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.odf_sh">
<code class="descname">odf_sh</code><span class="sig-paren">(</span><em>s=2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.odf_sh" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the real analytical odf for a given discrete sphere.
Computes the design matrix of the ODF for the given sphere vertices
and radial moment <a class="reference internal" href="#r8a6380cda485-1" id="id474">[1]</a> eq. (32). The radial moment s acts as a
sharpening method. The analytical equation for the spherical ODF basis
is given in <a href="#id780"><span class="problematic" id="id475">[2]_</span></a> eq. (C8).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r8a6380cda485-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id474">1</a>, <a class="fn-backref" href="#id476">2</a>, <a class="fn-backref" href="#id477">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.pdf">
<code class="descname">pdf</code><span class="sig-paren">(</span><em>r_points</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.pdf" title="Permalink to this definition"></a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>qvals_or_gtab</em>, <em>S0=100.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Recovers the reconstructed signal for any qvalue array or
gradient table.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.qiv">
<code class="descname">qiv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.qiv" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical Q-space Inverse Variance (QIV).
It is defined as the inverse of the Laplacian of the origin of the
estimated propagator <a class="reference internal" href="#rd3765a80e128-1" id="id478">[1]</a> eq. (22). The analytical formula for the
MAP-MRI basis was derived in [Rd3765a80e128-2] eq. (C14, D2).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd3765a80e128-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id478">1</a>, <a class="fn-backref" href="#id480">2</a>)</em> Hosseinbor et al. Bessel fourier orientation reconstruction</td></tr>
</tbody>
</table>
<p>(bfor): An analytical diffusion propagator reconstruction for hybrid
diffusion imaging and computation of q-space indices. NeuroImage 64,
2013, 650-670.</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.rtap">
<code class="descname">rtap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.rtap" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical return to the axis probability (RTAP)
<a class="reference internal" href="#r6f4b363492da-1" id="id482">[1]</a> eq. (40, 44a). The analytical formula for the isotropic MAP-MRI
basis was derived in [R6f4b363492da-2] eq. (C11).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r6f4b363492da-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id451">1</a>, <a class="fn-backref" href="#id482">2</a>, <a class="fn-backref" href="#id484">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.rtop">
<code class="descname">rtop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.rtop" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical return to the origin probability (RTOP)
<a class="reference internal" href="#re6f1062fb760-1" id="id486">[1]</a> eq. (36, 43). The analytical formula for the isotropic MAP-MRI
basis was derived in [Re6f1062fb760-2] eq. (C11).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re6f1062fb760-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id452">1</a>, <a class="fn-backref" href="#id486">2</a>, <a class="fn-backref" href="#id488">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriFit.rtpp">
<code class="descname">rtpp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriFit.rtpp" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical return to the plane probability (RTPP)
<a class="reference internal" href="#rf9cced748cc9-1" id="id490">[1]</a> eq. (42). The analytical formula for the isotropic MAP-MRI
basis was derived in [Rf9cced748cc9-2] eq. (C11).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rf9cced748cc9-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id453">1</a>, <a class="fn-backref" href="#id490">2</a>, <a class="fn-backref" href="#id492">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mapmrimodel">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.MapmriModel" title="dipy.reconst.mapmri.MapmriModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapmriModel</span></code></a><a class="headerlink" href="#mapmrimodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.mapmri.MapmriModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">MapmriModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>radial_order=6</em>, <em>laplacian_regularization=True</em>, <em>laplacian_weighting=0.2</em>, <em>positivity_constraint=False</em>, <em>pos_grid=15</em>, <em>pos_radius='adaptive'</em>, <em>anisotropic_scaling=True</em>, <em>eigenvalue_threshold=0.0001</em>, <em>bval_threshold=inf</em>, <em>dti_scale_estimation=True</em>, <em>static_diffusivity=0.0007</em>, <em>cvxpy_solver=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.cache.Cache</span></code></a></p>
<p>Mean Apparent Propagator MRI (MAPMRI) <a class="reference internal" href="#rb71d87403e8f-1" id="id494">[1]</a> of the diffusion signal.</p>
<p>The main idea is to model the diffusion signal as a linear combination of
the continuous functions presented in <a class="reference internal" href="#rb71d87403e8f-2" id="id495">[2]</a> but extending it in three
dimensions.
The main difference with the SHORE proposed in <a class="reference internal" href="#rb71d87403e8f-3" id="id496">[3]</a> is that MAPMRI 3D
extension is provided using a set of three basis functions for the radial
part, one for the signal along x, one for y and one for z, while <a class="reference internal" href="#rb71d87403e8f-3" id="id497">[3]</a>
uses one basis function to model the radial part and real Spherical
Harmonics to model the angular part.
From the MAPMRI coefficients is possible to use the analytical formulae
to estimate the ODF.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb71d87403e8f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id28">1</a>, <a class="fn-backref" href="#id494">2</a>, <a class="fn-backref" href="#id498">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb71d87403e8f-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id495">1</a>, <a class="fn-backref" href="#id499">2</a>)</em> Ozarslan E. et al., Simple harmonic oscillator based reconstruction
and estimation for one-dimensional q-space magnetic resonance
1D-SHORE), eapoc Intl Soc Mag Reson Med, vol. 16, p. 35., 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb71d87403e8f-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id496">1</a>, <a class="fn-backref" href="#id497">2</a>, <a class="fn-backref" href="#id500">3</a>)</em> Merlet S. et al., Continuous diffusion signal, EAP and ODF
estimation via Compressive Sensing in diffusion MRI, Medical
Image Analysis, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb71d87403e8f-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id501">[4]</a></td><td>Fick, Rutger HJ, et al. MAPL: Tissue microstructure estimation
using Laplacian-regularized MAP-MRI and its application to HCP
data. NeuroImage (2016).</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb71d87403e8f-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id502">[5]</a></td><td>Cheng, J., 2014. Estimation and Processing of Ensemble Average
Propagator and Its Features in Diffusion MRI. Ph.D. Thesis.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb71d87403e8f-6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id503">[6]</a></td><td>Hosseinbor et al. Bessel fourier orientation reconstruction
(bfor): An analytical diffusion propagator reconstruction for hybrid
diffusion imaging and computation of q-space indices. NeuroImage
64, 2013, 650-670.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb71d87403e8f-7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id504">[7]</a></td><td>Craven et al. Smoothing Noisy Data with Spline Functions.
NUMER MATH 31.4 (1978): 377-403.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb71d87403e8f-8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id505">[8]</a></td><td>Avram et al. Clinical feasibility of using mean apparent
propagator (MAP) MRI to characterize brain tissue microstructure.
NeuroImage 2015, in press.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.mapmri.MapmriModel.fit" title="dipy.reconst.mapmri.MapmriModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>radial_order=6</em>, <em>laplacian_regularization=True</em>, <em>laplacian_weighting=0.2</em>, <em>positivity_constraint=False</em>, <em>pos_grid=15</em>, <em>pos_radius='adaptive'</em>, <em>anisotropic_scaling=True</em>, <em>eigenvalue_threshold=0.0001</em>, <em>bval_threshold=inf</em>, <em>dti_scale_estimation=True</em>, <em>static_diffusivity=0.0007</em>, <em>cvxpy_solver=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Analytical and continuous modeling of the diffusion signal with
respect to the MAPMRI basis <a class="reference internal" href="#r667c7fc64c9d-1" id="id506">[1]</a>.</p>
<p>The main idea is to model the diffusion signal as a linear combination
of the continuous functions presented in <a class="reference internal" href="#r667c7fc64c9d-2" id="id507">[2]</a> but extending it in three
dimensions.</p>
<p>The main difference with the SHORE proposed in <a class="reference internal" href="#r667c7fc64c9d-3" id="id508">[3]</a> is that MAPMRI 3D
extension is provided using a set of three basis functions for the
radial part, one for the signal along x, one for y and one for z, while
<a class="reference internal" href="#r667c7fc64c9d-3" id="id509">[3]</a> uses one basis function to model the radial part and real
Spherical Harmonics to model the angular part.</p>
<p>From the MAPMRI coefficients it is possible to estimate various
q-space indices, the PDF and the ODF.</p>
<p>The fitting procedure can be constrained using the positivity
constraint proposed in <a class="reference internal" href="#r667c7fc64c9d-1" id="id510">[1]</a> and/or the laplacian regularization
proposed in <a class="reference internal" href="#r667c7fc64c9d-4" id="id511">[4]</a>.</p>
<p>For the estimation of q-space indices we recommend using the regular
anisotropic implementation of MAPMRI. However, it has been shown that
the ODF estimation in this implementation has a bias which
squeezes together the ODF peaks when there is a crossing at an angle
smaller than 90 degrees <a class="reference internal" href="#r667c7fc64c9d-4" id="id512">[4]</a>. When you want to estimate ODFs for
tractography we therefore recommend using the isotropic implementation
(which is equivalent to <a class="reference internal" href="#r667c7fc64c9d-3" id="id513">[3]</a>).</p>
<p>The switch between isotropic and anisotropic can be easily made through
the anisotropic_scaling option.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable,</span></dt>
<dd><p class="first last">gradient directions and bvalues container class.
the gradient table has to include b0-images.</p>
</dd>
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>laplacian_regularization: bool,</strong></dt>
<dd><p class="first last">Regularize using the Laplacian of the MAP-MRI basis.</p>
</dd>
<dt><strong>laplacian_weighting: string or scalar,</strong></dt>
<dd><p class="first last">The string GCV makes it use generalized cross-validation to find
the regularization weight [4]. A scalar sets the regularization
weight to that value and an array will make it selected the
optimal weight from the values in the array.</p>
</dd>
<dt><strong>positivity_constraint</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool,</span></dt>
<dd><p class="first last">Constrain the propagator to be positive.</p>
</dd>
<dt><strong>pos_grid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer,</span></dt>
<dd><p class="first last">The number of points in the grid that is used in the positivity
constraint.</p>
</dd>
<dt><strong>pos_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or string,</span></dt>
<dd><p class="first last">If set to a float, the maximum distance the the positivity
constraint constrains to posivity is that value. If set to
<a href="#id514"><span class="problematic" id="id515">`</span></a>adaptive, the maximum distance is dependent on the estimated
tissue diffusivity.</p>
</dd>
<dt><strong>anisotropic_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool,</span></dt>
<dd><p class="first last">If True, uses the standard anisotropic MAP-MRI basis. If False,
uses the isotropic MAP-MRI basis (equal to 3D-SHORE).</p>
</dd>
<dt><strong>eigenvalue_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Sets the minimum of the tensor eigenvalues in order to avoid
stability problem.</p>
</dd>
<dt><strong>bval_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Sets the b-value threshold to be used in the scale factor
estimation. In order for the estimated non-Gaussianity to have
meaning this value should set to a lower value (b&lt;2000 s/mm^2)
such that the scale factors are estimated on signal points that
reasonably represent the spins at Gaussian diffusion.</p>
</dd>
<dt><strong>dti_scale_estimation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool,</span></dt>
<dd><p class="first last">Whether or not DTI fitting is used to estimate the isotropic scale
factor for isotropic MAP-MRI.
When set to False the algorithm presets the isotropic tissue
diffusivity to static_diffusivity. This vastly increases fitting
speed but at the cost of slightly reduced fitting quality. Can
still be used in combination with regularization and constraints.</p>
</dd>
<dt><strong>static_diffusivity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">the tissue diffusivity that is used when dti_scale_estimation is
set to False. The default is that of typical white matter
D=0.7e-3 _[5].</p>
</dd>
<dt><strong>cvxpy_solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">cvxpy solver name. Optionally optimize the positivity constraint
with a particular cvxpy solver. See <a class="reference external" href="http://www.cvxpy.org/">http://www.cvxpy.org/</a> for
details.
Default: None (cvxpy chooses its own solver)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r667c7fc64c9d-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id506">1</a>, <a class="fn-backref" href="#id510">2</a>, <a class="fn-backref" href="#id516">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r667c7fc64c9d-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id507">1</a>, <a class="fn-backref" href="#id517">2</a>)</em> Ozarslan E. et al., Simple harmonic oscillator based
reconstruction and estimation for one-dimensional q-space
magnetic resonance 1D-SHORE), Proc Intl Soc Mag Reson Med,
vol. 16, p. 35., 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r667c7fc64c9d-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id508">1</a>, <a class="fn-backref" href="#id509">2</a>, <a class="fn-backref" href="#id513">3</a>, <a class="fn-backref" href="#id518">4</a>)</em> Ozarslan E. et al., Simple harmonic oscillator based
reconstruction and estimation for three-dimensional q-space
mri, ISMRM 2009.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r667c7fc64c9d-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id511">1</a>, <a class="fn-backref" href="#id512">2</a>, <a class="fn-backref" href="#id519">3</a>)</em> Fick, Rutger HJ, et al. MAPL: Tissue microstructure estimation
using Laplacian-regularized MAP-MRI and its application to HCP
data. NeuroImage (2016).</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r667c7fc64c9d-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id520">[5]</a></td><td>Merlet S. et al., Continuous diffusion signal, EAP and ODF
estimation via Compressive Sensing in diffusion MRI, Medical
Image Analysis, 2013.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In this example, where the data, gradient table and sphere tessellation
used for reconstruction are provided, we model the diffusion signal
with respect to the SHORE basis and compute the real and analytical
ODF.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">dsi_voxels</span><span class="p">,</span> <span class="n">get_sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="k">import</span> <span class="n">gradient_table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">gtab_</span> <span class="o">=</span> <span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gtab</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">gtab_</span><span class="o">.</span><span class="n">bvals</span><span class="p">,</span> <span class="n">gtab_</span><span class="o">.</span><span class="n">bvecs</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">b0_threshold</span><span class="o">=</span><span class="n">gtab_</span><span class="o">.</span><span class="n">bvals</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.sims.voxel</span> <span class="k">import</span> <span class="n">SticksAndBall</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">golden_directions</span> <span class="o">=</span> <span class="n">SticksAndBall</span><span class="p">(</span>
<span class="gp">... </span>                                    <span class="n">gtab</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">0.0015</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">S0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="gp">... </span>                                    <span class="n">fractions</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="n">snr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.mapmri</span> <span class="k">import</span> <span class="n">MapmriModel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radial_order</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_model</span> <span class="o">=</span> <span class="n">MapmriModel</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">radial_order</span><span class="o">=</span><span class="n">radial_order</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mapfit</span> <span class="o">=</span> <span class="n">map_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">get_sphere</span><span class="p">(</span><span class="s1">&#39;symmetric724&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odf</span> <span class="o">=</span> <span class="n">mapfit</span><span class="o">.</span><span class="n">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.MapmriModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.MapmriModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="optimizer">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.Optimizer" title="dipy.reconst.mapmri.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code></a><a class="headerlink" href="#optimizer" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.mapmri.Optimizer">
<em class="property">class </em><code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">Optimizer</code><span class="sig-paren">(</span><em>fun</em>, <em>x0</em>, <em>args=()</em>, <em>method='L-BFGS-B'</em>, <em>jac=None</em>, <em>hess=None</em>, <em>hessp=None</em>, <em>bounds=None</em>, <em>constraints=()</em>, <em>tol=None</em>, <em>callback=None</em>, <em>options=None</em>, <em>evolution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.Optimizer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evolution</strong></dt>
<dd></dd>
<dt><strong>fopt</strong></dt>
<dd></dd>
<dt><strong>message</strong></dt>
<dd></dd>
<dt><strong>nfev</strong></dt>
<dd></dd>
<dt><strong>nit</strong></dt>
<dd></dd>
<dt><strong>xopt</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="37%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>print_summary</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.mapmri.Optimizer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>fun</em>, <em>x0</em>, <em>args=()</em>, <em>method='L-BFGS-B'</em>, <em>jac=None</em>, <em>hess=None</em>, <em>hessp=None</em>, <em>bounds=None</em>, <em>constraints=()</em>, <em>tol=None</em>, <em>callback=None</em>, <em>options=None</em>, <em>evolution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.Optimizer.__init__" title="Permalink to this definition"></a></dt>
<dd><p>A class for handling minimization of scalar function of one or more
variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fun</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">Objective function.</p>
</dd>
<dt><strong>x0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Initial guess.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, optional</span></dt>
<dd><p class="first last">Extra arguments passed to the objective function and its
derivatives (Jacobian, Hessian).</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">Type of solver.  Should be one of</p>
<blockquote class="last">
<div><ul class="simple">
<li>Nelder-Mead</li>
<li>Powell</li>
<li>CG</li>
<li>BFGS</li>
<li>Newton-CG</li>
<li>Anneal</li>
<li>L-BFGS-B</li>
<li>TNC</li>
<li>COBYLA</li>
<li>SLSQP</li>
<li>dogleg</li>
<li>trust-ncg</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>jac</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool or callable, optional</span></dt>
<dd><p class="first last">Jacobian of objective function. Only for CG, BFGS, Newton-CG,
dogleg, trust-ncg.
If <cite>jac</cite> is a Boolean and is True, <cite>fun</cite> is assumed to return the
value of Jacobian along with the objective function. If False, the
Jacobian will be estimated numerically.
<cite>jac</cite> can also be a callable returning the Jacobian of the
objective. In this case, it must accept the same arguments
as <cite>fun</cite>.</p>
</dd>
<dt><strong>hess, hessp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd><p class="first last">Hessian of objective function or Hessian of objective function
times an arbitrary vector p.  Only for Newton-CG,
dogleg, trust-ncg.
Only one of <cite>hessp</cite> or <cite>hess</cite> needs to be given.  If <cite>hess</cite> is
provided, then <cite>hessp</cite> will be ignored.  If neither <cite>hess</cite> nor
<cite>hessp</cite> is provided, then the hessian product will be approximated
using finite differences on <cite>jac</cite>. <cite>hessp</cite> must compute the Hessian
times an arbitrary vector.</p>
</dd>
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">Bounds for variables (only for L-BFGS-B, TNC and SLSQP).
<code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining
the bounds on that parameter. Use None for one of <code class="docutils literal notranslate"><span class="pre">min</span></code> or
<code class="docutils literal notranslate"><span class="pre">max</span></code> when there is no bound in that direction.</p>
</dd>
<dt><strong>constraints</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict or sequence of dict, optional</span></dt>
<dd><p class="first">Constraints definition (only for COBYLA and SLSQP).
Each constraint is defined in a dictionary with fields:</p>
<blockquote>
<div><dl class="docutils">
<dt>type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Constraint type: eq for equality, ineq for inequality.</p>
</dd>
<dt>fun <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">The function defining the constraint.</p>
</dd>
<dt>jac <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd><p class="first last">The Jacobian of <cite>fun</cite> (only for SLSQP).</p>
</dd>
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">Extra arguments to be passed to the function and Jacobian.</p>
</dd>
</dl>
</div></blockquote>
<p class="last">Equality constraint means that the constraint function result is to
be zero whereas inequality means that it is to be non-negative.
Note that COBYLA only supports inequality constraints.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Tolerance for termination. For detailed control, use
solver-specific options.</p>
</dd>
<dt><strong>callback</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd><p class="first last">Called after each iteration, as <code class="docutils literal notranslate"><span class="pre">callback(xk)</span></code>, where <code class="docutils literal notranslate"><span class="pre">xk</span></code> is
the current parameter vector. Only available using Scipy &gt;= 0.12.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first">A dictionary of solver options. All methods accept the following
generic options:</p>
<blockquote>
<div><dl class="docutils">
<dt>maxiter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations to perform.</p>
</dd>
<dt>disp <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set to True to print convergence messages.</p>
</dd>
</dl>
</div></blockquote>
<p class="last">For method-specific options, see
<cite>show_options(minimize, method)</cite>.</p>
</dd>
<dt><strong>evolution</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">save history of x for each iteration. Only available using Scipy
&gt;= 0.12.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.mapmri.Optimizer.evolution">
<code class="descname">evolution</code><a class="headerlink" href="#dipy.reconst.mapmri.Optimizer.evolution" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.mapmri.Optimizer.fopt">
<code class="descname">fopt</code><a class="headerlink" href="#dipy.reconst.mapmri.Optimizer.fopt" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.mapmri.Optimizer.message">
<code class="descname">message</code><a class="headerlink" href="#dipy.reconst.mapmri.Optimizer.message" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.mapmri.Optimizer.nfev">
<code class="descname">nfev</code><a class="headerlink" href="#dipy.reconst.mapmri.Optimizer.nfev" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.mapmri.Optimizer.nit">
<code class="descname">nit</code><a class="headerlink" href="#dipy.reconst.mapmri.Optimizer.nit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.Optimizer.print_summary">
<code class="descname">print_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.Optimizer.print_summary" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.mapmri.Optimizer.xopt">
<code class="descname">xopt</code><a class="headerlink" href="#dipy.reconst.mapmri.Optimizer.xopt" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id521">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.ReconstFit" title="dipy.reconst.mapmri.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><a class="headerlink" href="#id521" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.mapmri.ReconstFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">ReconstFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.ReconstFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.mapmri.ReconstFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.ReconstFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id522">
<h3><a class="reference internal" href="#dipy.reconst.mapmri.ReconstModel" title="dipy.reconst.mapmri.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#id522" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.mapmri.ReconstModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">ReconstModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.ReconstModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.mapmri.ReconstModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.ReconstModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.mapmri.ReconstModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.ReconstModel.fit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="b-mat">
<h3>b_mat<a class="headerlink" href="#b-mat" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.b_mat">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">b_mat</code><span class="sig-paren">(</span><em>index_matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.b_mat" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the B coefficients from <a class="reference internal" href="#rcb3260c94f80-1" id="id523">[1]</a> Eq. (27).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>index_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">ordering of the basis in x, y, z</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,)</span></dt>
<dd><p class="first last">B coefficients for the basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rcb3260c94f80-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id29">1</a>, <a class="fn-backref" href="#id523">2</a>, <a class="fn-backref" href="#id524">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="b-mat-isotropic">
<h3>b_mat_isotropic<a class="headerlink" href="#b-mat-isotropic" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.b_mat_isotropic">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">b_mat_isotropic</code><span class="sig-paren">(</span><em>index_matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.b_mat_isotropic" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the isotropic B coefficients from <a class="reference internal" href="#r21c472b0c767-1" id="id525">[1]</a> Fig 8.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>index_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">ordering of the isotropic basis in j, l, m</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,)</span></dt>
<dd><p class="first last">B coefficients for the isotropic basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r21c472b0c767-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id30">1</a>, <a class="fn-backref" href="#id525">2</a>, <a class="fn-backref" href="#id526">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="binomialfloat">
<h3>binomialfloat<a class="headerlink" href="#binomialfloat" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.binomialfloat">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">binomialfloat</code><span class="sig-paren">(</span><em>n</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.binomialfloat" title="Permalink to this definition"></a></dt>
<dd><p>Custom Binomial function</p>
</dd></dl>

</div>
<div class="section" id="id527">
<h3>cart2sphere<a class="headerlink" href="#id527" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.cart2sphere">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">cart2sphere</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.cart2sphere" title="Permalink to this definition"></a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions and derivation
of the formulae.</p>
<p><span class="math notranslate nohighlight">\(0\le\theta\mathrm{(theta)}\le\pi\)</span> and <span class="math notranslate nohighlight">\(-\pi\le\phi\mathrm{(phi)}\le\pi\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">x coordinate in Cartesian space</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">z coordinate</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">radius</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">inclination (polar) angle</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">azimuth angle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-rspace">
<h3>create_rspace<a class="headerlink" href="#create-rspace" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.create_rspace">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">create_rspace</code><span class="sig-paren">(</span><em>gridsize</em>, <em>radius_max</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.create_rspace" title="Permalink to this definition"></a></dt>
<dd><p>Create the real space table, that contains the points in which
to compute the pdf.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gridsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">dimension of the propagator grid</p>
</dd>
<dt><strong>radius_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximal radius in which compute the propagator</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">real space points in which calculates the pdf</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="delta">
<h3>delta<a class="headerlink" href="#delta" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.delta">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">delta</code><span class="sig-paren">(</span><em>n</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.delta" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="factorial2">
<h3>factorial2<a class="headerlink" href="#factorial2" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.factorial2">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">factorial2</code><span class="sig-paren">(</span><em>n</em>, <em>exact=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.factorial2" title="Permalink to this definition"></a></dt>
<dd><p>Double factorial.</p>
<p>This is the factorial with every second value skipped.  E.g., <code class="docutils literal notranslate"><span class="pre">7!!</span> <span class="pre">=</span> <span class="pre">7</span> <span class="pre">*</span> <span class="pre">5</span>
<span class="pre">*</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">1</span></code>.  It can be approximated numerically as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd
    = 2**(n/2) * (n/2)!                           n even
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array_like</span></dt>
<dd><p class="first last">Calculate <code class="docutils literal notranslate"><span class="pre">n!!</span></code>.  Arrays are only supported with <cite>exact</cite> set
to False.  If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, the return value is 0.</p>
</dd>
<dt><strong>exact</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">The result can be approximated rapidly using the gamma-formula
above (default).  If <cite>exact</cite> is set to True, calculate the
answer exactly using integer arithmetic.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span></dt>
<dd><p class="first last">Double factorial of <cite>n</cite>, as an int or a float depending on
<cite>exact</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">factorial2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial2</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array(105.00000000000001)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial2</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">105L</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gcv-cost-function">
<h3>gcv_cost_function<a class="headerlink" href="#gcv-cost-function" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.gcv_cost_function">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">gcv_cost_function</code><span class="sig-paren">(</span><em>weight</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.gcv_cost_function" title="Permalink to this definition"></a></dt>
<dd><p>The GCV cost function that is iterated [4]</p>
</dd></dl>

</div>
<div class="section" id="generalized-crossvalidation">
<h3>generalized_crossvalidation<a class="headerlink" href="#generalized-crossvalidation" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.generalized_crossvalidation">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">generalized_crossvalidation</code><span class="sig-paren">(</span><em>data</em>, <em>M</em>, <em>LR</em>, <em>gcv_startpoint=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.generalized_crossvalidation" title="Permalink to this definition"></a></dt>
<dd><p>Generalized Cross Validation Function [Rb690cd738504-1] eq. (15).
Finds optimal regularization weight based on generalized cross-validation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N),</span></dt>
<dd><p class="first last">data array</p>
</dd>
<dt><strong>M</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix, shape (N, Ncoef)</span></dt>
<dd><p class="first last">mapmri observation matrix</p>
</dd>
<dt><strong>LR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix, shape (N_coef, N_coef)</span></dt>
<dd><p class="first last">regularization matrix</p>
</dd>
<dt><strong>gcv_startpoint</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">startpoint for the gcv optimization</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>optimal_lambda</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">optimal regularization weight</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
</dd></dl>

</div>
<div class="section" id="generalized-crossvalidation-array">
<h3>generalized_crossvalidation_array<a class="headerlink" href="#generalized-crossvalidation-array" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.generalized_crossvalidation_array">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">generalized_crossvalidation_array</code><span class="sig-paren">(</span><em>data</em>, <em>M</em>, <em>LR</em>, <em>weights_array=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.generalized_crossvalidation_array" title="Permalink to this definition"></a></dt>
<dd><p>Generalized Cross Validation Function <a class="footnote-reference" href="#id344" id="id530">[1]</a> eq. (15).
Here weights_array is a numpy array with all values that should be
considered in the GCV. It will run through the weights until the cost
function starts to increase, then stop and take the last value as the
optimum weight.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N),</span></dt>
<dd><p class="first last">Basis order matrix</p>
</dd>
<dt><strong>M</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix, shape (N, Ncoef)</span></dt>
<dd><p class="first last">mapmri observation matrix</p>
</dd>
<dt><strong>LR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix, shape (N_coef, N_coef)</span></dt>
<dd><p class="first last">regularization matrix</p>
</dd>
<dt><strong>weights_array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N_of_weights)</span></dt>
<dd><p class="first last">array of optional regularization weights</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="genlaguerre">
<h3>genlaguerre<a class="headerlink" href="#genlaguerre" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.genlaguerre">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">genlaguerre</code><span class="sig-paren">(</span><em>n</em>, <em>alpha</em>, <em>monic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.genlaguerre" title="Permalink to this definition"></a></dt>
<dd><p>Generalized (associated) Laguerre polynomial.</p>
<p>Defined to be the solution of</p>
<div class="math notranslate nohighlight">
\[x\frac{d^2}{dx^2}L_n^{(\alpha)}
  + (\alpha + 1 - x)\frac{d}{dx}L_n^{(\alpha)}
  + nL_n^{(\alpha)} = 0,\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha &gt; -1\)</span>; <span class="math notranslate nohighlight">\(L_n^{(\alpha)}\)</span> is a polynomial
of degree <span class="math notranslate nohighlight">\(n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Degree of the polynomial.</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Parameter, must be greater than -1.</p>
</dd>
<dt><strong>monic</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If <cite>True</cite>, scale the leading coefficient to be 1. Default is
<cite>False</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">orthopoly1d</span></dt>
<dd><p class="first last">Generalized Laguerre polynomial.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">laguerre</span></code></dt>
<dd>Laguerre polynomial.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For fixed <span class="math notranslate nohighlight">\(\alpha\)</span>, the polynomials <span class="math notranslate nohighlight">\(L_n^{(\alpha)}\)</span>
are orthogonal over <span class="math notranslate nohighlight">\([0, \infty)\)</span> with weight function
<span class="math notranslate nohighlight">\(e^{-x}x^\alpha\)</span>.</p>
<p>The Laguerre polynomials are the special case where <span class="math notranslate nohighlight">\(\alpha
= 0\)</span>.</p>
</dd></dl>

</div>
<div class="section" id="id531">
<h3>gradient_table<a class="headerlink" href="#id531" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.gradient_table">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">gradient_table</code><span class="sig-paren">(</span><em>bvals</em>, <em>bvecs=None</em>, <em>big_delta=None</em>, <em>small_delta=None</em>, <em>b0_threshold=50</em>, <em>atol=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.gradient_table" title="Permalink to this definition"></a></dt>
<dd><p>A general function for creating diffusion MR gradients.</p>
<p>It reads, loads and prepares scanner parameters like the b-values and
b-vectors so that they can be useful during the reconstruction process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">can be any of the four options</span></dt>
<dd><ol class="first last arabic simple">
<li>an array of shape (N,) or (1, N) or (N, 1) with the b-values.</li>
<li>a path for the file which contains an array like the above (1).</li>
<li>an array of shape (N, 4) or (4, N). Then this parameter is
considered to be a b-table which contains both bvals and bvecs. In
this case the next parameter is skipped.</li>
<li>a path for the file which contains an array like the one at (3).</li>
</ol>
</dd>
<dt><strong>bvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">can be any of two options</span></dt>
<dd><ol class="first last arabic simple">
<li>an array of shape (N, 3) or (3, N) with the b-vectors.</li>
<li>a path for the file which contains an array like the previous.</li>
</ol>
</dd>
<dt><strong>big_delta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">acquisition pulse separation time in seconds (default None)</p>
</dd>
<dt><strong>small_delta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">acquisition pulse duration time in seconds (default None)</p>
</dd>
<dt><strong>b0_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">All b-values with values less than or equal to <cite>bo_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</dd>
<dt><strong>atol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">All b-vectors need to be unit vectors up to a tolerance.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gradients</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd><p class="first last">A GradientTable with all the gradient information.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li>Often b0s (b-values which correspond to images without diffusion
weighting) have 0 values however in some cases the scanner cannot
provide b0s of an exact 0 value and it gives a bit higher values
e.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</li>
<li>We assume that the minimum number of b-values is 7.</li>
<li>B-vectors should be unit vectors.</li>
</ol>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="k">import</span> <span class="n">gradient_table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span> <span class="o">=</span> <span class="mi">1500</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sq2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table</span><span class="p">(</span><span class="n">bvals</span><span class="p">,</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bvecs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">bvecs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hermite">
<h3>hermite<a class="headerlink" href="#hermite" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.hermite">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">hermite</code><span class="sig-paren">(</span><em>n</em>, <em>monic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.hermite" title="Permalink to this definition"></a></dt>
<dd><p>Physicists Hermite polynomial.</p>
<p>Defined by</p>
<div class="math notranslate nohighlight">
\[H_n(x) = (-1)^ne^{x^2}\frac{d^n}{dx^n}e^{-x^2};\]</div>
<p><span class="math notranslate nohighlight">\(H_n\)</span> is a polynomial of degree <span class="math notranslate nohighlight">\(n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Degree of the polynomial.</p>
</dd>
<dt><strong>monic</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If <cite>True</cite>, scale the leading coefficient to be 1. Default is
<cite>False</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">orthopoly1d</span></dt>
<dd><p class="first last">Hermite polynomial.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The polynomials <span class="math notranslate nohighlight">\(H_n\)</span> are orthogonal over <span class="math notranslate nohighlight">\((-\infty,
\infty)\)</span> with weight function <span class="math notranslate nohighlight">\(e^{-x^2}\)</span>.</p>
</dd></dl>

</div>
<div class="section" id="isotropic-scale-factor">
<h3>isotropic_scale_factor<a class="headerlink" href="#isotropic-scale-factor" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.isotropic_scale_factor">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">isotropic_scale_factor</code><span class="sig-paren">(</span><em>mu_squared</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.isotropic_scale_factor" title="Permalink to this definition"></a></dt>
<dd><p>Estimated isotropic scaling factor _[1] Eq. (49).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mu_squared</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">squared scale factors of mapmri basis in x, y, z</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>u0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">closest isotropic scale factor for the isotropic basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd2ef405bbccd-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id532">[1]</a></td><td>Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="map-laplace-s">
<h3>map_laplace_s<a class="headerlink" href="#map-laplace-s" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.map_laplace_s">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">map_laplace_s</code><span class="sig-paren">(</span><em>n</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.map_laplace_s" title="Permalink to this definition"></a></dt>
<dd><p>R(m,n) static matrix for Laplacian regularization [R932dd40ca52e-1] eq. (11).
Parameters
-
n, m : unsigned int</p>
<blockquote>
<div>basis order of the MAP-MRI basis in different directions</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Analytical integral of <span class="math notranslate nohighlight">\(\phi_n''(q) * \phi_m''(q)\)</span></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</div>
<div class="section" id="map-laplace-t">
<h3>map_laplace_t<a class="headerlink" href="#map-laplace-t" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.map_laplace_t">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">map_laplace_t</code><span class="sig-paren">(</span><em>n</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.map_laplace_t" title="Permalink to this definition"></a></dt>
<dd><p>L(m, n) static matrix for Laplacian regularization [Reb78d789d6c4-1] eq. (12).
Parameters
-
n, m : unsigned int</p>
<blockquote>
<div>basis order of the MAP-MRI basis in different directions</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Analytical integral of <span class="math notranslate nohighlight">\(\phi_n(q) * \phi_m''(q)\)</span></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</div>
<div class="section" id="map-laplace-u">
<h3>map_laplace_u<a class="headerlink" href="#map-laplace-u" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.map_laplace_u">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">map_laplace_u</code><span class="sig-paren">(</span><em>n</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.map_laplace_u" title="Permalink to this definition"></a></dt>
<dd><p>S(n, m) static matrix for Laplacian regularization [Rb93dd9dab8c9-1] eq. (13).
Parameters
-
n, m : unsigned int</p>
<blockquote>
<div>basis order of the MAP-MRI basis in different directions</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Analytical integral of <span class="math notranslate nohighlight">\(\phi_n(q) * \phi_m(q)\)</span></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</div>
<div class="section" id="mapmri-stu-reg-matrices">
<h3>mapmri_STU_reg_matrices<a class="headerlink" href="#mapmri-stu-reg-matrices" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_STU_reg_matrices">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_STU_reg_matrices</code><span class="sig-paren">(</span><em>radial_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_STU_reg_matrices" title="Permalink to this definition"></a></dt>
<dd><p>Generates the static portions of the Laplacian regularization matrix
according to [R1d585103467a-1] eq. (11, 12, 13).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S, T, U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Matrices, shape (N_coef,N_coef)</span></dt>
<dd><p class="first last">Regularization submatrices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</div>
<div class="section" id="mapmri-index-matrix">
<h3>mapmri_index_matrix<a class="headerlink" href="#mapmri-index-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_index_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_index_matrix</code><span class="sig-paren">(</span><em>radial_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_index_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the indices for the MAPMRI <a class="reference internal" href="#rb85ba44932df-1" id="id541">[1]</a> basis in x, y and z.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">radial order of MAPMRI basis</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">ordering of the basis in x, y, z</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb85ba44932df-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id37">1</a>, <a class="fn-backref" href="#id541">2</a>, <a class="fn-backref" href="#id542">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-k-mu-dependent">
<h3>mapmri_isotropic_K_mu_dependent<a class="headerlink" href="#mapmri-isotropic-k-mu-dependent" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_K_mu_dependent</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em>, <em>rgrad</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent" title="Permalink to this definition"></a></dt>
<dd><p>Computes mu dependent part of M. Same trick as with M.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-k-mu-independent">
<h3>mapmri_isotropic_K_mu_independent<a class="headerlink" href="#mapmri-isotropic-k-mu-independent" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_K_mu_independent</code><span class="sig-paren">(</span><em>radial_order</em>, <em>rgrad</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent" title="Permalink to this definition"></a></dt>
<dd><p>Computes mu independent part of K. Same trick as with M.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-m-mu-dependent">
<h3>mapmri_isotropic_M_mu_dependent<a class="headerlink" href="#mapmri-isotropic-m-mu-dependent" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_M_mu_dependent</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em>, <em>qval</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent" title="Permalink to this definition"></a></dt>
<dd><p>Computed the mu dependent part of the signal design matrix.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-m-mu-independent">
<h3>mapmri_isotropic_M_mu_independent<a class="headerlink" href="#mapmri-isotropic-m-mu-independent" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_M_mu_independent</code><span class="sig-paren">(</span><em>radial_order</em>, <em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent" title="Permalink to this definition"></a></dt>
<dd><p>Computed the mu independent part of the signal design matrix.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-index-matrix">
<h3>mapmri_isotropic_index_matrix<a class="headerlink" href="#mapmri-isotropic-index-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_index_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_index_matrix</code><span class="sig-paren">(</span><em>radial_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_index_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the indices for the isotropic MAPMRI basis <a class="reference internal" href="#rc015c0dc1977-1" id="id543">[1]</a> Fig 8.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">radial order of isotropic MAPMRI basis</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">ordering of the basis in x, y, z</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rc015c0dc1977-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id38">1</a>, <a class="fn-backref" href="#id543">2</a>, <a class="fn-backref" href="#id544">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-laplacian-reg-matrix">
<h3>mapmri_isotropic_laplacian_reg_matrix<a class="headerlink" href="#mapmri-isotropic-laplacian-reg-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_laplacian_reg_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Laplacian regularization matrix for MAP-MRIs isotropic
implementation [R156f27ca005f-1] eq. (C7).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>LR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Matrix, shape (N_coef, N_coef)</span></dt>
<dd><p class="first last">Laplacian regularization matrix</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-laplacian-reg-matrix-from-index-matrix">
<h3>mapmri_isotropic_laplacian_reg_matrix_from_index_matrix<a class="headerlink" href="#mapmri-isotropic-laplacian-reg-matrix-from-index-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>mu</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Laplacian regularization matrix for MAP-MRIs isotropic
implementation [Rdcc29394f577-1] eq. (C7).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ind_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix (N_coef, 3),</span></dt>
<dd><p class="first last">Basis order matrix</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>LR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Matrix, shape (N_coef, N_coef)</span></dt>
<dd><p class="first last">Laplacian regularization matrix</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-odf-matrix">
<h3>mapmri_isotropic_odf_matrix<a class="headerlink" href="#mapmri-isotropic-odf-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_odf_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_odf_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em>, <em>s</em>, <em>vertices</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the isotropic MAPMRI ODF matrix <a class="reference internal" href="#rf7e027186c88-1" id="id549">[1]</a> Eq. 32 but for the
isotropic propagator in <a class="reference internal" href="#rf7e027186c88-1" id="id550">[1]</a> eq. (60). Analytical derivation in
[Rf7e027186c88-2] eq. (C8).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">radial moment of the ODF</p>
</dd>
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">points of the sphere shell in the r-space in which evaluate the ODF</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>odf_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Matrix, shape (N_vertices, N_mapmri_coef)</span></dt>
<dd><p class="first last">ODF design matrix to discrete sphere function</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rf7e027186c88-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id41">1</a>, <a class="fn-backref" href="#id549">2</a>, <a class="fn-backref" href="#id550">3</a>, <a class="fn-backref" href="#id552">4</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-odf-sh-matrix">
<h3>mapmri_isotropic_odf_sh_matrix<a class="headerlink" href="#mapmri-isotropic-odf-sh-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_odf_sh_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the isotropic MAPMRI ODF matrix <a class="reference internal" href="#r18e181ea8d0c-1" id="id554">[1]</a> Eq. 32 for the isotropic
propagator in <a class="reference internal" href="#r18e181ea8d0c-1" id="id555">[1]</a> eq. (60). Here we do not compute the sphere function but
the spherical harmonics by only integrating the radial part of the
propagator. We use the same derivation of the ODF in the isotropic
implementation as in [R18e181ea8d0c-2] eq. (C8).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">isotropic scale factor of the isotropic MAP-MRI basis</p>
</dd>
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">radial moment of the ODF</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>odf_sh_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Matrix, shape (N_sh_coef, N_mapmri_coef)</span></dt>
<dd><p class="first last">ODF design matrix to spherical harmonics</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r18e181ea8d0c-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id42">1</a>, <a class="fn-backref" href="#id554">2</a>, <a class="fn-backref" href="#id555">3</a>, <a class="fn-backref" href="#id557">4</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-phi-matrix">
<h3>mapmri_isotropic_phi_matrix<a class="headerlink" href="#mapmri-isotropic-phi-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_phi_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_phi_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em>, <em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Three dimensional isotropic MAPMRI signal basis function from <a class="reference internal" href="#r7485962ae8ea-1" id="id559">[1]</a>
Eq. (61).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">radial order of the mapmri basis.</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">positive isotropic scale factor of the basis</p>
</dd>
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">points in the q-space in which evaluate the basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r7485962ae8ea-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id43">1</a>, <a class="fn-backref" href="#id559">2</a>, <a class="fn-backref" href="#id560">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-psi-matrix">
<h3>mapmri_isotropic_psi_matrix<a class="headerlink" href="#mapmri-isotropic-psi-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_psi_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_psi_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em>, <em>rgrad</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Three dimensional isotropic MAPMRI propagator basis function from <a class="reference internal" href="#r77a51da75e29-1" id="id561">[1]</a>
Eq. (61).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">radial order of the mapmri basis.</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">positive isotropic scale factor of the basis</p>
</dd>
<dt><strong>rgrad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">points in the r-space in which evaluate the basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r77a51da75e29-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id44">1</a>, <a class="fn-backref" href="#id561">2</a>, <a class="fn-backref" href="#id562">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-radial-pdf-basis">
<h3>mapmri_isotropic_radial_pdf_basis<a class="headerlink" href="#mapmri-isotropic-radial-pdf-basis" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_radial_pdf_basis</code><span class="sig-paren">(</span><em>j</em>, <em>l</em>, <em>mu</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis" title="Permalink to this definition"></a></dt>
<dd><p>Radial part of the isotropic 1D-SHORE propagator basis <a class="reference internal" href="#r889cbb1a52b7-1" id="id563">[1]</a> eq. (61).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">a positive integer related to the radial order</p>
</dd>
<dt><strong>l</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">the spherical harmonic order</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">isotropic scale factor of the basis</p>
</dd>
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">points in the r-space in which evaluate the basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r889cbb1a52b7-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id45">1</a>, <a class="fn-backref" href="#id563">2</a>, <a class="fn-backref" href="#id564">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-isotropic-radial-signal-basis">
<h3>mapmri_isotropic_radial_signal_basis<a class="headerlink" href="#mapmri-isotropic-radial-signal-basis" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_isotropic_radial_signal_basis</code><span class="sig-paren">(</span><em>j</em>, <em>l</em>, <em>mu</em>, <em>qval</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis" title="Permalink to this definition"></a></dt>
<dd><p>Radial part of the isotropic 1D-SHORE signal basis <a class="reference internal" href="#r87b99f9c6ca2-1" id="id565">[1]</a> eq. (61).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">a positive integer related to the radial order</p>
</dd>
<dt><strong>l</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">the spherical harmonic order</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">isotropic scale factor of the basis</p>
</dd>
<dt><strong>qval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">points in the q-space in which evaluate the basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r87b99f9c6ca2-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id46">1</a>, <a class="fn-backref" href="#id565">2</a>, <a class="fn-backref" href="#id566">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-laplacian-reg-matrix">
<h3>mapmri_laplacian_reg_matrix<a class="headerlink" href="#mapmri-laplacian-reg-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_laplacian_reg_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_laplacian_reg_matrix</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>mu</em>, <em>S_mat</em>, <em>T_mat</em>, <em>U_mat</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Puts the Laplacian regularization matrix together [Rc66aaccd07c1-1] eq. (10).
The static parts in S, T and U are multiplied and divided by the
voxel-specific scale factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ind_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix (N_coef, 3),</span></dt>
<dd><p class="first last">Basis order matrix</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (3,)</span></dt>
<dd><p class="first last">scale factors of the basis for x, y, z</p>
</dd>
<dt><strong>S, T, U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrices, shape (N_coef,N_coef)</span></dt>
<dd><p class="first last">Regularization submatrices</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>LR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix (N_coef, N_coef),</span></dt>
<dd><p class="first last">Voxel-specific Laplacian regularization matrix</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>using Laplacian-regularized MAP-MRI and its application to HCP data.
NeuroImage (2016).</p>
</dd></dl>

</div>
<div class="section" id="mapmri-odf-matrix">
<h3>mapmri_odf_matrix<a class="headerlink" href="#mapmri-odf-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_odf_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_odf_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em>, <em>s</em>, <em>vertices</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_odf_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the MAPMRI ODF matrix <a class="reference internal" href="#re26b9b8173e7-1" id="id569">[1]</a>  Eq. (33).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (3,)</span></dt>
<dd><p class="first last">scale factors of the basis for x, y, z</p>
</dd>
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">radial moment of the ODF</p>
</dd>
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">points of the sphere shell in the r-space in which evaluate the ODF</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re26b9b8173e7-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id48">1</a>, <a class="fn-backref" href="#id569">2</a>, <a class="fn-backref" href="#id570">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-phi-1d">
<h3>mapmri_phi_1d<a class="headerlink" href="#mapmri-phi-1d" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_phi_1d">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_phi_1d</code><span class="sig-paren">(</span><em>n</em>, <em>q</em>, <em>mu</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_phi_1d" title="Permalink to this definition"></a></dt>
<dd><p>One dimensional MAPMRI basis function from <a class="reference internal" href="#r76e82749e6a0-1" id="id571">[1]</a> Eq. (4).</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd>order of the basis</dd>
<dt>q <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,)</span></dt>
<dd>points in the q-space in which evaluate the basis</dd>
<dt>mu <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>scale factor of the basis</dd>
</dl>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r76e82749e6a0-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id49">1</a>, <a class="fn-backref" href="#id571">2</a>, <a class="fn-backref" href="#id572">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-phi-matrix">
<h3>mapmri_phi_matrix<a class="headerlink" href="#mapmri-phi-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_phi_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_phi_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em>, <em>q_gradients</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_phi_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the MAPMRI phi matrix for the signal <a class="reference internal" href="#r3a5a50d36842-1" id="id573">[1]</a> eq. (23).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (3,)</span></dt>
<dd><p class="first last">scale factors of the basis for x, y, z</p>
</dd>
<dt><strong>q_gradients</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">points in the q-space in which evaluate the basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r3a5a50d36842-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id50">1</a>, <a class="fn-backref" href="#id573">2</a>, <a class="fn-backref" href="#id574">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-psi-1d">
<h3>mapmri_psi_1d<a class="headerlink" href="#mapmri-psi-1d" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_psi_1d">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_psi_1d</code><span class="sig-paren">(</span><em>n</em>, <em>x</em>, <em>mu</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_psi_1d" title="Permalink to this definition"></a></dt>
<dd><p>One dimensional MAPMRI propagator basis function from <a class="reference internal" href="#rb9b07bc1eb95-1" id="id575">[1]</a> Eq. (10).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">order of the basis</p>
</dd>
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,)</span></dt>
<dd><p class="first last">points in the r-space in which evaluate the basis</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">scale factor of the basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb9b07bc1eb95-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id51">1</a>, <a class="fn-backref" href="#id575">2</a>, <a class="fn-backref" href="#id576">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mapmri-psi-matrix">
<h3>mapmri_psi_matrix<a class="headerlink" href="#mapmri-psi-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mapmri_psi_matrix">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mapmri_psi_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>mu</em>, <em>rgrad</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mapmri_psi_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the MAPMRI psi matrix for the propagator <a class="reference internal" href="#rf11279199519-1" id="id577">[1]</a> eq. (22).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (3,)</span></dt>
<dd><p class="first last">scale factors of the basis for x, y, z</p>
</dd>
<dt><strong>rgrad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">points in the r-space in which evaluate the EAP</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rf11279199519-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id52">1</a>, <a class="fn-backref" href="#id577">2</a>, <a class="fn-backref" href="#id578">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

</div>
<div class="section" id="mfactorial">
<h3>mfactorial<a class="headerlink" href="#mfactorial" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.mfactorial">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">mfactorial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.mfactorial" title="Permalink to this definition"></a></dt>
<dd><p>factorial(x) -&gt; Integral</p>
<p>Find x!. Raise a ValueError if x is negative or non-integral.</p>
</dd></dl>

</div>
<div class="section" id="id579">
<h3>multi_voxel_fit<a class="headerlink" href="#id579" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.multi_voxel_fit">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="id580">
<h3>optional_package<a class="headerlink" href="#id580" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.optional_package">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">optional_package</code><span class="sig-paren">(</span><em>name</em>, <em>trip_msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.optional_package" title="Permalink to this definition"></a></dt>
<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">package name</p>
</dd>
<dt><strong>trip_msg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or str</span></dt>
<dd><p class="first last">message to give when someone tries to use the return package, but we
could not import it, and have returned a TripWire object instead.
Default message if None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pkg_like</strong> <span class="classifier-delimiter">:</span> <span class="classifier">module or <code class="docutils literal notranslate"><span class="pre">TripWire</span></code> instance</span></dt>
<dd><p class="first last">If we can import the package, return it.  Otherwise return an object
raising an error when accessed</p>
</dd>
<dt><strong>have_pkg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if import for package was successful, false otherwise</p>
</dd>
<dt><strong>module_setup</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">callable usually set as <code class="docutils literal notranslate"><span class="pre">setup_module</span></code> in calling namespace, to allow
skipping tests.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id581">
<h3>real_sph_harm<a class="headerlink" href="#id581" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.real_sph_harm">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">real_sph_harm</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.real_sph_harm" title="Permalink to this definition"></a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>Where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:</p>
<blockquote>
<div>Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
<span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code></span></dt>
<dd><p class="first last">The order of the harmonic.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt>
<dd><p class="first last">The degree of the harmonic.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">real float</span></dt>
<dd><p class="first last">The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.special.sph_harm</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="sfactorial">
<h3>sfactorial<a class="headerlink" href="#sfactorial" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.sfactorial">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">sfactorial</code><span class="sig-paren">(</span><em>n</em>, <em>exact=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.sfactorial" title="Permalink to this definition"></a></dt>
<dd><p>The factorial of a number or array of numbers.</p>
<p>The factorial of non-negative integer <cite>n</cite> is the product of all
positive integers less than or equal to <cite>n</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>n! = n * (n - 1) * (n - 2) * ... * 1
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array_like of ints</span></dt>
<dd><p class="first last">Input values.  If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, the return value is 0.</p>
</dd>
<dt><strong>exact</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, calculate the answer exactly using long integer arithmetic.
If False, result is approximated in floating point rapidly using the
<cite>gamma</cite> function.
Default is False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or int or ndarray</span></dt>
<dd><p class="first last">Factorial of <cite>n</cite>, as integer or float depending on <cite>exact</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For arrays with <code class="docutils literal notranslate"><span class="pre">exact=True</span></code>, the factorial is computed only once, for
the largest input, with each other result computed in the process.
The output dtype is increased to <code class="docutils literal notranslate"><span class="pre">int64</span></code> or <code class="docutils literal notranslate"><span class="pre">object</span></code> if necessary.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">exact=False</span></code> the factorial is approximated using the gamma
function:</p>
<div class="math notranslate nohighlight">
\[n! = \Gamma(n+1)\]</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">factorial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([   6.,   24.,  120.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([  6,  24, 120])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">120L</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id582">
<h3>sph_harm_ind_list<a class="headerlink" href="#id582" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.sph_harm_ind_list">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">sph_harm_ind_list</code><span class="sig-paren">(</span><em>sh_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.sph_harm_ind_list" title="Permalink to this definition"></a></dt>
<dd><p>Returns the degree (n) and order (m) of all the symmetric spherical
harmonics of degree less then or equal to <cite>sh_order</cite>. The results, <cite>m_list</cite>
and <cite>n_list</cite> are kx1 arrays, where k depends on sh_order. They can be
passed to <a class="reference internal" href="#dipy.reconst.mapmri.real_sph_harm" title="dipy.reconst.mapmri.real_sph_harm"><code class="xref py py-func docutils literal notranslate"><span class="pre">real_sph_harm()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">even int &gt; 0, max degree to return</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>m_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">orders of even spherical harmonics</p>
</dd>
<dt><strong>n_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">degrees of even spherical harmonics</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.mapmri.real_sph_harm" title="dipy.reconst.mapmri.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="id583">
<h3>warn<a class="headerlink" href="#id583" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.mapmri.warn">
<code class="descclassname">dipy.reconst.mapmri.</code><code class="descname">warn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.mapmri.warn" title="Permalink to this definition"></a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
<div class="section" id="callablearray">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.CallableArray" title="dipy.reconst.multi_voxel.CallableArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CallableArray</span></code></a><a class="headerlink" href="#callablearray" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.multi_voxel.CallableArray">
<em class="property">class </em><code class="descclassname">dipy.reconst.multi_voxel.</code><code class="descname">CallableArray</code><a class="headerlink" href="#dipy.reconst.multi_voxel.CallableArray" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
<p>An array which can be called like a function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></dt>
<dd><p class="first last">Same as self.transpose(), except that self is returned if self.ndim &lt; 2.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd><p class="first last">Base object if memory is from some other object.</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/library/ctypes.html#module-ctypes" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></a></dt>
<dd><p class="first last">An object to simplify the interaction of the array with the ctypes module.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></dt>
<dd><p class="first last">Python buffer object pointing to the start of the arrays data.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></dt>
<dd><p class="first last">Data-type of the arrays elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd><p class="first last">Information about the memory layout of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></dt>
<dd><p class="first last">A 1-D iterator over the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></dt>
<dd><p class="first last">The imaginary part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></dt>
<dd><p class="first last">Length of one array element in bytes.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></dt>
<dd><p class="first last">Total bytes consumed by the elements of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></dt>
<dd><p class="first last">Number of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></dt>
<dd><p class="first last">The real part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt>
<dd><p class="first last">Tuple of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd><p class="first last">Number of elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></dt>
<dd><p class="first last">Tuple of bytes to step in each dimension when traversing an array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(*args,&nbsp;**kwargs)</td>
<td>Call self as a function.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns True if all elements evaluate to True.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns True if any of the elements of <cite>a</cite> evaluate to True.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code>([axis,&nbsp;out])</td>
<td>Return indices of the maximum values along the given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code>([axis,&nbsp;out])</td>
<td>Return indices of the minimum values along the given axis of <cite>a</cite>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argpartition</span></code>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would partition this array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would sort this array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code>(dtype[,&nbsp;order,&nbsp;casting,&nbsp;subok,&nbsp;copy])</td>
<td>Copy of the array, cast to a specified type.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">byteswap</span></code>([inplace])</td>
<td>Swap the bytes of the array elements</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code>(choices[,&nbsp;out,&nbsp;mode])</td>
<td>Use an index array to construct a new array from a set of choices.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([min,&nbsp;max,&nbsp;out])</td>
<td>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code>(condition[,&nbsp;axis,&nbsp;out])</td>
<td>Return selected slices of this array along given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code>()</td>
<td>Complex-conjugate all elements.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code>()</td>
<td>Return the complex conjugate, element-wise.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>([order])</td>
<td>Return a copy of the array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative product of the elements along the given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative sum of the elements along the given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code>([offset,&nbsp;axis1,&nbsp;axis2])</td>
<td>Return specified diagonals.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code>(b[,&nbsp;out])</td>
<td>Dot product of two arrays.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump</span></code>(file)</td>
<td>Dump a pickle of the array to the specified file.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumps</span></code>()</td>
<td>Returns the pickle of the array as a string.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill</span></code>(value)</td>
<td>Fill the array with a scalar value.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code>([order])</td>
<td>Return a copy of the array collapsed into one dimension.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">getfield</span></code>(dtype[,&nbsp;offset])</td>
<td>Returns a field of the given array as a certain type.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">item</span></code>(*args)</td>
<td>Copy an element of an array to a standard Python scalar and return it.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemset</span></code>(*args)</td>
<td>Insert scalar into an array (scalar is cast to arrays dtype, if possible)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the maximum along a given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns the average of the array elements along given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the minimum along a given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">newbyteorder</span></code>([new_order])</td>
<td>Return the array with the same data viewed with a different byte order.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code>()</td>
<td>Return the indices of the elements that are non-zero.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the product of the array elements over the given axis</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptp</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Peak to peak (maximum - minimum) value along a given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code>(indices,&nbsp;values[,&nbsp;mode])</td>
<td>Set <code class="docutils literal notranslate"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for all <cite>n</cite> in indices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code>([order])</td>
<td>Return a flattened array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code>(repeats[,&nbsp;axis])</td>
<td>Repeat elements of an array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code>(shape[,&nbsp;order])</td>
<td>Returns an array containing the same data with a new shape.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code>(new_shape[,&nbsp;refcheck])</td>
<td>Change shape and size of array in-place.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code>([decimals,&nbsp;out])</td>
<td>Return <cite>a</cite> with each element rounded to the given number of decimals.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code>(v[,&nbsp;side,&nbsp;sorter])</td>
<td>Find indices where elements of v should be inserted in a to maintain order.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">setfield</span></code>(val,&nbsp;dtype[,&nbsp;offset])</td>
<td>Put a value into a specified place in a field defined by a data-type.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">setflags</span></code>([write,&nbsp;align,&nbsp;uic])</td>
<td>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Sort an array, in-place.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code>([axis])</td>
<td>Remove single-dimensional entries from the shape of <cite>a</cite>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof,&nbsp;keepdims])</td>
<td>Returns the standard deviation of the array elements along given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the sum of the array elements over the given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code>(axis1,&nbsp;axis2)</td>
<td>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code>(indices[,&nbsp;axis,&nbsp;out,&nbsp;mode])</td>
<td>Return an array formed from the elements of <cite>a</cite> at the given indices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tobytes</span></code>([order])</td>
<td>Construct Python bytes containing the raw data bytes in the array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tofile</span></code>(fid[,&nbsp;sep,&nbsp;format])</td>
<td>Write array to a file as text or binary (default).</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code>()</td>
<td>Return the array as a (possibly nested) list.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tostring</span></code>([order])</td>
<td>Construct Python bytes containing the raw data bytes in the array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>([offset,&nbsp;axis1,&nbsp;axis2,&nbsp;dtype,&nbsp;out])</td>
<td>Return the sum along diagonals of the array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code>(*axes)</td>
<td>Returns a view of the array with axes transposed.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof,&nbsp;keepdims])</td>
<td>Returns the variance of the array elements, along given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code>([dtype,&nbsp;type])</td>
<td>New view of array with the same data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.multi_voxel.CallableArray.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.CallableArray.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="multivoxelfit">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="dipy.reconst.multi_voxel.MultiVoxelFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiVoxelFit</span></code></a><a class="headerlink" href="#multivoxelfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.multi_voxel.MultiVoxelFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.multi_voxel.</code><code class="descname">MultiVoxelFit</code><span class="sig-paren">(</span><em>model</em>, <em>fit_array</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstFit</span></code></a></p>
<p>Holds an array of fits and allows access to their attributes and
methods</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.multi_voxel.MultiVoxelFit.predict" title="dipy.reconst.multi_voxel.MultiVoxelFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Predict for the multi-voxel object using each single-objects prediction API, with S0 provided from an array.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.multi_voxel.MultiVoxelFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>fit_array</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.multi_voxel.MultiVoxelFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict for the multi-voxel object using each single-objects
prediction API, with S0 provided from an array.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.multi_voxel.MultiVoxelFit.shape">
<code class="descname">shape</code><a class="headerlink" href="#dipy.reconst.multi_voxel.MultiVoxelFit.shape" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id584">
<h3><a class="reference internal" href="#dipy.reconst.multi_voxel.ReconstFit" title="dipy.reconst.multi_voxel.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><a class="headerlink" href="#id584" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.multi_voxel.ReconstFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.multi_voxel.</code><code class="descname">ReconstFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.ReconstFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.multi_voxel.ReconstFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.ReconstFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="as-strided">
<h3>as_strided<a class="headerlink" href="#as-strided" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.multi_voxel.as_strided">
<code class="descclassname">dipy.reconst.multi_voxel.</code><code class="descname">as_strided</code><span class="sig-paren">(</span><em>x</em>, <em>shape=None</em>, <em>strides=None</em>, <em>subok=False</em>, <em>writeable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.as_strided" title="Permalink to this definition"></a></dt>
<dd><p>Create a view into the array with the given shape and strides.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function has to be used with extreme care, see notes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Array to create a new.</p>
</dd>
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of int, optional</span></dt>
<dd><p class="first last">The shape of the new array. Defaults to <code class="docutils literal notranslate"><span class="pre">x.shape</span></code>.</p>
</dd>
<dt><strong>strides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of int, optional</span></dt>
<dd><p class="first last">The strides of the new array. Defaults to <code class="docutils literal notranslate"><span class="pre">x.strides</span></code>.</p>
</dd>
<dt><strong>subok</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><div class="first versionadded">
<p><span class="versionmodified">New in version 1.10.</span></p>
</div>
<p class="last">If True, subclasses are preserved.</p>
</dd>
<dt><strong>writeable</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><div class="first versionadded">
<p><span class="versionmodified">New in version 1.12.</span></p>
</div>
<p class="last">If set to False, the returned array will always be readonly.
Otherwise it will be writable if the original array was. It
is advisable to set this to False if possible (see Notes).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>view</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast_to</span></code></dt>
<dd>broadcast an array to a given shape.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code></dt>
<dd>reshape an array.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">as_strided</span></code> creates a view into the array given the exact strides
and shape. This means it manipulates the internal data structure of
ndarray and, if done incorrectly, the array elements can point to
invalid memory and can corrupt results or crash your program.
It is advisable to always use the original <code class="docutils literal notranslate"><span class="pre">x.strides</span></code> when
calculating new strides to avoid reliance on a contiguous memory
layout.</p>
<p>Furthermore, arrays created with this function often contain self
overlapping memory, so that two elements are identical.
Vectorized write operations on such arrays will typically be
unpredictable. They may even give different results for small, large,
or transposed arrays.
Since writing to these arrays has to be tested and done with great
care, you may want to use <code class="docutils literal notranslate"><span class="pre">writeable=False</span></code> to avoid accidental write
operations.</p>
<p>For these reasons it is advisable to avoid <code class="docutils literal notranslate"><span class="pre">as_strided</span></code> when
possible.</p>
</dd></dl>

</div>
<div class="section" id="id585">
<h3>multi_voxel_fit<a class="headerlink" href="#id585" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.multi_voxel.multi_voxel_fit">
<code class="descclassname">dipy.reconst.multi_voxel.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="id586">
<h3>ndindex<a class="headerlink" href="#id586" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.multi_voxel.ndindex">
<code class="descclassname">dipy.reconst.multi_voxel.</code><code class="descname">ndindex</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.multi_voxel.ndindex" title="Permalink to this definition"></a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd><p class="first last">The dimensions of the array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="k">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id587">
<h3><a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a><a class="headerlink" href="#id587" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.odf.OdfFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.odf.</code><code class="descname">OdfFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstFit</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.OdfFit.odf" title="dipy.reconst.odf.OdfFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>To be implemented but specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.odf.OdfFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.odf.OdfFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id588">
<h3><a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a><a class="headerlink" href="#id588" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.odf.OdfModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.odf.</code><code class="descname">OdfModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as its
first and only argument.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.odf.OdfModel.fit" title="dipy.reconst.odf.OdfModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.odf.OdfModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.odf.OdfModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.OdfModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id589">
<h3><a class="reference internal" href="#dipy.reconst.odf.ReconstFit" title="dipy.reconst.odf.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><a class="headerlink" href="#id589" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.odf.ReconstFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.odf.</code><code class="descname">ReconstFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.ReconstFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.odf.ReconstFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.ReconstFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id590">
<h3><a class="reference internal" href="#dipy.reconst.odf.ReconstModel" title="dipy.reconst.odf.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#id590" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.odf.ReconstModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.odf.</code><code class="descname">ReconstModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.ReconstModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.odf.ReconstModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.ReconstModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.odf.ReconstModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.ReconstModel.fit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id591">
<h3>gfa<a class="headerlink" href="#id591" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.odf.gfa">
<code class="descclassname">dipy.reconst.odf.</code><code class="descname">gfa</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.gfa" title="Permalink to this definition"></a></dt>
<dd><p>The general fractional anisotropy of a function evaluated
on the unit sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Values of data on the unit sphere.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gfa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">GFA evaluated in each entry of the array, along the last dimension.
An <cite>np.nan</cite> is returned for coordinates that contain all-zeros in
<cite>samples</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The GFA is defined as <a class="reference internal" href="#r6d0af26625ec-1" id="id592">[1]</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">sqrt</span><span class="p">{</span>\<span class="n">frac</span><span class="p">{</span><span class="n">n</span> \<span class="n">sum_i</span><span class="p">{(</span>\<span class="n">Psi_i</span> <span class="o">-</span> <span class="o">&lt;</span>\<span class="n">Psi</span><span class="o">&gt;</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">}}{(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> \<span class="nb">sum</span><span class="p">{</span>\<span class="n">Psi_i</span> <span class="o">^</span> <span class="mi">2</span><span class="p">}}}</span>
</pre></div>
</div>
<p>Where <span class="math notranslate nohighlight">\(\Psi\)</span> is an orientation distribution function sampled discretely on
the unit sphere and angle brackets denote average over the samples on the
sphere.</p>
<table class="docutils citation" frame="void" id="r6d0af26625ec-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id592">[1]</a></td><td>Quality assessment of High Angular Resolution Diffusion Imaging
data using bootstrap on Q-ball reconstruction. J. Cohen Adad, M.
Descoteaux, L.L. Wald. JMRI 33: 1194-1208.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="minmax-normalize">
<h3>minmax_normalize<a class="headerlink" href="#minmax-normalize" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.odf.minmax_normalize">
<code class="descclassname">dipy.reconst.odf.</code><code class="descname">minmax_normalize</code><span class="sig-paren">(</span><em>samples</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.odf.minmax_normalize" title="Permalink to this definition"></a></dt>
<dd><p>Min-max normalization of a function evaluated on the unit sphere</p>
<p>Normalizes samples to <code class="docutils literal notranslate"><span class="pre">(samples</span> <span class="pre">-</span> <span class="pre">min(samples))</span> <span class="pre">/</span> <span class="pre">(max(samples)</span> <span class="pre">-</span>
<span class="pre">min(samples))</span></code> for each unit sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (, N)</span></dt>
<dd><p class="first last">N samples on a unit sphere for each point, stored along the last axis
of the array.</p>
</dd>
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndrray (, N), optional</span></dt>
<dd><p class="first last">An array to store the normalized samples.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, (, N)</span></dt>
<dd><p class="first last">Normalized samples.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="intemporarydirectory">
<h3><a class="reference internal" href="#dipy.reconst.peaks.InTemporaryDirectory" title="dipy.reconst.peaks.InTemporaryDirectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">InTemporaryDirectory</span></code></a><a class="headerlink" href="#intemporarydirectory" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.InTemporaryDirectory">
<em class="property">class </em><code class="descclassname">dipy.reconst.peaks.</code><code class="descname">InTemporaryDirectory</code><span class="sig-paren">(</span><em>suffix=''</em>, <em>prefix='tmp'</em>, <em>dir=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.InTemporaryDirectory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.tmpdirs.TemporaryDirectory</span></code></p>
<p>Create, return, and change directory to a temporary directory</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">InTemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmpdir</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;some text&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="s1">&#39;test.txt&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span> <span class="s1">&#39;test.txt&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">==</span> <span class="n">my_cwd</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="48%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>cleanup</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.InTemporaryDirectory.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>suffix=''</em>, <em>prefix='tmp'</em>, <em>dir=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.InTemporaryDirectory.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="peaksandmetrics">
<h3><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetrics" title="dipy.reconst.peaks.PeaksAndMetrics"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeaksAndMetrics</span></code></a><a class="headerlink" href="#peaksandmetrics" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.PeaksAndMetrics">
<em class="property">class </em><code class="descclassname">dipy.reconst.peaks.</code><code class="descname">PeaksAndMetrics</code><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetrics" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.peak_direction_getter.PeaksAndMetricsDirectionGetter</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ang_thr</strong></dt>
<dd></dd>
<dt><strong>qa_thr</strong></dt>
<dd></dd>
<dt><strong>total_weight</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">initial_direction</span></code></td>
<td>The best starting directions for fiber tracking from point</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="37%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>get_direction</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.PeaksAndMetrics.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetrics.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="peaksandmetricsdirectiongetter">
<h3><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter" title="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeaksAndMetricsDirectionGetter</span></code></a><a class="headerlink" href="#peaksandmetricsdirectiongetter" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter">
<em class="property">class </em><code class="descclassname">dipy.reconst.peaks.</code><code class="descname">PeaksAndMetricsDirectionGetter</code><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.local.direction_getter.DirectionGetter</span></code></p>
<p>Deterministic Direction Getter based on peak directions.</p>
<p>This class contains the cython portion of the code for PeaksAndMetrics and
is not meant to be used on its own.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ang_thr</strong></dt>
<dd></dd>
<dt><strong>qa_thr</strong></dt>
<dd></dd>
<dt><strong>total_weight</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.initial_direction" title="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.initial_direction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initial_direction</span></code></a></td>
<td>The best starting directions for fiber tracking from point</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="37%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>get_direction</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.ang_thr">
<code class="descname">ang_thr</code><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.ang_thr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.initial_direction">
<code class="descname">initial_direction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.initial_direction" title="Permalink to this definition"></a></dt>
<dd><p>The best starting directions for fiber tracking from point</p>
<p>All the valid peaks in the voxel closest to point are returned as
initial directions.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.qa_thr">
<code class="descname">qa_thr</code><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.qa_thr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.total_weight">
<code class="descname">total_weight</code><a class="headerlink" href="#dipy.reconst.peaks.PeaksAndMetricsDirectionGetter.total_weight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="sphere">
<h3><a class="reference internal" href="#dipy.reconst.peaks.Sphere" title="dipy.reconst.peaks.Sphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sphere</span></code></a><a class="headerlink" href="#sphere" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.Sphere">
<em class="property">class </em><code class="descclassname">dipy.reconst.peaks.</code><code class="descname">Sphere</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.Sphere" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Points on the unit sphere.</p>
<p>The sphere can be constructed using one of three conventions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">Sphere</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x, y, z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array_like</span></dt>
<dd><p class="first last">Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>theta, phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array_like</span></dt>
<dd><p class="first last">Vertices as spherical coordinates.  Theta and phi are the inclination
and azimuth angles respectively.</p>
</dd>
<dt><strong>xyz</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 3) ndarray</span></dt>
<dd><p class="first last">Vertices as x-y-z coordinates.</p>
</dd>
<dt><strong>faces</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 3) ndarray</span></dt>
<dd><p class="first last">Indices into vertices that form triangular faces.  If unspecified,
the faces are computed using a Delaunay triangulation.</p>
</dd>
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) ndarray</span></dt>
<dd><p class="first last">Edges between vertices.  If unspecified, the edges are
derived from the faces.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong></dt>
<dd></dd>
<dt><strong>y</strong></dt>
<dd></dd>
<dt><strong>z</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.peaks.Sphere.find_closest" title="dipy.reconst.peaks.Sphere.find_closest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_closest</span></code></a>(xyz)</td>
<td>Find the index of the vertex in the Sphere closest to the input vector</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.peaks.Sphere.subdivide" title="dipy.reconst.peaks.Sphere.subdivide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code></a>([n])</td>
<td>Subdivides each face of the sphere into four new faces.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="45%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>edges</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>faces</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>vertices</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.peaks.Sphere.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>theta=None</em>, <em>phi=None</em>, <em>xyz=None</em>, <em>faces=None</em>, <em>edges=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.Sphere.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.Sphere.edges">
<code class="descname">edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.Sphere.edges" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.Sphere.faces">
<code class="descname">faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.Sphere.faces" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.Sphere.find_closest">
<code class="descname">find_closest</code><span class="sig-paren">(</span><em>xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.Sphere.find_closest" title="Permalink to this definition"></a></dt>
<dd><p>Find the index of the vertex in the Sphere closest to the input vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>xyz</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, 3 elements</span></dt>
<dd><p class="first last">A unit vector</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.Sphere.subdivide">
<code class="descname">subdivide</code><span class="sig-paren">(</span><em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.Sphere.subdivide" title="Permalink to this definition"></a></dt>
<dd><p>Subdivides each face of the sphere into four new faces.</p>
<p>New vertices are created at a, b, and c. Then each face [x, y, z] is
divided into faces [x, a, c], [y, a, b], [z, b, c], and [a, b, c].</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   y
   /               /               a/____
/\    /            /  \  /             /____\/____          x      c     z
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of subdivisions to preform.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The subdivided sphere.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.peaks.Sphere.vertices">
<code class="descname">vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.Sphere.vertices" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.Sphere.x">
<code class="descname">x</code><a class="headerlink" href="#dipy.reconst.peaks.Sphere.x" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.Sphere.y">
<code class="descname">y</code><a class="headerlink" href="#dipy.reconst.peaks.Sphere.y" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.peaks.Sphere.z">
<code class="descname">z</code><a class="headerlink" href="#dipy.reconst.peaks.Sphere.z" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="repeat">
<h3><a class="reference internal" href="#dipy.reconst.peaks.repeat" title="dipy.reconst.peaks.repeat"><code class="xref py py-class docutils literal notranslate"><span class="pre">repeat</span></code></a><a class="headerlink" href="#repeat" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.peaks.repeat">
<em class="property">class </em><code class="descclassname">dipy.reconst.peaks.</code><code class="descname">repeat</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>times</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; create an iterator which returns the object<a class="headerlink" href="#dipy.reconst.peaks.repeat" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>for the specified number of times.  If not specified, returns the object
endlessly.</p>
<dl class="method">
<dt id="dipy.reconst.peaks.repeat.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.repeat.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="xrange">
<h3><a class="reference internal" href="#dipy.reconst.peaks.xrange" title="dipy.reconst.peaks.xrange"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrange</span></code></a><a class="headerlink" href="#xrange" title="Permalink to this headline"></a></h3>
<dl class="attribute">
<dt id="dipy.reconst.peaks.xrange">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">xrange</code><a class="headerlink" href="#dipy.reconst.peaks.xrange" title="Permalink to this definition"></a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.range</span></code></p>
</dd></dl>

</div>
<div class="section" id="pool">
<h3>Pool<a class="headerlink" href="#pool" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.Pool">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">Pool</code><span class="sig-paren">(</span><em>processes=None</em>, <em>initializer=None</em>, <em>initargs=()</em>, <em>maxtasksperchild=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.Pool" title="Permalink to this definition"></a></dt>
<dd><p>Returns a process pool object</p>
</dd></dl>

</div>
<div class="section" id="cpu-count">
<h3>cpu_count<a class="headerlink" href="#cpu-count" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.cpu_count">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">cpu_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.cpu_count" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of CPUs in the system</p>
</dd></dl>

</div>
<div class="section" id="id593">
<h3>gfa<a class="headerlink" href="#id593" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.gfa">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">gfa</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.gfa" title="Permalink to this definition"></a></dt>
<dd><p>The general fractional anisotropy of a function evaluated
on the unit sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Values of data on the unit sphere.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gfa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">GFA evaluated in each entry of the array, along the last dimension.
An <cite>np.nan</cite> is returned for coordinates that contain all-zeros in
<cite>samples</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The GFA is defined as <a class="reference internal" href="#ra9cd169a6918-1" id="id594">[1]</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">sqrt</span><span class="p">{</span>\<span class="n">frac</span><span class="p">{</span><span class="n">n</span> \<span class="n">sum_i</span><span class="p">{(</span>\<span class="n">Psi_i</span> <span class="o">-</span> <span class="o">&lt;</span>\<span class="n">Psi</span><span class="o">&gt;</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">}}{(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> \<span class="nb">sum</span><span class="p">{</span>\<span class="n">Psi_i</span> <span class="o">^</span> <span class="mi">2</span><span class="p">}}}</span>
</pre></div>
</div>
<p>Where <span class="math notranslate nohighlight">\(\Psi\)</span> is an orientation distribution function sampled discretely on
the unit sphere and angle brackets denote average over the samples on the
sphere.</p>
<table class="docutils citation" frame="void" id="ra9cd169a6918-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id594">[1]</a></td><td>Quality assessment of High Angular Resolution Diffusion Imaging
data using bootstrap on Q-ball reconstruction. J. Cohen Adad, M.
Descoteaux, L.L. Wald. JMRI 33: 1194-1208.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id595">
<h3>local_maxima<a class="headerlink" href="#id595" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.local_maxima">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">local_maxima</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.local_maxima" title="Permalink to this definition"></a></dt>
<dd><p>Local maxima of a function evaluated on a discrete set of points.</p>
<p>If a function is evaluated on some set of points where each pair of
neighboring points is an edge in edges, find the local maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, 1d, dtype=double</span></dt>
<dd><p class="first last">The function evaluated on a set of discrete points.</p>
</dd>
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, 2)</span></dt>
<dd><p class="first last">The set of neighbor relations between the points. Every edge, ie
<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>peak_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Value of odf at a maximum point. Peak values is sorted in descending
order.</p>
</dd>
<dt><strong>peak_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so
<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="dipy.core.html#module-dipy.core.sphere" title="dipy.core.sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dipy.core.sphere</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="id596">
<h3>ndindex<a class="headerlink" href="#id596" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.ndindex">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">ndindex</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.ndindex" title="Permalink to this definition"></a></dt>
<dd><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned; the last dimension is iterated over first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd><p class="first last">The dimensions of the array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.ndindex</span> <span class="k">import</span> <span class="n">ndindex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="peak-directions">
<h3>peak_directions<a class="headerlink" href="#peak-directions" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.peak_directions">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">peak_directions</code><span class="sig-paren">(</span><em>odf</em>, <em>sphere</em>, <em>relative_peak_threshold=0.5</em>, <em>min_separation_angle=25</em>, <em>minmax_norm=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.peak_directions" title="Permalink to this definition"></a></dt>
<dd><p>Get the directions of odf peaks.</p>
<p>Peaks are defined as points on the odf that are greater than at least one
neighbor and greater than or equal to all neighbors. Peaks are sorted in
descending order by their values then filtered based on their relative size
and spacing on the sphere. An odf may have 0 peaks, for example if the odf
is perfectly isotropic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray</span></dt>
<dd><p class="first last">The odf function evaluated on the vertices of <cite>sphere</cite></p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The Sphere providing discrete directions for evaluation.</p>
</dd>
<dt><strong>relative_peak_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float in [0., 1.]</span></dt>
<dd><p class="first last">Only peaks greater than <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">+</span> <span class="pre">relative_peak_threshold</span> <span class="pre">*</span> <span class="pre">scale</span></code> are
kept, where <code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">=</span> <span class="pre">max(0,</span> <span class="pre">odf.min())</span></code> and
<code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">=</span> <span class="pre">odf.max()</span> <span class="pre">-</span> <span class="pre">min</span></code>.</p>
</dd>
<dt><strong>min_separation_angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float in [0, 90]</span></dt>
<dd><p class="first last">The minimum distance between directions. If two peaks are too close
only the larger of the two is returned.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>directions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 3) ndarray</span></dt>
<dd><p class="first last">N vertices for sphere, one for each peak</p>
</dd>
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last">peak values</p>
</dd>
<dt><strong>indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last">peak indices of the directions on the sphere</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If the odf has any negative values, they will be clipped to zeros.</p>
</dd></dl>

</div>
<div class="section" id="peak-directions-nl">
<h3>peak_directions_nl<a class="headerlink" href="#peak-directions-nl" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.peak_directions_nl">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">peak_directions_nl</code><span class="sig-paren">(</span><em>sphere_eval</em>, <em>relative_peak_threshold=0.25</em>, <em>min_separation_angle=25</em>, <em>sphere=&lt;dipy.core.sphere.HemiSphere object&gt;</em>, <em>xtol=1e-07</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.peak_directions_nl" title="Permalink to this definition"></a></dt>
<dd><p>Non Linear Direction Finder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere_eval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">A function which can be evaluated on a sphere.</p>
</dd>
<dt><strong>relative_peak_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Only return peaks greater than <code class="docutils literal notranslate"><span class="pre">relative_peak_threshold</span> <span class="pre">*</span> <span class="pre">m</span></code> where m
is the largest peak.</p>
</dd>
<dt><strong>min_separation_angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float in [0, 90]</span></dt>
<dd><p class="first last">The minimum distance between directions. If two peaks are too close
only the larger of the two is returned.</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">A discrete Sphere. The points on the sphere will be used for initial
estimate of maximums.</p>
</dd>
<dt><strong>xtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Relative tolerance for optimization.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>directions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, 3)</span></dt>
<dd><p class="first last">Points on the sphere corresponding to N local maxima on the sphere.</p>
</dd>
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N,)</span></dt>
<dd><p class="first last">Value of sphere_eval at each point on directions.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id597">
<h3>peaks_from_model<a class="headerlink" href="#id597" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.peaks_from_model">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">peaks_from_model</code><span class="sig-paren">(</span><em>model</em>, <em>data</em>, <em>sphere</em>, <em>relative_peak_threshold</em>, <em>min_separation_angle</em>, <em>mask=None</em>, <em>return_odf=False</em>, <em>return_sh=True</em>, <em>gfa_thr=0</em>, <em>normalize_peaks=False</em>, <em>sh_order=8</em>, <em>sh_basis_type=None</em>, <em>npeaks=5</em>, <em>B=None</em>, <em>invB=None</em>, <em>parallel=False</em>, <em>nbr_processes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.peaks_from_model" title="Permalink to this definition"></a></dt>
<dd><p>Fit the model to data and computes peaks and metrics</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a model instance</span></dt>
<dd><p class="first last"><cite>model</cite> will be used to fit the data.</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The Sphere providing discrete directions for evaluation.</p>
</dd>
<dt><strong>relative_peak_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Only return peaks greater than <code class="docutils literal notranslate"><span class="pre">relative_peak_threshold</span> <span class="pre">*</span> <span class="pre">m</span></code> where m
is the largest peak.</p>
</dd>
<dt><strong>min_separation_angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float in [0, 90] The minimum distance between</span></dt>
<dd><p class="first last">directions. If two peaks are too close only the larger of the two is
returned.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd><p class="first last">If <cite>mask</cite> is provided, voxels that are False in <cite>mask</cite> are skipped and
no peaks are returned.</p>
</dd>
<dt><strong>return_odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, the odfs are returned.</p>
</dd>
<dt><strong>return_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, the odf as spherical harmonics coefficients is returned</p>
</dd>
<dt><strong>gfa_thr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Voxels with gfa less than <cite>gfa_thr</cite> are skipped, no peaks are returned.</p>
</dd>
<dt><strong>normalize_peaks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, all peak values are calculated relative to <cite>max(odf)</cite>.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients (default 8).</p>
</dd>
<dt><strong>sh_basis_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, tournier07, descoteaux07}</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="reference internal" href="#r5c88bcbc3a09-2" id="id598">[2]</a> basis, and
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="reference internal" href="#r5c88bcbc3a09-1" id="id599">[1]</a> basis
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>sh_smooth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Lambda-regularization in the SH fit (default 0.0).</p>
</dd>
<dt><strong>npeaks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of peaks found (default 5 peaks).</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">Matrix that transforms spherical harmonics to spherical function
<code class="docutils literal notranslate"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></code>.</p>
</dd>
<dt><strong>invB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">Inverse of B.</p>
</dd>
<dt><strong>parallel: bool</strong></dt>
<dd><p class="first last">If True, use multiprocessing to compute peaks and metric
(default False). Temporary files are saved in the default temporary
directory of the system. It can be changed using <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">tempfile</span></code>
and <code class="docutils literal notranslate"><span class="pre">tempfile.tempdir</span> <span class="pre">=</span> <span class="pre">'/path/to/tempdir'</span></code>.</p>
</dd>
<dt><strong>nbr_processes: int</strong></dt>
<dd><p class="first last">If <cite>parallel</cite> is True, the number of subprocesses to use
(default multiprocessing.cpu_count()).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pam</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PeaksAndMetrics</span></dt>
<dd><p class="first last">An object with <code class="docutils literal notranslate"><span class="pre">gfa</span></code>, <code class="docutils literal notranslate"><span class="pre">peak_directions</span></code>, <code class="docutils literal notranslate"><span class="pre">peak_values</span></code>,
<code class="docutils literal notranslate"><span class="pre">peak_indices</span></code>, <code class="docutils literal notranslate"><span class="pre">odf</span></code>, <code class="docutils literal notranslate"><span class="pre">shm_coeffs</span></code> as attributes</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r5c88bcbc3a09-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id599">1</a>, <a class="fn-backref" href="#id600">2</a>)</em> Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r5c88bcbc3a09-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id598">1</a>, <a class="fn-backref" href="#id601">2</a>)</em> Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id602">
<h3>remove_similar_vertices<a class="headerlink" href="#id602" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.remove_similar_vertices">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">remove_similar_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.remove_similar_vertices" title="Permalink to this definition"></a></dt>
<dd><p>Remove vertices that are less than <cite>theta</cite> degrees from any other</p>
<p>Returns vertices that are at least theta degrees from any other vertex.
Vertex v and -v are considered the same so if v and -v are both in
<cite>vertices</cite> only one is kept. Also if v and w are both in vertices, w must
be separated by theta degrees from both v and -v to be unique.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 3) ndarray</span></dt>
<dd><p class="first last">N unit vectors.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum separation between vertices in degrees.</p>
</dd>
<dt><strong>return_mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{False, True}, optional</span></dt>
<dd><p class="first last">If True, return <cite>mapping</cite> as well as <cite>vertices</cite> and maybe <cite>indices</cite>
(see below).</p>
</dd>
<dt><strong>return_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{False, True}, optional</span></dt>
<dd><p class="first last">If True, return <cite>indices</cite> as well as <cite>vertices</cite> and maybe <cite>mapping</cite>
(see below).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>unique_vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, 3) ndarray</span></dt>
<dd><p class="first last">Vertices sufficiently separated from one another.</p>
</dd>
<dt><strong>mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last">For each element <code class="docutils literal notranslate"><span class="pre">vertices[i]</span></code> (<span class="math notranslate nohighlight">\(i \in 0..N-1\)</span>), the index <span class="math notranslate nohighlight">\(j\)</span> to a
vertex in <cite>unique_vertices</cite> that is less than <cite>theta</cite> degrees from
<code class="docutils literal notranslate"><span class="pre">vertices[i]</span></code>.  Only returned if <cite>return_mapping</cite> is True.</p>
</dd>
<dt><strong>indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray</span></dt>
<dd><p class="first last"><cite>indices</cite> gives the reverse of <cite>mapping</cite>.  For each element
<code class="docutils literal notranslate"><span class="pre">unique_vertices[j]</span></code> (<span class="math notranslate nohighlight">\(j \in 0..M-1\)</span>), the index <span class="math notranslate nohighlight">\(i\)</span> to a vertex in
<cite>vertices</cite> that is less than <cite>theta</cite> degrees from
<code class="docutils literal notranslate"><span class="pre">unique_vertices[j]</span></code>.  If there is more than one element of
<cite>vertices</cite> that is less than theta degrees from <cite>unique_vertices[j]</cite>,
return the first (lowest index) matching value.  Only return if
<cite>return_indices</cite> is True.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="reshape-peaks-for-visualization">
<h3>reshape_peaks_for_visualization<a class="headerlink" href="#reshape-peaks-for-visualization" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.reshape_peaks_for_visualization">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">reshape_peaks_for_visualization</code><span class="sig-paren">(</span><em>peaks</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.reshape_peaks_for_visualization" title="Permalink to this definition"></a></dt>
<dd><p>Reshape peaks for visualization.</p>
<p>Reshape and convert to float32 a set of peaks for visualisation with mrtrix
or the fibernavigator.</p>
</dd></dl>

</div>
<div class="section" id="search-descending">
<h3>search_descending<a class="headerlink" href="#search-descending" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.search_descending">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">search_descending</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.search_descending" title="Permalink to this definition"></a></dt>
<dd><p><cite>i</cite> in descending array <cite>a</cite> so <cite>a[i] &lt; a[0] * relative_threshold</cite></p>
<p>Call <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">a[0]</span> <span class="pre">*</span> <span class="pre">relative_threshold</span></code>. Return value <cite>i</cite> will be the
smallest index in the descending array <cite>a</cite> such that <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;</span> <span class="pre">T</span></code>.
Equivalently, <cite>i</cite> will be the largest index such that <code class="docutils literal notranslate"><span class="pre">all(a[:i]</span> <span class="pre">&gt;=</span> <span class="pre">T)</span></code>.
If all values in <cite>a</cite> are &gt;= T, return the length of array <cite>a</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, ndim=1, c-contiguous</span></dt>
<dd><p class="first last">Array to be searched.  We assume <cite>a</cite> is in descending order.</p>
</dd>
<dt><strong>relative_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Applied threshold will be <code class="docutils literal notranslate"><span class="pre">T</span></code> with <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">a[0]</span> <span class="pre">*</span> <span class="pre">relative_threshold</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.intp</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">a[0]</span> <span class="pre">*</span> <span class="pre">relative_threshold</span></code> then <cite>i</cite> will be the largest index
such that <code class="docutils literal notranslate"><span class="pre">all(a[:i]</span> <span class="pre">&gt;=</span> <span class="pre">T)</span></code>.  If all values in <cite>a</cite> are &gt;= T then
<cite>i</cite> will be <cite>len(a)</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 10.,   9.,   8.,   7.,   6.,   5.,   4.,   3.,   2.,   1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_descending</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="mf">0.5</span>
<span class="go">array([False, False, False, False, False, False,  True,  True,  True,  True], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_descending</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_descending</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_descending</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sh-to-sf-matrix">
<h3>sh_to_sf_matrix<a class="headerlink" href="#sh-to-sf-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.sh_to_sf_matrix">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">sh_to_sf_matrix</code><span class="sig-paren">(</span><em>sphere</em>, <em>sh_order</em>, <em>basis_type=None</em>, <em>return_inv=True</em>, <em>smooth=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.sh_to_sf_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Matrix that transforms Spherical harmonics (SH) to spherical
function (SF).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The points on which to sample the spherical function.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients (default 4).</p>
</dd>
<dt><strong>basis_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, tournier07, descoteaux07}</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="reference internal" href="#r32ff341be5fc-2" id="id603">[2]</a> basis, and
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="reference internal" href="#r32ff341be5fc-1" id="id604">[1]</a> basis
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>return_inv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True then the inverse of the matrix is also returned</p>
</dd>
<dt><strong>smooth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Lambda-regularization in the SH fit (default 0.0).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Matrix that transforms spherical harmonics to spherical function
<code class="docutils literal notranslate"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></code>.</p>
</dd>
<dt><strong>invB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Inverse of B.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r32ff341be5fc-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id604">1</a>, <a class="fn-backref" href="#id605">2</a>)</em> Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r32ff341be5fc-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id603">1</a>, <a class="fn-backref" href="#id606">2</a>)</em> Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id607">
<h3>warn<a class="headerlink" href="#id607" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.peaks.warn">
<code class="descclassname">dipy.reconst.peaks.</code><code class="descname">warn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.peaks.warn" title="Permalink to this definition"></a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
<div class="section" id="id608">
<h3><a class="reference internal" href="#dipy.reconst.qtdmri.Cache" title="dipy.reconst.qtdmri.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#id608" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.qtdmri.Cache">
<em class="property">class </em><code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">Cache</code><a class="headerlink" href="#dipy.reconst.qtdmri.Cache" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.Cache.cache_clear" title="dipy.reconst.qtdmri.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.Cache.cache_get" title="dipy.reconst.qtdmri.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.Cache.cache_set" title="dipy.reconst.qtdmri.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.qtdmri.Cache.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.Cache.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.Cache.cache_clear">
<code class="descname">cache_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.Cache.cache_clear" title="Permalink to this definition"></a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.Cache.cache_get">
<code class="descname">cache_get</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.Cache.cache_get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.Cache.cache_set">
<code class="descname">cache_set</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.Cache.cache_set" title="Permalink to this definition"></a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="qtdmrifit">
<h3><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit" title="dipy.reconst.qtdmri.QtdmriFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriFit</span></code></a><a class="headerlink" href="#qtdmrifit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.qtdmri.QtdmriFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">QtdmriFit</code><span class="sig-paren">(</span><em>model</em>, <em>qtdmri_coef</em>, <em>us</em>, <em>ut</em>, <em>tau_scaling</em>, <em>R</em>, <em>lopt</em>, <em>alpha</em>, <em>cvxpy_solution_optimal</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.fitted_signal" title="dipy.reconst.qtdmri.QtdmriFit.fitted_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fitted_signal</span></code></a>([gtab])</td>
<td>Recovers the fitted signal for the given gradient table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.msd" title="dipy.reconst.qtdmri.QtdmriFit.msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd</span></code></a>(tau)</td>
<td>Calculates the analytical Mean Squared Displacement (MSD) for a given diffusion time tau.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal" title="dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm_of_laplacian_signal</span></code></a>()</td>
<td>Calculates the norm of the laplacian of the fitted signal [Re930b800cbc4-1].</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.odf" title="dipy.reconst.qtdmri.QtdmriFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere,&nbsp;tau[,&nbsp;s])</td>
<td>Calculates the analytical Orientation Distribution Function (ODF) for a given diffusion time tau from the signal, <a class="reference internal" href="#re8a94af3adb8-1" id="id610">[1]</a> Eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.odf_sh" title="dipy.reconst.qtdmri.QtdmriFit.odf_sh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sh</span></code></a>(tau[,&nbsp;s])</td>
<td>Calculates the real analytical odf for a given discrete sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.pdf" title="dipy.reconst.qtdmri.QtdmriFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>(rt_points)</td>
<td>Diffusion propagator on a given set of real points.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.predict" title="dipy.reconst.qtdmri.QtdmriFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(qvals_or_gtab[,&nbsp;S0])</td>
<td>Recovers the reconstructed signal for any qvalue array or gradient table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.qiv" title="dipy.reconst.qtdmri.QtdmriFit.qiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qiv</span></code></a>(tau)</td>
<td>Calculates the analytical Q-space Inverse Variance (QIV) for given diffusion time tau.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef" title="dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qtdmri_to_mapmri_coef</span></code></a>(tau)</td>
<td>This function converts the qtdmri coefficients to mapmri coefficients for a given tau <a class="reference internal" href="#rbeb00b0728f1-1" id="id611">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.rtap" title="dipy.reconst.qtdmri.QtdmriFit.rtap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtap</span></code></a>(tau)</td>
<td>Calculates the analytical return to the axis probability (RTAP) for a given diffusion time tau, <a class="reference internal" href="#rb426f7ff6c1f-1" id="id612">[1]</a> eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.rtop" title="dipy.reconst.qtdmri.QtdmriFit.rtop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop</span></code></a>(tau)</td>
<td>Calculates the analytical return to the origin probability (RTOP) for a given diffusion time tau <a class="reference internal" href="#rae9ef6a2072f-1" id="id613">[1]</a> eq.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.rtpp" title="dipy.reconst.qtdmri.QtdmriFit.rtpp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtpp</span></code></a>(tau)</td>
<td>Calculates the analytical return to the plane probability (RTPP) for a given diffusion time tau, <a class="reference internal" href="#r0ef534f1e9fc-1" id="id614">[1]</a> eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_abs" title="dipy.reconst.qtdmri.QtdmriFit.sparsity_abs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparsity_abs</span></code></a>([threshold])</td>
<td>As a measure of sparsity, calculates the number of largest coefficients needed to absolute sum up to 99% of the total absolute sum of all coefficients</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_density" title="dipy.reconst.qtdmri.QtdmriFit.sparsity_density"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparsity_density</span></code></a>([threshold])</td>
<td>As a measure of sparsity, calculates the number of largest coefficients needed to squared sum up to 99% of the total squared sum of all coefficients</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>qtdmri_coef</em>, <em>us</em>, <em>ut</em>, <em>tau_scaling</em>, <em>R</em>, <em>lopt</em>, <em>alpha</em>, <em>cvxpy_solution_optimal</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Calculates diffusion properties for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">AnalyticalModel</p>
</dd>
<dt><strong>qtdmri_coef</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">qtdmri coefficients</p>
</dd>
<dt><strong>us</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, 3 x 1</span></dt>
<dd><p class="first last">spatial scaling factors</p>
</dd>
<dt><strong>ut</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">temporal scaling factor</p>
</dd>
<dt><strong>tau_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">the temporal scaling that used to scale tau to the size of us</p>
</dd>
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3x3 numpy array,</span></dt>
<dd><p class="first last">tensor eigenvectors</p>
</dd>
<dt><strong>lopt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">laplacian regularization weight</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">the l1 regularization weight</p>
</dd>
<dt><strong>cvxpy_solution_optimal: bool,</strong></dt>
<dd><p class="first last">indicates whether the cvxpy coefficient estimation reach an optimal
solution</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.fitted_signal">
<code class="descname">fitted_signal</code><span class="sig-paren">(</span><em>gtab=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.fitted_signal" title="Permalink to this definition"></a></dt>
<dd><p>Recovers the fitted signal for the given gradient table. If no gradient
table is given it recovers the signal for the gtab of the model object.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.msd">
<code class="descname">msd</code><span class="sig-paren">(</span><em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.msd" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical Mean Squared Displacement (MSD) for a
given diffusion time tau. It is defined as the Laplacian of the origin
of the estimated signal <a class="reference internal" href="#r9ee09c2d0d0c-1" id="id615">[1]</a>. The analytical formula for the MAP-MRI
basis was derived in [R9ee09c2d0d0c-2] eq. (C13, D1). The qtdmri coefficients are
first converted to mapmri coefficients following [3].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r9ee09c2d0d0c-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id615">1</a>, <a class="fn-backref" href="#id617">2</a>)</em> Cheng, J., 2014. Estimation and Processing of Ensemble Average
Propagator and Its Features in Diffusion MRI. Ph.D. Thesis.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r9ee09c2d0d0c-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id619">[3]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal">
<code class="descname">norm_of_laplacian_signal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the norm of the laplacian of the fitted signal [Re930b800cbc4-1].
This information could be useful to assess if the extrapolation of the
fitted signal contains spurious oscillations. A high laplacian norm may
indicate that these are present, and any q-space indices that
use integrals of the signal may be corrupted (e.g. RTOP, RTAP, RTPP,
QIV). In contrast to [1], the Laplacian now describes oscillations in
the 4-dimensional qt-signal [2].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re930b800cbc4-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id622">[2]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em>, <em>tau</em>, <em>s=2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical Orientation Distribution Function (ODF)
for a given diffusion time tau from the signal, <a class="reference internal" href="#re8a94af3adb8-1" id="id623">[1]</a> Eq. (32). The
qtdmri coefficients are first converted to mapmri coefficients
following [2].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dipy sphere object</span></dt>
<dd><p class="first last">sphere object with vertice orientations to compute the ODF on.</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">radial moment of the ODF</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re8a94af3adb8-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id610">1</a>, <a class="fn-backref" href="#id623">2</a>, <a class="fn-backref" href="#id624">3</a>)</em> Ozarslan E. et. al, Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="re8a94af3adb8-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id625">[2]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.odf_sh">
<code class="descname">odf_sh</code><span class="sig-paren">(</span><em>tau</em>, <em>s=2</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.odf_sh" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the real analytical odf for a given discrete sphere.
Computes the design matrix of the ODF for the given sphere vertices
and radial moment <a class="reference internal" href="#r0a1decd741db-1" id="id626">[1]</a> eq. (32). The radial moment s acts as a
sharpening method. The analytical equation for the spherical ODF basis
is given in [R0a1decd741db-2] eq. (C8). The qtdmri coefficients are first converted
to mapmri coefficients following [3].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">radial moment of the ODF</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r0a1decd741db-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id626">1</a>, <a class="fn-backref" href="#id628">2</a>)</em> Ozarslan E. et. al, Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r0a1decd741db-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id630">[3]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.pdf">
<code class="descname">pdf</code><span class="sig-paren">(</span><em>rt_points</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.pdf" title="Permalink to this definition"></a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>qvals_or_gtab</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Recovers the reconstructed signal for any qvalue array or
gradient table.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.qiv">
<code class="descname">qiv</code><span class="sig-paren">(</span><em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.qiv" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical Q-space Inverse Variance (QIV) for given
diffusion time tau.
It is defined as the inverse of the Laplacian of the origin of the
estimated propagator <a class="reference internal" href="#r1e32c9d7d6dc-1" id="id631">[1]</a> eq. (22). The analytical formula for the
MAP-MRI basis was derived in [R1e32c9d7d6dc-2] eq. (C14, D2). The qtdmri
coefficients are first converted to mapmri coefficients following [3].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1e32c9d7d6dc-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id631">1</a>, <a class="fn-backref" href="#id633">2</a>)</em> Hosseinbor et al. Bessel fourier orientation reconstruction
(bfor): An analytical diffusion propagator reconstruction for
hybrid diffusion imaging and computation of q-space indices.
NeuroImage 64, 2013, 650670.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r1e32c9d7d6dc-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id635">[3]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef">
<code class="descname">qtdmri_to_mapmri_coef</code><span class="sig-paren">(</span><em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef" title="Permalink to this definition"></a></dt>
<dd><p>This function converts the qtdmri coefficients to mapmri
coefficients for a given tau <a class="reference internal" href="#rbeb00b0728f1-1" id="id636">[1]</a>. The conversion is performed by a
matrix multiplication that evaluates the time-depenent part of the
basis and multiplies it with the coefficients, after which coefficients
with the same spatial orders are summed up, resulting in mapmri
coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rbeb00b0728f1-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id611">1</a>, <a class="fn-backref" href="#id636">2</a>, <a class="fn-backref" href="#id637">3</a>)</em> Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.rtap">
<code class="descname">rtap</code><span class="sig-paren">(</span><em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.rtap" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical return to the axis probability (RTAP)
for a given diffusion time tau, <a class="reference internal" href="#rb426f7ff6c1f-1" id="id638">[1]</a> eq. (40, 44a). The analytical
formula for the isotropic MAP-MRI basis was derived in [Rb426f7ff6c1f-2] eq. (C11).
The qtdmri coefficients are first converted to mapmri coefficients
following [3].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb426f7ff6c1f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id612">1</a>, <a class="fn-backref" href="#id638">2</a>, <a class="fn-backref" href="#id640">3</a>)</em> Ozarslan E. et. al, Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rb426f7ff6c1f-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id642">[3]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.rtop">
<code class="descname">rtop</code><span class="sig-paren">(</span><em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.rtop" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical return to the origin probability (RTOP)
for a given diffusion time tau <a class="reference internal" href="#rae9ef6a2072f-1" id="id643">[1]</a> eq. (36, 43). The analytical
formula for the isotropic MAP-MRI basis was derived in [Rae9ef6a2072f-2] eq. (C11).
The qtdmri coefficients are first converted to mapmri coefficients
following [3].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rae9ef6a2072f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id613">1</a>, <a class="fn-backref" href="#id643">2</a>, <a class="fn-backref" href="#id645">3</a>)</em> Ozarslan E. et. al, Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rae9ef6a2072f-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id647">[3]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.rtpp">
<code class="descname">rtpp</code><span class="sig-paren">(</span><em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.rtpp" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical return to the plane probability (RTPP)
for a given diffusion time tau, <a class="reference internal" href="#r0ef534f1e9fc-1" id="id648">[1]</a> eq. (42). The analytical formula
for the isotropic MAP-MRI basis was derived in [R0ef534f1e9fc-2] eq. (C11). The
qtdmri coefficients are first converted to mapmri coefficients
following [3].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r0ef534f1e9fc-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id614">1</a>, <a class="fn-backref" href="#id648">2</a>, <a class="fn-backref" href="#id650">3</a>)</em> Ozarslan E. et. al, Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r0ef534f1e9fc-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id652">[3]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.sparsity_abs">
<code class="descname">sparsity_abs</code><span class="sig-paren">(</span><em>threshold=0.99</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_abs" title="Permalink to this definition"></a></dt>
<dd><p>As a measure of sparsity, calculates the number of largest
coefficients needed to absolute sum up to 99% of the total absolute sum
of all coefficients</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriFit.sparsity_density">
<code class="descname">sparsity_density</code><span class="sig-paren">(</span><em>threshold=0.99</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriFit.sparsity_density" title="Permalink to this definition"></a></dt>
<dd><p>As a measure of sparsity, calculates the number of largest
coefficients needed to squared sum up to 99% of the total squared sum
of all coefficients</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="qtdmrimodel">
<h3><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriModel" title="dipy.reconst.qtdmri.QtdmriModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QtdmriModel</span></code></a><a class="headerlink" href="#qtdmrimodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.qtdmri.QtdmriModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">QtdmriModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>radial_order=6</em>, <em>time_order=2</em>, <em>laplacian_regularization=False</em>, <em>laplacian_weighting=0.2</em>, <em>l1_regularization=False</em>, <em>l1_weighting=0.1</em>, <em>cartesian=True</em>, <em>anisotropic_scaling=True</em>, <em>normalization=False</em>, <em>constrain_q0=True</em>, <em>bval_threshold=10000000000.0</em>, <em>eigenvalue_threshold=0.0001</em>, <em>cvxpy_solver='ECOS'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.cache.Cache</span></code></a></p>
<p>The q:math:<cite>tau</cite>-dMRI model [1] to analytically and continuously represent
the q:math:<cite>tau</cite> diffusion signal attenuation over diffusion sensitization
q and diffusion time <span class="math notranslate nohighlight">\(\tau\)</span>. The model can be seen as an extension of
the MAP-MRI basis [2] towards different diffusion times.</p>
<p>The main idea is to model the diffusion signal over time and space as
a linear combination of continuous functions,</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">hat{E}(textbf{q},tau;textbf{c}) =
sum_i^{N_{textbf{q}}}sum_k^{<a href="#id781"><span class="problematic" id="id782">N_</span></a>tau} textbf{c}_{ik}
,Phi_i(textbf{q}),T_k(tau),</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\Phi\)</span> and <span class="math notranslate nohighlight">\(T\)</span> are the spatial and temporal basis funcions,
<span class="math notranslate nohighlight">\(N_{\textbf{q}}\)</span> and <span class="math notranslate nohighlight">\(N_\tau\)</span> are the maximum spatial and temporal
order, and <span class="math notranslate nohighlight">\(i,k\)</span> are basis order iterators.</p>
<p>The estimation of the coefficients <span class="math notranslate nohighlight">\(c_i\)</span> can be regularized using
either analytic Laplacian regularization, sparsity regularization using
the l1-norm, or both to do a type of elastic net regularization.</p>
<p>From the coefficients, there exists an analytical formula to estimate
the ODF, RTOP, RTAP, RTPP, QIV and MSD, for any diffusion time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable,</span></dt>
<dd><p class="first last">gradient directions and bvalues container class. The bvalues
should be in the normal s/mm^2. big_delta and small_delta need to
given in seconds.</p>
</dd>
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer representing the spatial/radial order of the basis.</p>
</dd>
<dt><strong>time_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an integer larger or equal than zero representing the time order
of the basis.</p>
</dd>
<dt><strong>laplacian_regularization</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool,</span></dt>
<dd><p class="first last">Regularize using the Laplacian of the qt-dMRI basis.</p>
</dd>
<dt><strong>laplacian_weighting: string or scalar,</strong></dt>
<dd><p class="first last">The string GCV makes it use generalized cross-validation to find
the regularization weight [3]. A scalar sets the regularization
weight to that value.</p>
</dd>
<dt><strong>l1_regularization</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool,</span></dt>
<dd><p class="first last">Regularize by imposing sparsity in the coefficients using the
l1-norm.</p>
</dd>
<dt><strong>l1_weighting</strong> <span class="classifier-delimiter">:</span> <span class="classifier">CV or scalar,</span></dt>
<dd><p class="first last">The string CV makes it use five-fold cross-validation to find
the regularization weight. A scalar sets the regularization weight
to that value.</p>
</dd>
<dt><strong>cartesian</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to use the Cartesian or spherical implementation of the
qt-dMRI basis, which we first explored in [4].</p>
</dd>
<dt><strong>anisotropic_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to use anisotropic scaling or isotropic scaling. This
option can be used to test if the Cartesian implementation is
equivalent with the spherical one when using the same scaling.</p>
</dd>
<dt><strong>normalization</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to normalize the basis functions such that their inner
product is equal to one. Normalization is only necessary when
imposing sparsity in the spherical basis if cartesian=False.</p>
</dd>
<dt><strong>constrain_q0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">whether to constrain the q0 point to unity along the tau-space.
This is necessary to ensure that <span class="math notranslate nohighlight">\(E(0,\tau)=1\)</span>.</p>
</dd>
<dt><strong>bval_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the threshold b-value to be used, such that only data points below
that threshold are used when estimating the scale factors.</p>
</dd>
<dt><strong>eigenvalue_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Sets the minimum of the tensor eigenvalues in order to avoid
stability problem.</p>
</dd>
<dt><strong>cvxpy_solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">cvxpy solver name. Optionally optimize the positivity constraint
with a particular cvxpy solver. See See <a class="reference external" href="http://www.cvxpy.org/">http://www.cvxpy.org/</a> for
details. Default: ECOS.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r6dee8b26f150-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id653">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6dee8b26f150-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id654">[2]</a></td><td>Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6dee8b26f150-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id655">[3]</a></td><td>Craven et al. Smoothing Noisy Data with Spline Functions.
NUMER MATH 31.4 (1978): 377-403.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6dee8b26f150-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id656">[4]</a></td><td>Fick, Rutger HJ, et al. A unifying framework for spatial and
temporal diffusion in diffusion mri. International Conference on
Information Processing in Medical Imaging. Springer, Cham, 2015.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.qtdmri.QtdmriModel.fit" title="dipy.reconst.qtdmri.QtdmriModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>radial_order=6</em>, <em>time_order=2</em>, <em>laplacian_regularization=False</em>, <em>laplacian_weighting=0.2</em>, <em>l1_regularization=False</em>, <em>l1_weighting=0.1</em>, <em>cartesian=True</em>, <em>anisotropic_scaling=True</em>, <em>normalization=False</em>, <em>constrain_q0=True</em>, <em>bval_threshold=10000000000.0</em>, <em>eigenvalue_threshold=0.0001</em>, <em>cvxpy_solver='ECOS'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.qtdmri.QtdmriModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.QtdmriModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id657">
<h3>GCV_cost_function<a class="headerlink" href="#id657" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.GCV_cost_function">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">GCV_cost_function</code><span class="sig-paren">(</span><em>weight</em>, <em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.GCV_cost_function" title="Permalink to this definition"></a></dt>
<dd><p>Generalized Cross Validation Function that is iterated [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r288c54af3b44-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id658">[1]</a></td><td>Craven et al. Smoothing Noisy Data with Spline Functions.
NUMER MATH 31.4 (1978): 377-403.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="h">
<h3>H<a class="headerlink" href="#h" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.H">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">H</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.H" title="Permalink to this definition"></a></dt>
<dd><p>Step function of H(x)=1 if x&gt;=0 and zero otherwise. Used for the
temporal laplacian matrix.</p>
</dd></dl>

</div>
<div class="section" id="angular-basis-eap-opt">
<h3>angular_basis_EAP_opt<a class="headerlink" href="#angular-basis-eap-opt" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.angular_basis_EAP_opt">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">angular_basis_EAP_opt</code><span class="sig-paren">(</span><em>j</em>, <em>l</em>, <em>m</em>, <em>r</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.angular_basis_EAP_opt" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="angular-basis-opt">
<h3>angular_basis_opt<a class="headerlink" href="#angular-basis-opt" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.angular_basis_opt">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">angular_basis_opt</code><span class="sig-paren">(</span><em>l</em>, <em>m</em>, <em>q</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.angular_basis_opt" title="Permalink to this definition"></a></dt>
<dd><p>Angular basis independent of spatial scaling factor us. Though it
includes q, it is independent of the data and can be precomputed.</p>
</dd></dl>

</div>
<div class="section" id="id659">
<h3>cart2sphere<a class="headerlink" href="#id659" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.cart2sphere">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">cart2sphere</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.cart2sphere" title="Permalink to this definition"></a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions and derivation
of the formulae.</p>
<p><span class="math notranslate nohighlight">\(0\le\theta\mathrm{(theta)}\le\pi\)</span> and <span class="math notranslate nohighlight">\(-\pi\le\phi\mathrm{(phi)}\le\pi\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">x coordinate in Cartesian space</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">z coordinate</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">radius</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">inclination (polar) angle</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">azimuth angle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-rt-space-grid">
<h3>create_rt_space_grid<a class="headerlink" href="#create-rt-space-grid" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.create_rt_space_grid">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">create_rt_space_grid</code><span class="sig-paren">(</span><em>grid_size_r</em>, <em>max_radius_r</em>, <em>grid_size_tau</em>, <em>min_radius_tau</em>, <em>max_radius_tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.create_rt_space_grid" title="Permalink to this definition"></a></dt>
<dd><p>Generates EAP grid (for potential positivity constraint).</p>
</dd></dl>

</div>
<div class="section" id="design-matrix-spatial">
<h3>design_matrix_spatial<a class="headerlink" href="#design-matrix-spatial" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.design_matrix_spatial">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">design_matrix_spatial</code><span class="sig-paren">(</span><em>bvecs</em>, <em>qvals</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.design_matrix_spatial" title="Permalink to this definition"></a></dt>
<dd><p>Constructs design matrix for DTI weighted least squares or
least squares fitting. (Basser et al., 1994a)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N x 3)</span></dt>
<dd><p class="first last">unit b-vectors of the acquisition.</p>
</dd>
<dt><strong>qvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N,)</span></dt>
<dd><p class="first last">corresponding q-values in 1/mm</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>design_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (g,7)</span></dt>
<dd><p class="first last">Design matrix or B matrix assuming Gaussian distributed tensor model
design_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="elastic-crossvalidation">
<h3>elastic_crossvalidation<a class="headerlink" href="#elastic-crossvalidation" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.elastic_crossvalidation">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">elastic_crossvalidation</code><span class="sig-paren">(</span><em>b0s_mask</em>, <em>E</em>, <em>M</em>, <em>L</em>, <em>lopt</em>, <em>weight_array=array([0.</em>, <em>0.01</em>, <em>0.02</em>, <em>0.03</em>, <em>0.04</em>, <em>0.05</em>, <em>0.06</em>, <em>0.07</em>, <em>0.08</em>, <em>0.09</em>, <em>0.1</em>, <em>0.11</em>, <em>0.12</em>, <em>0.13</em>, <em>0.14</em>, <em>0.15</em>, <em>0.16</em>, <em>0.17</em>, <em>0.18</em>, <em>0.19</em>, <em>0.2 ])</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.elastic_crossvalidation" title="Permalink to this definition"></a></dt>
<dd><p>cross-validation function to find the optimal weight of alpha for
sparsity regularization when also Laplacian regularization is used.</p>
</dd></dl>

</div>
<div class="section" id="factorial">
<h3>factorial<a class="headerlink" href="#factorial" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.factorial">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">factorial</code><span class="sig-paren">(</span><em>n</em>, <em>exact=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.factorial" title="Permalink to this definition"></a></dt>
<dd><p>The factorial of a number or array of numbers.</p>
<p>The factorial of non-negative integer <cite>n</cite> is the product of all
positive integers less than or equal to <cite>n</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>n! = n * (n - 1) * (n - 2) * ... * 1
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array_like of ints</span></dt>
<dd><p class="first last">Input values.  If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, the return value is 0.</p>
</dd>
<dt><strong>exact</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, calculate the answer exactly using long integer arithmetic.
If False, result is approximated in floating point rapidly using the
<cite>gamma</cite> function.
Default is False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or int or ndarray</span></dt>
<dd><p class="first last">Factorial of <cite>n</cite>, as integer or float depending on <cite>exact</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For arrays with <code class="docutils literal notranslate"><span class="pre">exact=True</span></code>, the factorial is computed only once, for
the largest input, with each other result computed in the process.
The output dtype is increased to <code class="docutils literal notranslate"><span class="pre">int64</span></code> or <code class="docutils literal notranslate"><span class="pre">object</span></code> if necessary.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">exact=False</span></code> the factorial is approximated using the gamma
function:</p>
<div class="math notranslate nohighlight">
\[n! = \Gamma(n+1)\]</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">factorial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([   6.,   24.,  120.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([  6,  24, 120])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">120L</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id660">
<h3>factorial2<a class="headerlink" href="#id660" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.factorial2">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">factorial2</code><span class="sig-paren">(</span><em>n</em>, <em>exact=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.factorial2" title="Permalink to this definition"></a></dt>
<dd><p>Double factorial.</p>
<p>This is the factorial with every second value skipped.  E.g., <code class="docutils literal notranslate"><span class="pre">7!!</span> <span class="pre">=</span> <span class="pre">7</span> <span class="pre">*</span> <span class="pre">5</span>
<span class="pre">*</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">1</span></code>.  It can be approximated numerically as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd
    = 2**(n/2) * (n/2)!                           n even
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array_like</span></dt>
<dd><p class="first last">Calculate <code class="docutils literal notranslate"><span class="pre">n!!</span></code>.  Arrays are only supported with <cite>exact</cite> set
to False.  If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, the return value is 0.</p>
</dd>
<dt><strong>exact</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">The result can be approximated rapidly using the gamma-formula
above (default).  If <cite>exact</cite> is set to True, calculate the
answer exactly using integer arithmetic.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span></dt>
<dd><p class="first last">Double factorial of <cite>n</cite>, as an int or a float depending on
<cite>exact</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">factorial2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial2</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array(105.00000000000001)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial2</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">105L</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="fmin-l-bfgs-b">
<h3>fmin_l_bfgs_b<a class="headerlink" href="#fmin-l-bfgs-b" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.fmin_l_bfgs_b">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">fmin_l_bfgs_b</code><span class="sig-paren">(</span><em>func</em>, <em>x0</em>, <em>fprime=None</em>, <em>args=()</em>, <em>approx_grad=0</em>, <em>bounds=None</em>, <em>m=10</em>, <em>factr=10000000.0</em>, <em>pgtol=1e-05</em>, <em>epsilon=1e-08</em>, <em>iprint=-1</em>, <em>maxfun=15000</em>, <em>maxiter=15000</em>, <em>disp=None</em>, <em>callback=None</em>, <em>maxls=20</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.fmin_l_bfgs_b" title="Permalink to this definition"></a></dt>
<dd><p>Minimize a function func using the L-BFGS-B algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable f(x,*args)</span></dt>
<dd><p class="first last">Function to minimise.</p>
</dd>
<dt><strong>x0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Initial guess.</p>
</dd>
<dt><strong>fprime</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable fprime(x,*args), optional</span></dt>
<dd><p class="first last">The gradient of <cite>func</cite>.  If None, then <cite>func</cite> returns the function
value and the gradient (<code class="docutils literal notranslate"><span class="pre">f,</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">func(x,</span> <span class="pre">*args)</span></code>), unless
<cite>approx_grad</cite> is True in which case <cite>func</cite> returns only <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd><p class="first last">Arguments to pass to <cite>func</cite> and <cite>fprime</cite>.</p>
</dd>
<dt><strong>approx_grad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to approximate the gradient numerically (in which case
<cite>func</cite> returns only the function value).</p>
</dd>
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining
the bounds on that parameter. Use None or +-inf for one of <code class="docutils literal notranslate"><span class="pre">min</span></code> or
<code class="docutils literal notranslate"><span class="pre">max</span></code> when there is no bound in that direction.</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The maximum number of variable metric corrections
used to define the limited memory matrix. (The limited memory BFGS
method does not store the full hessian but uses this many terms in an
approximation to it.)</p>
</dd>
<dt><strong>factr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">The iteration stops when
<code class="docutils literal notranslate"><span class="pre">(f^k</span> <span class="pre">-</span> <span class="pre">f^{k+1})/max{|f^k|,|f^{k+1}|,1}</span> <span class="pre">&lt;=</span> <span class="pre">factr</span> <span class="pre">*</span> <span class="pre">eps</span></code>,
where <code class="docutils literal notranslate"><span class="pre">eps</span></code> is the machine precision, which is automatically
generated by the code. Typical values for <cite>factr</cite> are: 1e12 for
low accuracy; 1e7 for moderate accuracy; 10.0 for extremely
high accuracy. See Notes for relationship to <cite>ftol</cite>, which is exposed
(instead of <cite>factr</cite>) by the <cite>scipy.optimize.minimize</cite> interface to
L-BFGS-B.</p>
</dd>
<dt><strong>pgtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">The iteration will stop when
<code class="docutils literal notranslate"><span class="pre">max{|proj</span> <span class="pre">g_i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">n}</span> <span class="pre">&lt;=</span> <span class="pre">pgtol</span></code>
where <code class="docutils literal notranslate"><span class="pre">pg_i</span></code> is the i-th component of the projected gradient.</p>
</dd>
<dt><strong>epsilon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Step size used when <cite>approx_grad</cite> is True, for numerically
calculating the gradient</p>
</dd>
<dt><strong>iprint</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Controls the frequency of output. <code class="docutils literal notranslate"><span class="pre">iprint</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> means no output;
<code class="docutils literal notranslate"><span class="pre">iprint</span> <span class="pre">=</span> <span class="pre">0</span></code>    print only one line at the last iteration;
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">iprint</span> <span class="pre">&lt;</span> <span class="pre">99</span></code> print also f and <code class="docutils literal notranslate"><span class="pre">|proj</span> <span class="pre">g|</span></code> every iprint iterations;
<code class="docutils literal notranslate"><span class="pre">iprint</span> <span class="pre">=</span> <span class="pre">99</span></code>   print details of every iteration except n-vectors;
<code class="docutils literal notranslate"><span class="pre">iprint</span> <span class="pre">=</span> <span class="pre">100</span></code>  print also the changes of active set and final x;
<code class="docutils literal notranslate"><span class="pre">iprint</span> <span class="pre">&gt;</span> <span class="pre">100</span></code>  print details of every iteration including x and g.</p>
</dd>
<dt><strong>disp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">If zero, then no output.  If a positive number, then this over-rides
<cite>iprint</cite> (i.e., <cite>iprint</cite> gets the value of <cite>disp</cite>).</p>
</dd>
<dt><strong>maxfun</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum number of function evaluations.</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum number of iterations.</p>
</dd>
<dt><strong>callback</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd><p class="first last">Called after each iteration, as <code class="docutils literal notranslate"><span class="pre">callback(xk)</span></code>, where <code class="docutils literal notranslate"><span class="pre">xk</span></code> is the
current parameter vector.</p>
</dd>
<dt><strong>maxls</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum number of line search steps (per iteration). Default is 20.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Estimated position of the minimum.</p>
</dd>
<dt><strong>f</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Value of <cite>func</cite> at the minimum.</p>
</dd>
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">Information dictionary.</p>
<ul class="last simple">
<li>d[warnflag] is<ul>
<li>0 if converged,</li>
<li>1 if too many function evaluations or too many iterations,</li>
<li>2 if stopped for another reason, given in d[task]</li>
</ul>
</li>
<li>d[grad] is the gradient at the minimum (should be 0 ish)</li>
<li>d[funcalls] is the number of function calls made.</li>
<li>d[nit] is the number of iterations.</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize</span></code></dt>
<dd>Interface to minimization algorithms for multivariate functions. See the L-BFGS-B <cite>method</cite> in particular. Note that the <cite>ftol</cite> option is made available via that interface, while <cite>factr</cite> is provided via this interface, where <cite>factr</cite> is the factor multiplying the default machine floating-point precision to arrive at <cite>ftol</cite>: <code class="docutils literal notranslate"><span class="pre">ftol</span> <span class="pre">=</span> <span class="pre">factr</span> <span class="pre">*</span> <span class="pre">numpy.finfo(float).eps</span></code>.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>License of L-BFGS-B (FORTRAN code):</p>
<p>The version included here (in fortran code) is 3.0
(released April 25, 2011).  It was written by Ciyou Zhu, Richard Byrd,
and Jorge Nocedal &lt;<a class="reference external" href="mailto:nocedal&#37;&#52;&#48;ece&#46;nwu&#46;edu">nocedal<span>&#64;</span>ece<span>&#46;</span>nwu<span>&#46;</span>edu</a>&gt;. It carries the following
condition for use:</p>
<p>This software is freely available, but we expect that all publications
describing work using this software, or all commercial products using it,
quote at least one of the references given below. This software is released
under the BSD License.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound
Constrained Optimization, (1995), SIAM Journal on Scientific and
Statistical Computing, 16, 5, pp. 1190-1208.</li>
<li>C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B,
FORTRAN routines for large scale bound constrained optimization (1997),
ACM Transactions on Mathematical Software, 23, 4, pp. 550 - 560.</li>
<li>J.L. Morales and J. Nocedal. L-BFGS-B: Remark on Algorithm 778: L-BFGS-B,
FORTRAN routines for large scale bound constrained optimization (2011),
ACM Transactions on Mathematical Software, 38, 1.</li>
</ul>
</dd></dl>

</div>
<div class="section" id="id661">
<h3>generalized_crossvalidation<a class="headerlink" href="#id661" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.generalized_crossvalidation">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">generalized_crossvalidation</code><span class="sig-paren">(</span><em>data</em>, <em>M</em>, <em>LR</em>, <em>startpoint=0.0005</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.generalized_crossvalidation" title="Permalink to this definition"></a></dt>
<dd><p>Generalized Cross Validation Function [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2320c3f97d4d-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id662">[1]</a></td><td>Craven et al. Smoothing Noisy Data with Spline Functions.
NUMER MATH 31.4 (1978): 377-403.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id663">
<h3>genlaguerre<a class="headerlink" href="#id663" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.genlaguerre">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">genlaguerre</code><span class="sig-paren">(</span><em>n</em>, <em>alpha</em>, <em>monic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.genlaguerre" title="Permalink to this definition"></a></dt>
<dd><p>Generalized (associated) Laguerre polynomial.</p>
<p>Defined to be the solution of</p>
<div class="math notranslate nohighlight">
\[x\frac{d^2}{dx^2}L_n^{(\alpha)}
  + (\alpha + 1 - x)\frac{d}{dx}L_n^{(\alpha)}
  + nL_n^{(\alpha)} = 0,\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha &gt; -1\)</span>; <span class="math notranslate nohighlight">\(L_n^{(\alpha)}\)</span> is a polynomial
of degree <span class="math notranslate nohighlight">\(n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Degree of the polynomial.</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Parameter, must be greater than -1.</p>
</dd>
<dt><strong>monic</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If <cite>True</cite>, scale the leading coefficient to be 1. Default is
<cite>False</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">orthopoly1d</span></dt>
<dd><p class="first last">Generalized Laguerre polynomial.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">laguerre</span></code></dt>
<dd>Laguerre polynomial.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For fixed <span class="math notranslate nohighlight">\(\alpha\)</span>, the polynomials <span class="math notranslate nohighlight">\(L_n^{(\alpha)}\)</span>
are orthogonal over <span class="math notranslate nohighlight">\([0, \infty)\)</span> with weight function
<span class="math notranslate nohighlight">\(e^{-x}x^\alpha\)</span>.</p>
<p>The Laguerre polynomials are the special case where <span class="math notranslate nohighlight">\(\alpha
= 0\)</span>.</p>
</dd></dl>

</div>
<div class="section" id="gradient-table-from-gradient-strength-bvecs">
<h3>gradient_table_from_gradient_strength_bvecs<a class="headerlink" href="#gradient-table-from-gradient-strength-bvecs" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.gradient_table_from_gradient_strength_bvecs">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">gradient_table_from_gradient_strength_bvecs</code><span class="sig-paren">(</span><em>gradient_strength</em>, <em>bvecs</em>, <em>big_delta</em>, <em>small_delta</em>, <em>b0_threshold=50</em>, <em>atol=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.gradient_table_from_gradient_strength_bvecs" title="Permalink to this definition"></a></dt>
<dd><p>A general function for creating diffusion MR gradients.</p>
<p>It reads, loads and prepares scanner parameters like the b-values and
b-vectors so that they can be useful during the reconstruction process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gradient_strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">an array of shape (N,),</span></dt>
<dd><p class="first last">gradient strength given in T/mm</p>
</dd>
<dt><strong>bvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">can be any of two options</span></dt>
<dd><ol class="first last arabic simple">
<li>an array of shape (N, 3) or (3, N) with the b-vectors.</li>
<li>a path for the file which contains an array like the previous.</li>
</ol>
</dd>
<dt><strong>big_delta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array of shape (N,)</span></dt>
<dd><p class="first last">acquisition pulse separation time in seconds</p>
</dd>
<dt><strong>small_delta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">acquisition pulse duration time in seconds</p>
</dd>
<dt><strong>b0_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">All b-values with values less than or equal to <cite>bo_threshold</cite> are
considered as b0s i.e. without diffusion weighting.</p>
</dd>
<dt><strong>atol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">All b-vectors need to be unit vectors up to a tolerance.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gradients</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd><p class="first last">A GradientTable with all the gradient information.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li>Often b0s (b-values which correspond to images without diffusion
weighting) have 0 values however in some cases the scanner cannot
provide b0s of an exact 0 value and it gives a bit higher values
e.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</li>
<li>We assume that the minimum number of b-values is 7.</li>
<li>B-vectors should be unit vectors.</li>
</ol>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.core.gradients</span> <span class="k">import</span> <span class="p">(</span>
<span class="gp">... </span>   <span class="n">gradient_table_from_gradient_strength_bvecs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient_strength</span> <span class="o">=</span> <span class="o">.</span><span class="mf">03e-3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>  <span class="c1"># clinical strength at 30 mT/m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big_delta</span> <span class="o">=</span> <span class="o">.</span><span class="mi">03</span>  <span class="c1"># pulse separation of 30ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_delta</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># pulse duration of 10ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient_strength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sq2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="n">sq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sq2</span><span class="p">,</span> <span class="n">sq2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span> <span class="o">=</span> <span class="n">gradient_table_from_gradient_strength_bvecs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">gradient_strength</span><span class="p">,</span> <span class="n">bvecs</span><span class="p">,</span> <span class="n">big_delta</span><span class="p">,</span> <span class="n">small_delta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="l1-crossvalidation">
<h3>l1_crossvalidation<a class="headerlink" href="#l1-crossvalidation" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.l1_crossvalidation">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">l1_crossvalidation</code><span class="sig-paren">(</span><em>b0s_mask</em>, <em>E</em>, <em>M</em>, <em>weight_array=array([0.</em>, <em>0.02</em>, <em>0.04</em>, <em>0.06</em>, <em>0.08</em>, <em>0.1</em>, <em>0.12</em>, <em>0.14</em>, <em>0.16</em>, <em>0.18</em>, <em>0.2</em>, <em>0.22</em>, <em>0.24</em>, <em>0.26</em>, <em>0.28</em>, <em>0.3</em>, <em>0.32</em>, <em>0.34</em>, <em>0.36</em>, <em>0.38</em>, <em>0.4 ])</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.l1_crossvalidation" title="Permalink to this definition"></a></dt>
<dd><p>cross-validation function to find the optimal weight of alpha for
sparsity regularization</p>
</dd></dl>

</div>
<div class="section" id="id664">
<h3>multi_voxel_fit<a class="headerlink" href="#id664" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.multi_voxel_fit">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="id665">
<h3>optional_package<a class="headerlink" href="#id665" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.optional_package">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">optional_package</code><span class="sig-paren">(</span><em>name</em>, <em>trip_msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.optional_package" title="Permalink to this definition"></a></dt>
<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">package name</p>
</dd>
<dt><strong>trip_msg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or str</span></dt>
<dd><p class="first last">message to give when someone tries to use the return package, but we
could not import it, and have returned a TripWire object instead.
Default message if None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pkg_like</strong> <span class="classifier-delimiter">:</span> <span class="classifier">module or <code class="docutils literal notranslate"><span class="pre">TripWire</span></code> instance</span></dt>
<dd><p class="first last">If we can import the package, return it.  Otherwise return an object
raising an error when accessed</p>
</dd>
<dt><strong>have_pkg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if import for package was successful, false otherwise</p>
</dd>
<dt><strong>module_setup</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">callable usually set as <code class="docutils literal notranslate"><span class="pre">setup_module</span></code> in calling namespace, to allow
skipping tests.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="part1-reg-matrix-tau">
<h3>part1_reg_matrix_tau<a class="headerlink" href="#part1-reg-matrix-tau" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.part1_reg_matrix_tau">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">part1_reg_matrix_tau</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>ut</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part1_reg_matrix_tau" title="Permalink to this definition"></a></dt>
<dd><p>Partial temporal Laplacian regularization matrix following
Appendix B in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r8e68d0fd6501-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id666">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="part23-iso-reg-matrix-q">
<h3>part23_iso_reg_matrix_q<a class="headerlink" href="#part23-iso-reg-matrix-q" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.part23_iso_reg_matrix_q">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">part23_iso_reg_matrix_q</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>us</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part23_iso_reg_matrix_q" title="Permalink to this definition"></a></dt>
<dd><p>Partial spherical spatial Laplacian regularization matrix following the
equation below Eq. (C4) in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r5e69c004448e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id667">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="part23-reg-matrix-q">
<h3>part23_reg_matrix_q<a class="headerlink" href="#part23-reg-matrix-q" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.part23_reg_matrix_q">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">part23_reg_matrix_q</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>U_mat</em>, <em>T_mat</em>, <em>us</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part23_reg_matrix_q" title="Permalink to this definition"></a></dt>
<dd><p>Partial cartesian spatial Laplacian regularization matrix following
second line of Eq. (B2) in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r3f2cd4a23cf5-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id668">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="part23-reg-matrix-tau">
<h3>part23_reg_matrix_tau<a class="headerlink" href="#part23-reg-matrix-tau" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.part23_reg_matrix_tau">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">part23_reg_matrix_tau</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>ut</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part23_reg_matrix_tau" title="Permalink to this definition"></a></dt>
<dd><p>Partial temporal Laplacian regularization matrix following
Appendix B in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd02c9fab0299-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id669">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="part4-iso-reg-matrix-q">
<h3>part4_iso_reg_matrix_q<a class="headerlink" href="#part4-iso-reg-matrix-q" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.part4_iso_reg_matrix_q">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">part4_iso_reg_matrix_q</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>us</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part4_iso_reg_matrix_q" title="Permalink to this definition"></a></dt>
<dd><p>Partial spherical spatial Laplacian regularization matrix following the
equation below Eq. (C4) in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r14eeb60c3baf-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id670">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="part4-reg-matrix-q">
<h3>part4_reg_matrix_q<a class="headerlink" href="#part4-reg-matrix-q" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.part4_reg_matrix_q">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">part4_reg_matrix_q</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>U_mat</em>, <em>us</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part4_reg_matrix_q" title="Permalink to this definition"></a></dt>
<dd><p>Partial cartesian spatial Laplacian regularization matrix following
equation Eq. (B2) in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd6bc6528afc6-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id671">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="part4-reg-matrix-tau">
<h3>part4_reg_matrix_tau<a class="headerlink" href="#part4-reg-matrix-tau" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.part4_reg_matrix_tau">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">part4_reg_matrix_tau</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>ut</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.part4_reg_matrix_tau" title="Permalink to this definition"></a></dt>
<dd><p>Partial temporal Laplacian regularization matrix following
Appendix B in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="ra481a087fd3c-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id672">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="qtdmri-anisotropic-scaling">
<h3>qtdmri_anisotropic_scaling<a class="headerlink" href="#qtdmri-anisotropic-scaling" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_anisotropic_scaling">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_anisotropic_scaling</code><span class="sig-paren">(</span><em>data</em>, <em>q</em>, <em>bvecs</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Constructs design matrix for fitting an exponential to the
diffusion time points.</p>
</dd></dl>

</div>
<div class="section" id="qtdmri-eap-matrix">
<h3>qtdmri_eap_matrix<a class="headerlink" href="#qtdmri-eap-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_eap_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_eap_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>us</em>, <em>ut</em>, <em>grid</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the design matrix as a product of 3 separated radial,
angular and temporal design matrices. It precomputes the relevant basis
orders for each one and finally puts them together according to the index
matrix</p>
</dd></dl>

</div>
<div class="section" id="id673">
<h3><a href="#id783"><span class="problematic" id="id784">qtdmri_eap_matrix_</span></a><a class="headerlink" href="#id673" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_eap_matrix_">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_eap_matrix_</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>us</em>, <em>ut</em>, <em>grid</em>, <em>normalization=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_eap_matrix_" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="qtdmri-index-matrix">
<h3>qtdmri_index_matrix<a class="headerlink" href="#qtdmri-index-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_index_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_index_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_index_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Computes the SHORE basis order indices according to [1].</p>
</dd></dl>

</div>
<div class="section" id="qtdmri-isotropic-eap-matrix">
<h3>qtdmri_isotropic_eap_matrix<a class="headerlink" href="#qtdmri-isotropic-eap-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_isotropic_eap_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>us</em>, <em>ut</em>, <em>grid</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the design matrix as a product of 3 separated radial,
angular and temporal design matrices. It precomputes the relevant basis
orders for each one and finally puts them together according to the index
matrix</p>
</dd></dl>

</div>
<div class="section" id="id674">
<h3><a href="#id785"><span class="problematic" id="id786">qtdmri_isotropic_eap_matrix_</span></a><a class="headerlink" href="#id674" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_isotropic_eap_matrix_</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>us</em>, <em>ut</em>, <em>grid</em>, <em>normalization=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="qtdmri-isotropic-index-matrix">
<h3>qtdmri_isotropic_index_matrix<a class="headerlink" href="#qtdmri-isotropic-index-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_isotropic_index_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Computes the SHORE basis order indices according to [1].</p>
</dd></dl>

</div>
<div class="section" id="qtdmri-isotropic-laplacian-reg-matrix">
<h3>qtdmri_isotropic_laplacian_reg_matrix<a class="headerlink" href="#qtdmri-isotropic-laplacian-reg-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_isotropic_laplacian_reg_matrix</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>us</em>, <em>ut</em>, <em>part1_uq_iso_precomp=None</em>, <em>part1_ut_precomp=None</em>, <em>part23_ut_precomp=None</em>, <em>part4_ut_precomp=None</em>, <em>normalization=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Computes the spherical qt-dMRI Laplacian regularization matrix. If
given, uses precomputed matrices for temporal and spatial regularization
matrices to speed up computation. Follows the the formulation of Appendix C
in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r191ed4b20871-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id675">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="qtdmri-isotropic-scaling">
<h3>qtdmri_isotropic_scaling<a class="headerlink" href="#qtdmri-isotropic-scaling" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_isotropic_scaling">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_isotropic_scaling</code><span class="sig-paren">(</span><em>data</em>, <em>q</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Constructs design matrix for fitting an exponential to the
diffusion time points.</p>
</dd></dl>

</div>
<div class="section" id="qtdmri-isotropic-signal-matrix">
<h3>qtdmri_isotropic_signal_matrix<a class="headerlink" href="#qtdmri-isotropic-signal-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_isotropic_signal_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>us</em>, <em>ut</em>, <em>q</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id676">
<h3><a href="#id787"><span class="problematic" id="id788">qtdmri_isotropic_signal_matrix_</span></a><a class="headerlink" href="#id676" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_isotropic_signal_matrix_</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>us</em>, <em>ut</em>, <em>q</em>, <em>tau</em>, <em>normalization=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="qtdmri-isotropic-to-mapmri-matrix">
<h3>qtdmri_isotropic_to_mapmri_matrix<a class="headerlink" href="#qtdmri-isotropic-to-mapmri-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_isotropic_to_mapmri_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>ut</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Generates the matrix that maps the spherical qtdmri coefficients to
MAP-MRI coefficients. The conversion is done by only evaluating the time
basis for a diffusion time tau and summing up coefficients with the same
spatial basis orders [1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer representing the spatial/radial order of the basis.</p>
</dd>
<dt><strong>time_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an integer larger or equal than zero representing the time order
of the basis.</p>
</dd>
<dt><strong>ut</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">temporal scaling factor</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="ra63fed2caebe-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id677">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="qtdmri-laplacian-reg-matrix">
<h3>qtdmri_laplacian_reg_matrix<a class="headerlink" href="#qtdmri-laplacian-reg-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_laplacian_reg_matrix</code><span class="sig-paren">(</span><em>ind_mat</em>, <em>us</em>, <em>ut</em>, <em>S_mat=None</em>, <em>T_mat=None</em>, <em>U_mat=None</em>, <em>part1_ut_precomp=None</em>, <em>part23_ut_precomp=None</em>, <em>part4_ut_precomp=None</em>, <em>normalization=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Computes the cartesian qt-dMRI Laplacian regularization matrix. If
given, uses precomputed matrices for temporal and spatial regularization
matrices to speed up computation. Follows the the formulation of Appendix B
in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r74810f43fcd2-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id678">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="qtdmri-mapmri-isotropic-normalization">
<h3>qtdmri_mapmri_isotropic_normalization<a class="headerlink" href="#qtdmri-mapmri-isotropic-normalization" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_mapmri_isotropic_normalization</code><span class="sig-paren">(</span><em>j</em>, <em>l</em>, <em>u0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization" title="Permalink to this definition"></a></dt>
<dd><p>Normalization factor for Spherical MAP-MRI basis. The normalization
for a basis function with orders [j,l,m] depends only on orders j,l and
the isotropic scale factor.</p>
</dd></dl>

</div>
<div class="section" id="qtdmri-mapmri-normalization">
<h3>qtdmri_mapmri_normalization<a class="headerlink" href="#qtdmri-mapmri-normalization" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_mapmri_normalization">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_mapmri_normalization</code><span class="sig-paren">(</span><em>mu</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_mapmri_normalization" title="Permalink to this definition"></a></dt>
<dd><p>Normalization factor for Cartesian MAP-MRI basis. The scaling is the
same for every basis function depending only on the spatial scaling
mu.</p>
</dd></dl>

</div>
<div class="section" id="qtdmri-number-of-coefficients">
<h3>qtdmri_number_of_coefficients<a class="headerlink" href="#qtdmri-number-of-coefficients" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_number_of_coefficients">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_number_of_coefficients</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_number_of_coefficients" title="Permalink to this definition"></a></dt>
<dd><p>Computes the total number of coefficients of the qtdmri basis given a
radial and temporal order. Equation given below Eq (9) in [1].</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rcf42999df2c0-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id679">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="qtdmri-signal-matrix">
<h3>qtdmri_signal_matrix<a class="headerlink" href="#qtdmri-signal-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_signal_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_signal_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>us</em>, <em>ut</em>, <em>q</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the design matrix as a product of 3 separated radial,
angular and temporal design matrices. It precomputes the relevant basis
orders for each one and finally puts them together according to the index
matrix</p>
</dd></dl>

</div>
<div class="section" id="id680">
<h3><a href="#id789"><span class="problematic" id="id790">qtdmri_signal_matrix_</span></a><a class="headerlink" href="#id680" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_signal_matrix_">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_signal_matrix_</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>us</em>, <em>ut</em>, <em>q</em>, <em>tau</em>, <em>normalization=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_signal_matrix_" title="Permalink to this definition"></a></dt>
<dd><p>Function to generate the qtdmri signal basis.</p>
</dd></dl>

</div>
<div class="section" id="qtdmri-temporal-normalization">
<h3>qtdmri_temporal_normalization<a class="headerlink" href="#qtdmri-temporal-normalization" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_temporal_normalization">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_temporal_normalization</code><span class="sig-paren">(</span><em>ut</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_temporal_normalization" title="Permalink to this definition"></a></dt>
<dd><p>Normalization factor for the temporal basis</p>
</dd></dl>

</div>
<div class="section" id="qtdmri-to-mapmri-matrix">
<h3>qtdmri_to_mapmri_matrix<a class="headerlink" href="#qtdmri-to-mapmri-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">qtdmri_to_mapmri_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>time_order</em>, <em>ut</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Generates the matrix that maps the qtdmri coefficients to MAP-MRI
coefficients. The conversion is done by only evaluating the time basis for
a diffusion time tau and summing up coefficients with the same spatial
basis orders [1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer representing the spatial/radial order of the basis.</p>
</dd>
<dt><strong>time_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an integer larger or equal than zero representing the time order
of the basis.</p>
</dd>
<dt><strong>ut</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">temporal scaling factor</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">diffusion time (big_delta - small_delta / 3.) in seconds</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r9f26e60b820f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id681">[1]</a></td><td>Fick, Rutger HJ, et al. Non-Parametric GraphNet-Regularized
Representation of dMRI in Space and Time, Medical Image Analysis,
2017.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="radial-basis-eap-opt">
<h3>radial_basis_EAP_opt<a class="headerlink" href="#radial-basis-eap-opt" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.radial_basis_EAP_opt">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">radial_basis_EAP_opt</code><span class="sig-paren">(</span><em>j</em>, <em>l</em>, <em>us</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.radial_basis_EAP_opt" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="radial-basis-opt">
<h3>radial_basis_opt<a class="headerlink" href="#radial-basis-opt" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.radial_basis_opt">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">radial_basis_opt</code><span class="sig-paren">(</span><em>j</em>, <em>l</em>, <em>us</em>, <em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.radial_basis_opt" title="Permalink to this definition"></a></dt>
<dd><p>Spatial basis dependent on spatial scaling factor us</p>
</dd></dl>

</div>
<div class="section" id="id682">
<h3>real_sph_harm<a class="headerlink" href="#id682" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.real_sph_harm">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">real_sph_harm</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.real_sph_harm" title="Permalink to this definition"></a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>Where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:</p>
<blockquote>
<div>Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
<span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code></span></dt>
<dd><p class="first last">The order of the harmonic.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt>
<dd><p class="first last">The degree of the harmonic.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">real float</span></dt>
<dd><p class="first last">The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.special.sph_harm</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="temporal-basis">
<h3>temporal_basis<a class="headerlink" href="#temporal-basis" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.temporal_basis">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">temporal_basis</code><span class="sig-paren">(</span><em>o</em>, <em>ut</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.temporal_basis" title="Permalink to this definition"></a></dt>
<dd><p>Temporal basis dependent on temporal scaling factor ut</p>
</dd></dl>

</div>
<div class="section" id="visualise-gradient-table-g-delta-rainbow">
<h3>visualise_gradient_table_G_Delta_rainbow<a class="headerlink" href="#visualise-gradient-table-g-delta-rainbow" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">visualise_gradient_table_G_Delta_rainbow</code><span class="sig-paren">(</span><em>gtab</em>, <em>big_delta_start=None</em>, <em>big_delta_end=None</em>, <em>G_start=None</em>, <em>G_end=None</em>, <em>bval_isolines=array([    0</em>, <em>250</em>, <em>1000</em>, <em>2500</em>, <em>5000</em>, <em>7500</em>, <em>10000</em>, <em>14000])</em>, <em>alpha_shading=0.6</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow" title="Permalink to this definition"></a></dt>
<dd><p>This function visualizes a q-tau acquisition scheme as a function of
gradient strength and pulse separation (big_delta). It represents every
measurements at its G and big_delta position regardless of b-vector, with a
background of b-value isolines for reference. It assumes there is only one
unique pulse length (small_delta) in the acquisition scheme.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable object</span></dt>
<dd><p class="first last">constructed gradient table with big_delta and small_delta given as
inputs.</p>
</dd>
<dt><strong>big_delta_start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">optional minimum big_delta that is plotted in seconds</p>
</dd>
<dt><strong>big_delta_end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">optional maximum big_delta that is plotted in seconds</p>
</dd>
<dt><strong>G_start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">optional minimum gradient strength that is plotted in T/m</p>
</dd>
<dt><strong>G_end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">optional maximum gradient strength taht is plotted in T/m</p>
</dd>
<dt><strong>bval_isolines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array,</span></dt>
<dd><p class="first last">optional array of bvalue isolines that are plotted in the background</p>
</dd>
<dt><strong>alpha_shading</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float between [0-1]</span></dt>
<dd><p class="first last">optional shading of the bvalue colors in the background</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id683">
<h3>warn<a class="headerlink" href="#id683" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.qtdmri.warn">
<code class="descclassname">dipy.reconst.qtdmri.</code><code class="descname">warn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.qtdmri.warn" title="Permalink to this definition"></a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
<div class="section" id="id684">
<h3><a class="reference internal" href="#dipy.reconst.sfm.Cache" title="dipy.reconst.sfm.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#id684" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.Cache">
<em class="property">class </em><code class="descclassname">dipy.reconst.sfm.</code><code class="descname">Cache</code><a class="headerlink" href="#dipy.reconst.sfm.Cache" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.Cache.cache_clear" title="dipy.reconst.sfm.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.Cache.cache_get" title="dipy.reconst.sfm.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.Cache.cache_set" title="dipy.reconst.sfm.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.Cache.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.Cache.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.Cache.cache_clear">
<code class="descname">cache_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.Cache.cache_clear" title="Permalink to this definition"></a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.Cache.cache_get">
<code class="descname">cache_get</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.Cache.cache_get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.Cache.cache_set">
<code class="descname">cache_set</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.Cache.cache_set" title="Permalink to this definition"></a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exponentialisotropicfit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="dipy.reconst.sfm.ExponentialIsotropicFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicFit</span></code></a><a class="headerlink" href="#exponentialisotropicfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.ExponentialIsotropicFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.sfm.</code><code class="descname">ExponentialIsotropicFit</code><span class="sig-paren">(</span><em>model</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.sfm.IsotropicFit</span></code></a></p>
<p>A fit to the ExponentialIsotropicModel object, based on data.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicFit.predict" title="dipy.reconst.sfm.ExponentialIsotropicFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>([gtab])</td>
<td>Predict the isotropic signal, based on a gradient table.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.ExponentialIsotropicFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize an IsotropicFit object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">IsotropicModel class instance</span></dt>
<dd></dd>
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The mean isotropic model parameters (the mean diffusion-weighted
signal in each voxel).</p>
</dd>
<dt><strong>n_vox</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of voxels for which the fit was done.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.ExponentialIsotropicFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the isotropic signal, based on a gradient table. In this case,
the prediction will be for an exponential decay with the mean
diffusivity derived from the data that was fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance (optional)</span></dt>
<dd><p class="first last">Defaults to use the gtab from the IsotropicModel from which this
fit was derived.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exponentialisotropicmodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="dipy.reconst.sfm.ExponentialIsotropicModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialIsotropicModel</span></code></a><a class="headerlink" href="#exponentialisotropicmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.ExponentialIsotropicModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.sfm.</code><code class="descname">ExponentialIsotropicModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.sfm.IsotropicModel</span></code></a></p>
<p>Representing the isotropic signal as a fit to an exponential decay function
with b-values</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.ExponentialIsotropicModel.fit" title="dipy.reconst.sfm.ExponentialIsotropicModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.ExponentialIsotropicModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize an IsotropicModel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.ExponentialIsotropicModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ExponentialIsotropicModel.fit" title="Permalink to this definition"></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ExponentialIsotropicFit class instance.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="isotropicfit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit" title="dipy.reconst.sfm.IsotropicFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicFit</span></code></a><a class="headerlink" href="#isotropicfit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.IsotropicFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.sfm.</code><code class="descname">IsotropicFit</code><span class="sig-paren">(</span><em>model</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstFit</span></code></a></p>
<p>A fit object for representing the isotropic signal as the mean of the
diffusion-weighted signal.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.IsotropicFit.predict" title="dipy.reconst.sfm.IsotropicFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>([gtab])</td>
<td>Predict the isotropic signal.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.IsotropicFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize an IsotropicFit object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">IsotropicModel class instance</span></dt>
<dd></dd>
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The mean isotropic model parameters (the mean diffusion-weighted
signal in each voxel).</p>
</dd>
<dt><strong>n_vox</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of voxels for which the fit was done.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.IsotropicFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the isotropic signal.</p>
<p>Based on a gradient table. In this case, the (naive!) prediction will
be the mean of the diffusion-weighted signal in the voxels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance (optional)</span></dt>
<dd><p class="first last">Defaults to use the gtab from the IsotropicModel from which this
fit was derived.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="isotropicmodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel" title="dipy.reconst.sfm.IsotropicModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicModel</span></code></a><a class="headerlink" href="#isotropicmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.IsotropicModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.sfm.</code><code class="descname">IsotropicModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>A base-class for the representation of isotropic signals.</p>
<p>The default behavior, suitable for single b-value data is to calculate the
mean in each voxel as an estimate of the signal that does not depend on
direction.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.IsotropicModel.fit" title="dipy.reconst.sfm.IsotropicModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data)</td>
<td>Fit an IsotropicModel.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.IsotropicModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize an IsotropicModel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.IsotropicModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.IsotropicModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit an IsotropicModel.</p>
<p>This boils down to finding the mean diffusion-weighted signal in each
voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>IsotropicFit class instance.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id685">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ReconstFit" title="dipy.reconst.sfm.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstFit</span></code></a><a class="headerlink" href="#id685" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.ReconstFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.sfm.</code><code class="descname">ReconstFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ReconstFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class which holds the fit result of ReconstModel</p>
<p>For example that could be holding FA or GFA etc.</p>
<dl class="method">
<dt id="dipy.reconst.sfm.ReconstFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ReconstFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id686">
<h3><a class="reference internal" href="#dipy.reconst.sfm.ReconstModel" title="dipy.reconst.sfm.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReconstModel</span></code></a><a class="headerlink" href="#id686" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.ReconstModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.sfm.</code><code class="descname">ReconstModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ReconstModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for signal reconstruction models</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.ReconstModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ReconstModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.ReconstModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.ReconstModel.fit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="sparsefasciclefit">
<h3><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit" title="dipy.reconst.sfm.SparseFascicleFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleFit</span></code></a><a class="headerlink" href="#sparsefasciclefit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.SparseFascicleFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.sfm.</code><code class="descname">SparseFascicleFit</code><span class="sig-paren">(</span><em>model</em>, <em>beta</em>, <em>S0</em>, <em>iso</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstFit</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit.odf" title="dipy.reconst.sfm.SparseFascicleFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>The orientation distribution function of the SFM</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleFit.predict" title="dipy.reconst.sfm.SparseFascicleFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>([gtab,&nbsp;response,&nbsp;S0])</td>
<td>Predict the signal based on the SFM parameters</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>beta</em>, <em>S0</em>, <em>iso</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initalize a SparseFascicleFit class instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a SparseFascicleModel object.</span></dt>
<dd></dd>
<dt><strong>beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The parameters of fit to data.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The mean non-diffusion-weighted signal.</p>
</dd>
<dt><strong>iso</strong> <span class="classifier-delimiter">:</span> <span class="classifier">IsotropicFit class instance</span></dt>
<dd><p class="first last">A representation of the isotropic signal, together with parameters
of the isotropic signal in each voxel, that is capable of
deriving/predicting an isotropic signal, based on a gradient-table.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>The orientation distribution function of the SFM</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The points in which the ODF is evaluated</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>odf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (x, y, z, sphere.vertices.shape[0])</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab=None</em>, <em>response=None</em>, <em>S0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the signal based on the SFM parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable, optional</span></dt>
<dd><p class="first last">The bvecs/bvals to predict the signal on. Default: the gtab from
the model object.</p>
</dd>
<dt><strong>response</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of 3 elements, optional</span></dt>
<dd><p class="first last">The eigenvalues of a tensor which will serve as a kernel
function. Default: the response of the model object. Default to use
<cite>model.response</cite>.</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array, optional</span></dt>
<dd><p class="first last">The non-diffusion-weighted signal. Default: use the S0 of the data</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pred_sig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The signal predicted in each voxel/direction</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sparsefasciclemodel">
<h3><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel" title="dipy.reconst.sfm.SparseFascicleModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseFascicleModel</span></code></a><a class="headerlink" href="#sparsefasciclemodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.sfm.SparseFascicleModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.sfm.</code><code class="descname">SparseFascicleModel</code><span class="sig-paren">(</span><em>gtab, sphere=None, response=[0.0015, 0.0005, 0.0005], solver='ElasticNet', l1_ratio=0.5, alpha=0.001, isotropic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.cache.Cache</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel.design_matrix" title="dipy.reconst.sfm.SparseFascicleModel.design_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">design_matrix</span></code></a>()</td>
<td>The design matrix for a SFM.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.sfm.SparseFascicleModel.fit" title="dipy.reconst.sfm.SparseFascicleModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit the SparseFascicleModel object to data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab, sphere=None, response=[0.0015, 0.0005, 0.0005], solver='ElasticNet', l1_ratio=0.5, alpha=0.001, isotropic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a Sparse Fascicle Model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere class instance, optional</span></dt>
<dd><p class="first last">A sphere on which coefficients will be estimated. Default:</p>
</dd>
<dt><strong>symmetric sphere with 362 points (from :mod:`dipy.data`).</strong></dt>
<dd></dd>
<dt><strong>response</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) array-like, optional</span></dt>
<dd><p class="first last">The eigenvalues of a canonical tensor to be used as the response
function of single-fascicle signals.
Default:[0.0015, 0.0005, 0.0005]</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, dipy.core.optimize.SKLearnLinearSolver object, or sklearn.linear_model.base.LinearModel object, optional.</span></dt>
<dd><p class="first last">This will determine the algorithm used to solve the set of linear
equations underlying this model. If it is a string it needs to be
one of the following: {ElasticNet, NNLS}. Otherwise, it can be
an object that inherits from <cite>dipy.optimize.SKLearnLinearSolver</cite>.
Default: ElasticNet.</p>
</dd>
<dt><strong>l1_ratio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Sets the balance betwee L1 and L2 regularization in ElasticNet
<a class="reference internal" href="#r3db2a282ece1-zou2005" id="id687">[Zou2005]</a>. Default: 0.5</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Sets the balance between least-squares error and L1/L2
regularization in ElasticNet <a class="reference internal" href="#r3db2a282ece1-zou2005" id="id688">[Zou2005]</a>. Default: 0.001</p>
</dd>
<dt><strong>isotropic</strong> <span class="classifier-delimiter">:</span> <span class="classifier">IsotropicModel class instance</span></dt>
<dd><p class="first last">This is a class that implements the function that calculates the
value of the isotropic signal. This is a value of the signal that is
independent of direction, and therefore removed from both sides of
the SFM equation. The default is an instance of IsotropicModel, but
other functions can be inherited from IsotropicModel to implement
other fits to the aspects of the data that depend on b-value, but
not on direction.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is an implementation of the SFM, described in <a class="reference internal" href="../examples_built/sfm_tracking.html#rokem2015" id="id689">[Rokem2015]</a>.</p>
<table class="docutils citation" frame="void" id="r3db2a282ece1-rokem2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Rokem2014]</td><td>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick
N. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell
(2014). Evaluating the accuracy of diffusion MRI models in white
matter. PLoS ONE 10(4): e0123272. doi:10.1371/journal.pone.0123272</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r3db2a282ece1-zou2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Zou2005]</td><td><em>(<a class="fn-backref" href="#id687">1</a>, <a class="fn-backref" href="#id688">2</a>)</em> Zou H, Hastie T (2005). Regularization and variable
selection via the elastic net. J R Stat Soc B:301-320</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleModel.design_matrix">
<code class="descname">design_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.design_matrix" title="Permalink to this definition"></a></dt>
<dd><p>The design matrix for a SFM.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ndarray</strong></dt>
<dd><p class="first last">The design matrix, where each column is a rotated version of the
response function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.sfm.SparseFascicleModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.SparseFascicleModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit the SparseFascicleModel object to data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The measured signal.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd><p class="first last">A boolean array used to mark the coordinates in the data that
should be analyzed. Has the shape <cite>data.shape[:-1]</cite>. Default: None,
which implies that all points should be analyzed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>SparseFascicleFit object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id690">
<h3>auto_attr<a class="headerlink" href="#id690" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.sfm.auto_attr">
<code class="descclassname">dipy.reconst.sfm.</code><code class="descname">auto_attr</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.auto_attr" title="Permalink to this definition"></a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">The method that will be called the first time to compute a value.
Afterwards, the methods name will be a standard attribute holding the
value of this computation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nanmean">
<h3>nanmean<a class="headerlink" href="#nanmean" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.sfm.nanmean">
<code class="descclassname">dipy.reconst.sfm.</code><code class="descname">nanmean</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.nanmean" title="Permalink to this definition"></a></dt>
<dd><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<p>For all-NaN slices, NaN is returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Array containing numbers whose mean is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd><p class="first last">Axis or axes along which the means are computed. The default is to compute
the mean of the flattened array.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd><p class="first last">Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for inexact inputs, it is the same as the input
dtype.</p>
</dd>
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">Alternate output array in which to place the result.  The default
is <code class="docutils literal notranslate"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
<cite>doc.ufuncs</cite> for details.</p>
</dd>
<dt><strong>keepdims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p class="last">If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>mean</cite> or <cite>sum</cite> methods
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above</span></dt>
<dd><p class="first last">If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned. Nan is
returned for slices that contain only NaNs.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">average</span></code></dt>
<dd>Weighted average</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></dt>
<dd>Arithmetic mean taken while not ignoring NaNs</dd>
</dl>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">nanvar</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The arithmetic mean is the sum of the non-NaN elements along the axis
divided by the number of non-NaN elements.</p>
<p>Note that for floating-point input, the mean is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite>.  Specifying a
higher-precision accumulator using the <cite>dtype</cite> keyword can alleviate
this issue.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.6666666666666665</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.,  3.5])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id691">
<h3>optional_package<a class="headerlink" href="#id691" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.sfm.optional_package">
<code class="descclassname">dipy.reconst.sfm.</code><code class="descname">optional_package</code><span class="sig-paren">(</span><em>name</em>, <em>trip_msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.optional_package" title="Permalink to this definition"></a></dt>
<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">package name</p>
</dd>
<dt><strong>trip_msg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or str</span></dt>
<dd><p class="first last">message to give when someone tries to use the return package, but we
could not import it, and have returned a TripWire object instead.
Default message if None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pkg_like</strong> <span class="classifier-delimiter">:</span> <span class="classifier">module or <code class="docutils literal notranslate"><span class="pre">TripWire</span></code> instance</span></dt>
<dd><p class="first last">If we can import the package, return it.  Otherwise return an object
raising an error when accessed</p>
</dd>
<dt><strong>have_pkg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if import for package was successful, false otherwise</p>
</dd>
<dt><strong>module_setup</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">callable usually set as <code class="docutils literal notranslate"><span class="pre">setup_module</span></code> in calling namespace, to allow
skipping tests.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sfm-design-matrix">
<h3>sfm_design_matrix<a class="headerlink" href="#sfm-design-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.sfm.sfm_design_matrix">
<code class="descclassname">dipy.reconst.sfm.</code><code class="descname">sfm_design_matrix</code><span class="sig-paren">(</span><em>gtab</em>, <em>sphere</em>, <em>response</em>, <em>mode='signal'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.sfm.sfm_design_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Construct the SFM design matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable or Sphere</span></dt>
<dd><p class="first last">Sets the rows of the matrix, if the mode is signal, this should be a
GradientTable. If mode is odf this should be a Sphere</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">Sets the columns of the matrix</p>
</dd>
<dt><strong>response</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of 3 elements</span></dt>
<dd><p class="first last">The eigenvalues of a tensor which will serve as a kernel
function.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {signal | odf}, optional</span></dt>
<dd><p class="first last">Choose the (default) signal for a design matrix containing predicted
signal in the measurements defined by the gradient table for putative
fascicles oriented along the vertices of the sphere. Otherwise, choose
odf for an odf convolution matrix, with values of the odf calculated
from a tensor with the provided response eigenvalues, evaluated at the
b-vectors in the gradient table, for the tensors with prinicipal
diffusion directions along the vertices of the sphere.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A design matrix that can be used for one of the following operations:
when the signal mode is used, each column contains the putative
signal in each of the bvectors of the <cite>gtab</cite> if a fascicle is oriented
in the direction encoded by the sphere vertex corresponding to this
column. This is used for deconvolution with a measured DWI signal. If
the odf mode is chosen, each column instead contains the values of
the tensor ODF for a tensor with a principal diffusion direction
corresponding to this vertex. This is used to generate odfs from the
fits of the SFM for the purpose of tracking.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<table class="docutils citation" frame="void" id="rdfd493249d4f-rokem2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Rokem2015]</td><td>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick
N. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell
(2015). Evaluating the accuracy of diffusion MRI models in white
matter. PLoS ONE 10(4): e0123272. doi:10.1371/journal.pone.0123272</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rdfd493249d4f-rokem2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id692">[Rokem2014]</a></td><td>Ariel Rokem, Kimberly L. Chan, Jason D. Yeatman, Franco
Pestilli,  Brian A. Wandell (2014). Evaluating the accuracy of diffusion
models at multiple b-values with cross-validation. ISMRM 2014.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rdfd493249d4f-behrens2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id693">[Behrens2007]</a></td><td>Behrens TEJ, Berg HJ, Jbabdi S, Rushworth MFS, Woolrich MW
(2007): Probabilistic diffusion tractography with multiple fibre
orientations: What can we gain? Neuroimage 34:144-55.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dipy.data</span> <span class="k">as</span> <span class="nn">dpd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">gtab</span> <span class="o">=</span> <span class="n">dpd</span><span class="o">.</span><span class="n">dsi_voxels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">dpd</span><span class="o">.</span><span class="n">get_sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.reconst.sfm</span> <span class="k">import</span> <span class="n">sfm_design_matrix</span>
</pre></div>
</div>
<p>A canonical tensor approximating corpus-callosum voxels <a class="reference internal" href="#rdfd493249d4f-rokem2014" id="id692">[Rokem2014]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor_matrix</span> <span class="o">=</span> <span class="n">sfm_design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="p">[</span><span class="mf">0.0015</span><span class="p">,</span> <span class="mf">0.0005</span><span class="p">,</span> <span class="mf">0.0005</span><span class="p">])</span>
</pre></div>
</div>
<p>A stick function (<a class="reference internal" href="#rdfd493249d4f-behrens2007" id="id693">[Behrens2007]</a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stick_matrix</span> <span class="o">=</span> <span class="n">sfm_design_matrix</span><span class="p">(</span><span class="n">gtab</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id694">
<h3><a class="reference internal" href="#dipy.reconst.shm.Cache" title="dipy.reconst.shm.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#id694" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.Cache">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">Cache</code><a class="headerlink" href="#dipy.reconst.shm.Cache" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.Cache.cache_clear" title="dipy.reconst.shm.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.Cache.cache_get" title="dipy.reconst.shm.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.Cache.cache_set" title="dipy.reconst.shm.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.Cache.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.Cache.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.Cache.cache_clear">
<code class="descname">cache_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.Cache.cache_clear" title="Permalink to this definition"></a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.Cache.cache_get">
<code class="descname">cache_get</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.Cache.cache_get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.Cache.cache_set">
<code class="descname">cache_set</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.Cache.cache_set" title="Permalink to this definition"></a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="csaodfmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.CsaOdfModel" title="dipy.reconst.shm.CsaOdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CsaOdfModel</span></code></a><a class="headerlink" href="#csaodfmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.CsaOdfModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">CsaOdfModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.shm.QballBaseModel</span></code></a></p>
<p>Implementation of Constant Solid Angle reconstruction method.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rbc00e9136e1b-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id695">[1]</a></td><td>Aganj, I., et al. 2009. ODF Reconstruction in Q-Ball Imaging With
Solid Angle Consideration.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data[,&nbsp;mask])</td>
<td>Fits the model to diffusion data and returns the model fit</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.CsaOdfModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_data</span></code></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.CsaOdfModel.max">
<code class="descname">max</code><em class="property"> = 0.999</em><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.max" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.CsaOdfModel.min">
<code class="descname">min</code><em class="property"> = 0.001</em><a class="headerlink" href="#dipy.reconst.shm.CsaOdfModel.min" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id696">
<h3><a class="reference internal" href="#dipy.reconst.shm.LooseVersion" title="dipy.reconst.shm.LooseVersion"><code class="xref py py-class docutils literal notranslate"><span class="pre">LooseVersion</span></code></a><a class="headerlink" href="#id696" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.LooseVersion">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">LooseVersion</code><span class="sig-paren">(</span><em>vstring=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.LooseVersion" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">distutils.version.Version</span></code></p>
<p>Version numbering for anarchists and software realists.
Implements the standard interface for version number classes as
described above.  A version number consists of a series of numbers,
separated by either periods or strings of letters.  When comparing
version numbers, the numeric components will be compared
numerically, and the alphabetic components lexically.  The following
are all valid version numbers, in no particular order:</p>
<blockquote>
<div>1.5.1
1.5.2b2
161
3.10a
8.02
3.4j
1996.07.12
3.2.pl0
3.1.1.6
2g6
11g
0.960923
2.2beta29
1.13++
5.5.kw
2.0b1pl0</div></blockquote>
<p>In fact, there is no such thing as an invalid version number under
this scheme; the rules for comparison are simple and predictable,
but may not always give the results you want (for some definition
of want).</p>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>parse</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.LooseVersion.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>vstring=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.LooseVersion.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.LooseVersion.component_re">
<code class="descname">component_re</code><em class="property"> = re.compile('(\\d+ | [a-z]+ | \\.)', re.VERBOSE)</em><a class="headerlink" href="#dipy.reconst.shm.LooseVersion.component_re" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.LooseVersion.parse">
<code class="descname">parse</code><span class="sig-paren">(</span><em>vstring</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.LooseVersion.parse" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="id697">
<h3><a class="reference internal" href="#dipy.reconst.shm.OdfFit" title="dipy.reconst.shm.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfFit</span></code></a><a class="headerlink" href="#id697" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.OdfFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">OdfFit</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OdfFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstFit" title="dipy.reconst.base.ReconstFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstFit</span></code></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.OdfFit.odf" title="dipy.reconst.shm.OdfFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>To be implemented but specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.OdfFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OdfFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.OdfFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OdfFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented but specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id698">
<h3><a class="reference internal" href="#dipy.reconst.shm.OdfModel" title="dipy.reconst.shm.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OdfModel</span></code></a><a class="headerlink" href="#id698" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.OdfModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">OdfModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OdfModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.base.ReconstModel" title="dipy.reconst.base.ReconstModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.base.ReconstModel</span></code></a></p>
<p>An abstract class to be sub-classed by specific odf models</p>
<p>All odf models should provide a fit method which may take data as its
first and only argument.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.OdfModel.fit" title="dipy.reconst.shm.OdfModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.OdfModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OdfModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.OdfModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OdfModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>To be implemented by specific odf models</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="opdtmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.OpdtModel" title="dipy.reconst.shm.OpdtModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpdtModel</span></code></a><a class="headerlink" href="#opdtmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.OpdtModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">OpdtModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OpdtModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.shm.QballBaseModel</span></code></a></p>
<p>Implementation of Orientation Probability Density Transform
reconstruction method.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r51b90ac51a5a-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id699">[1]</a></td><td>Tristan-Vega, A., et al. 2010. A new methodology for estimation of
fiber populations in white matter of the brain with Funk-Radon
transform.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r51b90ac51a5a-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id700">[2]</a></td><td>Tristan-Vega, A., et al. 2009. Estimation of fiber orientation
probability density functions in high angular resolution diffusion
imaging.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data[,&nbsp;mask])</td>
<td>Fits the model to diffusion data and returns the model fit</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.OpdtModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.OpdtModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_data</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="qballbasemodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballBaseModel</span></code></a><a class="headerlink" href="#qballbasemodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.QballBaseModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">QballBaseModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.shm.SphHarmModel</span></code></a></p>
<p>To be subclassed by Qball type models.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.QballBaseModel.fit" title="dipy.reconst.shm.QballBaseModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fits the model to diffusion data and returns the model fit</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.QballBaseModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_data</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.QballBaseModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballBaseModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fits the model to diffusion data and returns the model fit</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="qballmodel">
<h3><a class="reference internal" href="#dipy.reconst.shm.QballModel" title="dipy.reconst.shm.QballModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">QballModel</span></code></a><a class="headerlink" href="#qballmodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.QballModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">QballModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.shm.QballBaseModel" title="dipy.reconst.shm.QballBaseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.shm.QballBaseModel</span></code></a></p>
<p>Implementation of regularized Qball reconstruction method.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="ra7cb3e95affa-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id701">[1]</a></td><td>Descoteaux, M., et al. 2007. Regularized, fast, and robust
analytical Q-ball imaging.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data[,&nbsp;mask])</td>
<td>Fits the model to diffusion data and returns the model fit</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.QballModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>sh_order</em>, <em>smooth=0.006</em>, <em>min_signal=1.0</em>, <em>assume_normed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.QballModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates a model that can be used to fit or sample diffusion data</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.normalize_data" title="dipy.reconst.shm.normalize_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_data</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="residualbootstrapwrapper">
<h3><a class="reference internal" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="dipy.reconst.shm.ResidualBootstrapWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResidualBootstrapWrapper</span></code></a><a class="headerlink" href="#residualbootstrapwrapper" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.ResidualBootstrapWrapper">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">ResidualBootstrapWrapper</code><span class="sig-paren">(</span><em>signal_object</em>, <em>B</em>, <em>where_dwi</em>, <em>min_signal=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.ResidualBootstrapWrapper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Returns a residual bootstrap sample of the signal_object when indexed</p>
<p>Wraps a signal_object, this signal object can be an interpolator. When
indexed, the the wrapper indexes the signal_object to get the signal.
There wrapper than samples the residual boostrap distribution of signal and
returns that sample.</p>
<dl class="method">
<dt id="dipy.reconst.shm.ResidualBootstrapWrapper.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>signal_object</em>, <em>B</em>, <em>where_dwi</em>, <em>min_signal=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.ResidualBootstrapWrapper.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Builds a ResidualBootstrapWapper</p>
<p>Given some linear model described by B, the design matrix, and a
signal_object, returns an object which can sample the residual
bootstrap distribution of the signal. We assume that the signals are
normalized so we clip the bootsrap samples to be between <cite>min_signal</cite>
and 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>signal_object</strong> <span class="classifier-delimiter">:</span> <span class="classifier">some object that can be indexed</span></dt>
<dd><p class="first last">This object should return diffusion weighted signals when indexed.</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, ndim=2</span></dt>
<dd><p class="first last">The design matrix of the spherical harmonics model used to fit the
data. This is the model that will be used to compute the residuals
and sample the residual bootstrap distribution</p>
</dd>
<dt><strong>where_dwi :</strong></dt>
<dd><p class="first last">indexing object to find diffusion weighted signals from signal</p>
</dd>
<dt><strong>min_signal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The lowest allowable signal.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id702">
<h3><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit" title="dipy.reconst.shm.SphHarmFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmFit</span></code></a><a class="headerlink" href="#id702" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.SphHarmFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">SphHarmFit</code><span class="sig-paren">(</span><em>model</em>, <em>shm_coef</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfFit" title="dipy.reconst.odf.OdfFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfFit</span></code></a></p>
<p>Diffusion data fit to a spherical harmonic model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit.shm_coeff" title="dipy.reconst.shm.SphHarmFit.shm_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm_coeff</span></code></a></dt>
<dd><p class="first last">The spherical harmonic coefficients of the odf</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit.odf" title="dipy.reconst.shm.SphHarmFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>Samples the odf function on the points of a sphere</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmFit.predict" title="dipy.reconst.shm.SphHarmFit.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>([gtab,&nbsp;S0])</td>
<td>Predict the diffusion signal from the model coefficients.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>gfa</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.SphHarmFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>shm_coef</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.SphHarmFit.gfa">
<code class="descname">gfa</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.gfa" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.SphHarmFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>Samples the odf function on the points of a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The points on which to sample the odf.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The value of the odf on each point of <cite>sphere</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.SphHarmFit.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>gtab=None</em>, <em>S0=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the diffusion signal from the model coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a GradientTable class instance</span></dt>
<dd><p class="first last">The directions and bvalues on which prediction is desired</p>
</dd>
<dt><strong>S0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">The mean non-diffusion-weighted signal in each voxel.
Default: 1.0 in all voxels</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.SphHarmFit.shape">
<code class="descname">shape</code><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.shape" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shm.SphHarmFit.shm_coeff">
<code class="descname">shm_coeff</code><a class="headerlink" href="#dipy.reconst.shm.SphHarmFit.shm_coeff" title="Permalink to this definition"></a></dt>
<dd><p>The spherical harmonic coefficients of the odf</p>
<p>Make this a property for now, if there is a usecase for modifying
the coefficients we can add a setter or expose the coefficients more
directly</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id703">
<h3><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel" title="dipy.reconst.shm.SphHarmModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphHarmModel</span></code></a><a class="headerlink" href="#id703" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shm.SphHarmModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.shm.</code><code class="descname">SphHarmModel</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.odf.OdfModel" title="dipy.reconst.odf.OdfModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.odf.OdfModel</span></code></a>, <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.cache.Cache</span></code></a></p>
<p>To be subclassed by all models that return a SphHarmFit when fit.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(data)</td>
<td>To be implemented by specific odf models</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shm.SphHarmModel.sampling_matrix" title="dipy.reconst.shm.SphHarmModel.sampling_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sampling_matrix</span></code></a>(sphere)</td>
<td>The matrix needed to sample ODFs from coefficients of the model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shm.SphHarmModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialization of the abstract class for signal reconstruction models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable class instance</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shm.SphHarmModel.sampling_matrix">
<code class="descname">sampling_matrix</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.SphHarmModel.sampling_matrix" title="Permalink to this definition"></a></dt>
<dd><p>The matrix needed to sample ODFs from coefficients of the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">Points used to sample ODF.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sampling_matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The size of the matrix will be (N, M) where N is the number of
vertices on sphere and M is the number of coefficients needed by
the model.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="anisotropic-power">
<h3>anisotropic_power<a class="headerlink" href="#anisotropic-power" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.anisotropic_power">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">anisotropic_power</code><span class="sig-paren">(</span><em>sh_coeffs</em>, <em>norm_factor=1e-05</em>, <em>power=2</em>, <em>non_negative=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.anisotropic_power" title="Permalink to this definition"></a></dt>
<dd><p>Calculates anisotropic power map with a given SH coefficient matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh_coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><blockquote class="first">
<div><p>A ndarray where the last dimension is the
SH coefficients estimates for that voxel.</p>
</div></blockquote>
<dl class="last docutils">
<dt>norm_factor: float, optional</dt>
<dd><p class="first last">The value to normalize the ap values. Default is 10^-5.</p>
</dd>
<dt>power <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The degree to which power maps are calculated. Default: 2.</p>
</dd>
<dt>non_negative: bool, optional</dt>
<dd><p class="first last">Whether to rectify the resulting map to be non-negative.
Default: True.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_ap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The log of the resulting power image.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{1}{2l+1} sum_{m=-l}^l{<a href="#id704"><span class="problematic" id="id705">|</span></a>a_{l,m}|^n}}</p>
<blockquote>
<div><p>Where the last dimension, C, is made of a flattened array of <span class="math notranslate nohighlight">\(l`x:math:`m\)</span>
coefficients, where <span class="math notranslate nohighlight">\(l\)</span> are the SH orders, and <span class="math notranslate nohighlight">\(m = 2l+1\)</span>,
So l=1 has 1 coeffecient, l=2 has 5,  l=8 has 17 and so on.
A l=2 SH coefficient matrix will then be composed of a IxJxKx6 volume.
The power, <span class="math notranslate nohighlight">\(n\)</span> is usually set to <span class="math notranslate nohighlight">\(n=2\)</span>.</p>
<p>The final AP image is then shifted by -log(norm_factor), to be strictly
non-negative. Remaining values &lt; 0 are discarded (set to 0), per default,
and this option is controlled through the <cite>non_negative</cite> keyword argument.</p>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="id706">
<h3>auto_attr<a class="headerlink" href="#id706" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.auto_attr">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">auto_attr</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.auto_attr" title="Permalink to this definition"></a></dt>
<dd><p>Decorator to create OneTimeProperty attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">The method that will be called the first time to compute a value.
Afterwards, the methods name will be a standard attribute holding the
value of this computation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MagicProp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@auto_attr</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">99</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MagicProp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">a</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="bootstrap-data-array">
<h3>bootstrap_data_array<a class="headerlink" href="#bootstrap-data-array" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.bootstrap_data_array">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">bootstrap_data_array</code><span class="sig-paren">(</span><em>data</em>, <em>H</em>, <em>R</em>, <em>permute=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.bootstrap_data_array" title="Permalink to this definition"></a></dt>
<dd><p>Applies the Residual Bootstraps to the data given H and R</p>
<p>data must be normalized, ie 0 &lt; data &lt;= 1</p>
<p>This function, and the bootstrap_data_voxel function, calculate
residual-bootsrap samples given a Hat matrix and a Residual matrix. These
samples can be used for non-parametric statistics or for bootstrap
probabilistic tractography:</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rf84331cfd25c-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id707">[1]</a></td><td>J. I. Berman, et al., Probabilistic streamline q-ball tractography
using the residual bootstrap 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rf84331cfd25c-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id708">[2]</a></td><td>HA Haroon, et al., Using the model-based residual bootstrap to
quantify uncertainty in fiber orientations from Q-ball analysis
2009.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rf84331cfd25c-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id709">[3]</a></td><td>B. Jeurissen, et al., Probabilistic Fiber Tracking Using the
Residual Bootstrap with Constrained Spherical Deconvolution 2011.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="bootstrap-data-voxel">
<h3>bootstrap_data_voxel<a class="headerlink" href="#bootstrap-data-voxel" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.bootstrap_data_voxel">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">bootstrap_data_voxel</code><span class="sig-paren">(</span><em>data</em>, <em>H</em>, <em>R</em>, <em>permute=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.bootstrap_data_voxel" title="Permalink to this definition"></a></dt>
<dd><p>Like bootstrap_data_array but faster when for a single voxel</p>
<p>data must be 1d and normalized</p>
</dd></dl>

</div>
<div class="section" id="calculate-max-order">
<h3>calculate_max_order<a class="headerlink" href="#calculate-max-order" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.calculate_max_order">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">calculate_max_order</code><span class="sig-paren">(</span><em>n_coeffs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.calculate_max_order" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>Calculate the maximal harmonic order, given that you know the</dt>
<dd>number of parameters that were estimated.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n_coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of SH coefficients</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The maximal SH order, given the number of coefficients</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>rac{1}{2} (L+1) (L+2)</p>
<p>arrow 2n = L^2 + 3L + 2</p>
<p>arrow L^2 + 3L + 2 - 2n = 0</p>
<p>arrow L^2 + 3L + 2(1-n) = 0</p>
<p>arrow L_{1,2} = 
rac{-3 pm sqrt{9 - 8 (1-n)}}{2}</p>
<p>arrow L{1,2} = 
rac{-3 pm sqrt{1 + 8n}}{2}</p>
<blockquote>
<div>Finally, the positive value is chosen between the two options.</div></blockquote>
</dd></dl>

</div>
<div class="section" id="id710">
<h3>cart2sphere<a class="headerlink" href="#id710" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.cart2sphere">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">cart2sphere</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.cart2sphere" title="Permalink to this definition"></a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions and derivation
of the formulae.</p>
<p><span class="math notranslate nohighlight">\(0\le\theta\mathrm{(theta)}\le\pi\)</span> and <span class="math notranslate nohighlight">\(-\pi\le\phi\mathrm{(phi)}\le\pi\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">x coordinate in Cartesian space</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">z coordinate</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">radius</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">inclination (polar) angle</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">azimuth angle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="concatenate">
<h3>concatenate<a class="headerlink" href="#concatenate" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.concatenate">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">concatenate</code><span class="sig-paren">(</span><em>(a1</em>, <em>a2</em>, <em>...)</em>, <em>axis=0</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.concatenate" title="Permalink to this definition"></a></dt>
<dd><p>Join a sequence of arrays along an existing axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a1, a2, </strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of array_like</span></dt>
<dd><p class="first last">The arrays must have the same shape, except in the dimension
corresponding to <cite>axis</cite> (the first, by default).</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The axis along which the arrays will be joined.  If axis is None,
arrays are flattened before use.  Default is 0.</p>
</dd>
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">If provided, the destination to place the result. The shape must be
correct, matching that of what concatenate would have returned if no
out argument were specified.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The concatenated array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ma.concatenate</span></code></dt>
<dd>Concatenate function that preserves input masks.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">array_split</span></code></dt>
<dd>Split an array into multiple sub-arrays of equal or near-equal size.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></dt>
<dd>Split array into a list of multiple sub-arrays of equal size.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">hsplit</span></code></dt>
<dd>Split array into multiple sub-arrays horizontally (column wise)</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vsplit</span></code></dt>
<dd>Split array into multiple sub-arrays vertically (row wise)</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dsplit</span></code></dt>
<dd>Split array into multiple sub-arrays along the 3rd axis (depth).</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></dt>
<dd>Stack a sequence of arrays along a new axis.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">hstack</span></code></dt>
<dd>Stack arrays in sequence horizontally (column wise)</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vstack</span></code></dt>
<dd>Stack arrays in sequence vertically (row wise)</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dstack</span></code></dt>
<dd>Stack arrays in sequence depth wise (along third dimension)</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are <em>not</em> preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2, 5],</span>
<span class="go">       [3, 4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<p>This function will not preserve masking of MaskedArray inputs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">masked_array(data = [0 -- 2],</span>
<span class="go">             mask = [False  True False],</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data = [0 1 2 2 3 4],</span>
<span class="go">             mask = False,</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data = [0 -- 2 2 3 4],</span>
<span class="go">             mask = [False  True False False False False],</span>
<span class="go">       fill_value = 999999)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="diag">
<h3>diag<a class="headerlink" href="#diag" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.diag">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">diag</code><span class="sig-paren">(</span><em>v</em>, <em>k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.diag" title="Permalink to this definition"></a></dt>
<dd><p>Extract a diagonal or construct a diagonal array.</p>
<p>See the more detailed documentation for <code class="docutils literal notranslate"><span class="pre">numpy.diagonal</span></code> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">If <cite>v</cite> is a 2-D array, return a copy of its <cite>k</cite>-th diagonal.
If <cite>v</cite> is a 1-D array, return a 2-D array with <cite>v</cite> on the <cite>k</cite>-th
diagonal.</p>
</dd>
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Diagonal in question. The default is 0. Use <cite>k&gt;0</cite> for diagonals
above the main diagonal, and <cite>k&lt;0</cite> for diagonals below the main
diagonal.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The extracted diagonal or constructed diagonal array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code></dt>
<dd>Return specified diagonals.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagflat</span></code></dt>
<dd>Create a 2-D array with the flattened input as a diagonal.</dd>
<dt><a class="reference external" href="https://docs.python.org/3/library/trace.html#module-trace" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a></dt>
<dd>Sum along diagonals.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triu</span></code></dt>
<dd>Upper triangle of an array.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">tril</span></code></dt>
<dd>Lower triangle of an array.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([0, 4, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([3, 7])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 8]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="diff">
<h3>diff<a class="headerlink" href="#diff" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.diff">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">diff</code><span class="sig-paren">(</span><em>a</em>, <em>n=1</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.diff" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the n-th discrete difference along the given axis.</p>
<p>The first difference is given by <code class="docutils literal notranslate"><span class="pre">out[n]</span> <span class="pre">=</span> <span class="pre">a[n+1]</span> <span class="pre">-</span> <span class="pre">a[n]</span></code> along
the given axis, higher differences are calculated by using <cite>diff</cite>
recursively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Input array</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of times values are differenced. If zero, the input
is returned as-is.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The axis along which the difference is taken, default is the
last axis.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>diff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The n-th differences. The shape of the output is the same as <cite>a</cite>
except along <cite>axis</cite> where the dimension is smaller by <cite>n</cite>. The
type of the output is the same as the type of the difference
between any two elements of <cite>a</cite>. This is the same as the type of
<cite>a</cite> in most cases. A notable exception is <cite>datetime64</cite>, which
results in a <cite>timedelta64</cite> output array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">ediff1d</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Type is preserved for boolean arrays, so the result will contain
<cite>False</cite> when consecutive elements are the same and <cite>True</cite> when they
differ.</p>
<p>For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u8_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u8_arr</span><span class="p">)</span>
<span class="go">array([255], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u8_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">-</span> <span class="n">u8_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
<span class="go">array(255, np.uint8)</span>
</pre></div>
</div>
<p>If this is not desirable, then the array should be cast to a larger
integer type first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i16_arr</span> <span class="o">=</span> <span class="n">u8_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">i16_arr</span><span class="p">)</span>
<span class="go">array([-1], dtype=int16)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1,  2,  3, -7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([  1,   1, -10])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[2, 3, 4],</span>
<span class="go">       [5, 1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-1,  2,  0, -2]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="s1">&#39;1066-10-13&#39;</span><span class="p">,</span> <span class="s1">&#39;1066-10-16&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([1, 1], dtype=&#39;timedelta64[D]&#39;)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="dot">
<h3>dot<a class="headerlink" href="#dot" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.dot">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">dot</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.dot" title="Permalink to this definition"></a></dt>
<dd><p>Dot product of two arrays. Specifically,</p>
<ul>
<li><p class="first">If both <cite>a</cite> and <cite>b</cite> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p>
</li>
<li><p class="first">If both <cite>a</cite> and <cite>b</cite> are 2-D arrays, it is matrix multiplication,
but using <code class="xref py py-func docutils literal notranslate"><span class="pre">matmul()</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">b</span></code> is preferred.</p>
</li>
<li><p class="first">If either <cite>a</cite> or <cite>b</cite> is 0-D (scalar), it is equivalent to <code class="xref py py-func docutils literal notranslate"><span class="pre">multiply()</span></code>
and using <code class="docutils literal notranslate"><span class="pre">numpy.multiply(a,</span> <span class="pre">b)</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> is preferred.</p>
</li>
<li><p class="first">If <cite>a</cite> is an N-D array and <cite>b</cite> is a 1-D array, it is a sum product over
the last axis of <cite>a</cite> and <cite>b</cite>.</p>
</li>
<li><p class="first">If <cite>a</cite> is an N-D array and <cite>b</cite> is an M-D array (where <code class="docutils literal notranslate"><span class="pre">M&gt;=2</span></code>), it is a
sum product over the last axis of <cite>a</cite> and the second-to-last axis of <cite>b</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">,:,</span><span class="n">m</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">First argument.</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Second argument.</p>
</dd>
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <cite>dot(a,b)</cite>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Returns the dot product of <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <cite>out</cite> is given, then it is returned.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">If the last dimension of <cite>a</cite> is not the same size as
the second-to-last dimension of <cite>b</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vdot</span></code></dt>
<dd>Complex-conjugating dot product.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot</span></code></dt>
<dd>Sum products over arbitrary axes.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">einsum</span></code></dt>
<dd>Einstein summation convention.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">matmul</span></code></dt>
<dd>&#64; operator as method with out parameter.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Neither argument is complex-conjugated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>
<span class="go">(-13+0j)</span>
</pre></div>
</div>
<p>For 2-D arrays it is the matrix product:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[4, 1],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">499128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">499128</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="empty">
<h3>empty<a class="headerlink" href="#empty" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.empty">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">empty</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype=float</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.empty" title="Permalink to this definition"></a></dt>
<dd><p>Return a new array of given shape and type, without initializing entries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span></dt>
<dd><p class="first last">Shape of the empty array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd><p class="first last">Desired output data-type for the array, e.g, <cite>numpy.int8</cite>. Default is
<cite>numpy.float64</cite>.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{C, F}, optional, default: C</span></dt>
<dd><p class="first last">Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Array of uninitialized (arbitrary) data of the given shape, dtype, and
order.  Object arrays will be initialized to None.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_like</span></code></dt>
<dd>Return an empty array with shape and type of input.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></dt>
<dd>Return a new array setting values to one.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></dt>
<dd>Return a new array setting values to zero.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></dt>
<dd>Return a new array of given shape filled with value.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>empty</cite>, unlike <cite>zeros</cite>, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([[ -9.74499359e+001,   6.69583040e-309],</span>
<span class="go">       [  2.13182611e-314,   3.06959433e-309]])         #random</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[-1073741821, -1067949133],</span>
<span class="go">       [  496041986,    19249760]])                     #random</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="eye">
<h3>eye<a class="headerlink" href="#eye" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.eye">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">eye</code><span class="sig-paren">(</span><em>N</em>, <em>M=None</em>, <em>k=0</em>, <em>dtype=&lt;class 'float'&gt;</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.eye" title="Permalink to this definition"></a></dt>
<dd><p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of rows in the output.</p>
</dd>
<dt><strong>M</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of columns in the output. If None, defaults to <cite>N</cite>.</p>
</dd>
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal, and a negative value
to a lower diagonal.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd><p class="first last">Data-type of the returned array.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{C, F}, optional</span></dt>
<dd><p class="first">Whether the output should be stored in row-major (C-style) or
column-major (Fortran-style) order in memory.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>I</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (N,M)</span></dt>
<dd><p class="first last">An array where all elements are equal to zero, except for the <cite>k</cite>-th
diagonal, whose values are equal to one.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identity</span></code></dt>
<dd>(almost) equivalent function</dd>
<dt><a class="reference internal" href="#dipy.reconst.shm.diag" title="dipy.reconst.shm.diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diag</span></code></a></dt>
<dd>diagonal 2-D array from a 1-D array specified by the user.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 0],</span>
<span class="go">       [0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id711">
<h3>forward_sdeconv_mat<a class="headerlink" href="#id711" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.forward_sdeconv_mat">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">forward_sdeconv_mat</code><span class="sig-paren">(</span><em>r_rh</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.forward_sdeconv_mat" title="Permalink to this definition"></a></dt>
<dd><p>Build forward spherical deconvolution matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r_rh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Rotational harmonics coefficients for the single fiber response
function. Each element <cite>rh[i]</cite> is associated with spherical harmonics
of degree <cite>2*i</cite>.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The degree of spherical harmonic function associated with each row of
the deconvolution matrix. Only even degrees are allowed</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N, N)</span></dt>
<dd><p class="first last">Deconvolution matrix with shape (N, N)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="gen-dirac">
<h3>gen_dirac<a class="headerlink" href="#gen-dirac" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.gen_dirac">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">gen_dirac</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.gen_dirac" title="Permalink to this definition"></a></dt>
<dd><p>Generate Dirac delta function orientated in (theta, phi) on the sphere</p>
<p>The spherical harmonics (SH) representation of this Dirac is returned as
coefficients to spherical harmonic functions produced by
<cite>shm.real_sph_harm</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">The order of the spherical harmonic function associated with each
coefficient.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">The degree of the spherical harmonic function associated with each
coefficient.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dirac</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">SH coefficients representing the Dirac function. The shape of this is
<cite>(m + 2) * (m + 1) / 2</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sph_harm</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sym_sh_basis</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="hat">
<h3>hat<a class="headerlink" href="#hat" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.hat">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">hat</code><span class="sig-paren">(</span><em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.hat" title="Permalink to this definition"></a></dt>
<dd><p>Returns the hat matrix for the design matrix B</p>
</dd></dl>

</div>
<div class="section" id="id712">
<h3>lazy_index<a class="headerlink" href="#id712" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.lazy_index">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">lazy_index</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.lazy_index" title="Permalink to this definition"></a></dt>
<dd><p>Produces a lazy index</p>
<p>Returns a slice that can be used for indexing an array, if no slice can be
made index is returned as is.</p>
</dd></dl>

</div>
<div class="section" id="lcr-matrix">
<h3>lcr_matrix<a class="headerlink" href="#lcr-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.lcr_matrix">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">lcr_matrix</code><span class="sig-paren">(</span><em>H</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.lcr_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns a matrix for computing leveraged, centered residuals from data</p>
<p>if r = (d-Hd), the leveraged centered residuals are lcr = (r/l)-mean(r/l)
ruturns the matrix R, such lcr = Rd</p>
</dd></dl>

</div>
<div class="section" id="id713">
<h3>lpn<a class="headerlink" href="#id713" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.lpn">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">lpn</code><span class="sig-paren">(</span><em>n</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.lpn" title="Permalink to this definition"></a></dt>
<dd><p>Legendre function of the first kind.</p>
<p>Compute sequence of Legendre functions of the first kind (polynomials),
Pn(z) and derivatives for all degrees from 0 to n (inclusive).</p>
<p>See also special.legendre for polynomial class.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r99d3a26015f1-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id714">[1]</a></td><td>Zhang, Shanjie and Jin, Jianming. Computation of Special
Functions, John Wiley and Sons, 1996.
<a class="reference external" href="https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html">https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="normalize-data">
<h3>normalize_data<a class="headerlink" href="#normalize-data" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.normalize_data">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">normalize_data</code><span class="sig-paren">(</span><em>data</em>, <em>where_b0</em>, <em>min_signal=1.0</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.normalize_data" title="Permalink to this definition"></a></dt>
<dd><p>Normalizes the data with respect to the mean b0</p>
</dd></dl>

</div>
<div class="section" id="order-from-ncoef">
<h3>order_from_ncoef<a class="headerlink" href="#order-from-ncoef" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.order_from_ncoef">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">order_from_ncoef</code><span class="sig-paren">(</span><em>ncoef</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.order_from_ncoef" title="Permalink to this definition"></a></dt>
<dd><p>Given a number n of coefficients, calculate back the sh_order</p>
</dd></dl>

</div>
<div class="section" id="id715">
<h3>pinv<a class="headerlink" href="#id715" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.pinv">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">pinv</code><span class="sig-paren">(</span><em>a</em>, <em>rcond=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.pinv" title="Permalink to this definition"></a></dt>
<dd><p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate the generalized inverse of a matrix using its
singular-value decomposition (SVD) and including all
<em>large</em> singular values.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.14: </span>Can now operate on stacks of matrices</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, M, N) array_like</span></dt>
<dd><p class="first last">Matrix or stack of matrices to be pseudo-inverted.</p>
</dd>
<dt><strong>rcond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">() array_like of float</span></dt>
<dd><p class="first last">Cutoff for small singular values.
Singular values smaller (in modulus) than
<cite>rcond</cite> * largest_singular_value (again, in modulus)
are set to zero. Broadcasts against the stack of matrices</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, N, M) ndarray</span></dt>
<dd><p class="first last">The pseudo-inverse of <cite>a</cite>. If <cite>a</cite> is a <cite>matrix</cite> instance, then so
is <cite>B</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>LinAlgError</strong></dt>
<dd><p class="first last">If the SVD computation does not converge.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The pseudo-inverse of a matrix A, denoted <span class="math notranslate nohighlight">\(A^+\)</span>, is
defined as: the matrix that solves [the least-squares problem]
<span class="math notranslate nohighlight">\(Ax = b\)</span>, i.e., if <span class="math notranslate nohighlight">\(\bar{x}\)</span> is said solution, then
<span class="math notranslate nohighlight">\(A^+\)</span> is that matrix such that <span class="math notranslate nohighlight">\(\bar{x} = A^+b\)</span>.</p>
<p>It can be shown that if <span class="math notranslate nohighlight">\(Q_1 \Sigma Q_2^T = A\)</span> is the singular
value decomposition of A, then
<span class="math notranslate nohighlight">\(A^+ = Q_2 \Sigma^+ Q_1^T\)</span>, where <span class="math notranslate nohighlight">\(Q_{1,2}\)</span> are
orthogonal matrices, <span class="math notranslate nohighlight">\(\Sigma\)</span> is a diagonal matrix consisting
of As so-called singular values, (followed, typically, by
zeros), and then <span class="math notranslate nohighlight">\(\Sigma^+\)</span> is simply the diagonal matrix
consisting of the reciprocals of As singular values
(again, followed by zeros). <a class="reference internal" href="#raf3ddba36db6-1" id="id716">[1]</a></p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="raf3ddba36db6-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id716">1</a>, <a class="fn-backref" href="#id717">2</a>)</em> G. Strang, <em>Linear Algebra and Its Applications</em>, 2nd Ed., Orlando,
FL, Academic Press, Inc., 1980, pp. 139-142.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>The following example checks that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">a+</span> <span class="pre">*</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">a+</span> <span class="pre">*</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">a+</span> <span class="pre">==</span> <span class="pre">a+</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">a</span><span class="p">)))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="randint">
<h3>randint<a class="headerlink" href="#randint" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.randint">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">randint</code><span class="sig-paren">(</span><em>low</em>, <em>high=None</em>, <em>size=None</em>, <em>dtype='l'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.randint" title="Permalink to this definition"></a></dt>
<dd><p>Return random integers from <cite>low</cite> (inclusive) to <cite>high</cite> (exclusive).</p>
<p>Return random integers from the discrete uniform distribution of
the specified dtype in the half-open interval [<cite>low</cite>, <cite>high</cite>). If
<cite>high</cite> is None (the default), then results are from [0, <cite>low</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>low</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Lowest (signed) integer to be drawn from the distribution (unless
<code class="docutils literal notranslate"><span class="pre">high=None</span></code>, in which case this parameter is one above the
<em>highest</em> such integer).</p>
</dd>
<dt><strong>high</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">If provided, one above the largest (signed) integer to be drawn
from the distribution (see above for behavior if <code class="docutils literal notranslate"><span class="pre">high=None</span></code>).</p>
</dd>
<dt><strong>size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints, optional</span></dt>
<dd><p class="first last">Output shape.  If the given shape is, e.g., <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n,</span> <span class="pre">k)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">k</span></code> samples are drawn.  Default is None, in which case a
single value is returned.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd><p class="first">Desired dtype of the result. All dtypes are determined by their
name, i.e., int64, int, etc, so byteorder is not available
and a specific precision may have different C types depending
on the platform. The default value is np.int.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.11.0.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or ndarray of ints</span></dt>
<dd><p class="first last"><cite>size</cite>-shaped array of random integers from the appropriate
distribution, or a single such random int if <cite>size</cite> not provided.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">random.random_integers</span></code></dt>
<dd>similar to <cite>randint</cite>, only for the closed interval [<cite>low</cite>, <cite>high</cite>], and 1 is the lowest value if <cite>high</cite> is omitted. In particular, this other one is the one to use to generate uniformly distributed discrete non-integers.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<p>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">array([[4, 0, 2, 1],</span>
<span class="go">       [3, 2, 2, 0]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id718">
<h3>real_sph_harm<a class="headerlink" href="#id718" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.real_sph_harm">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">real_sph_harm</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sph_harm" title="Permalink to this definition"></a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>Where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:</p>
<blockquote>
<div>Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
<span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code></span></dt>
<dd><p class="first last">The order of the harmonic.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt>
<dd><p class="first last">The degree of the harmonic.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">real float</span></dt>
<dd><p class="first last">The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.special.sph_harm</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="id719">
<h3>real_sym_sh_basis<a class="headerlink" href="#id719" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.real_sym_sh_basis">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">real_sym_sh_basis</code><span class="sig-paren">(</span><em>sh_order</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sym_sh_basis" title="Permalink to this definition"></a></dt>
<dd><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p>
<p>Samples the basis functions up to order <cite>sh_order</cite> at points on the sphere
given by <cite>theta</cite> and <cite>phi</cite>. The basis functions are defined here the same
way as in Descoteaux et al. 2007 <a class="reference internal" href="#r573dd6557753-1" id="id720">[1]</a> where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is
defined to be:</p>
<blockquote>
<div>Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
<span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">even int &gt; 0, max spherical harmonic degree</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">real float</span></dt>
<dd><p class="first last">The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite></p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The order of the harmonics.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The degree of the harmonics.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r573dd6557753-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id720">1</a>, <a class="fn-backref" href="#id721">2</a>)</em> Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="real-sym-sh-mrtrix">
<h3>real_sym_sh_mrtrix<a class="headerlink" href="#real-sym-sh-mrtrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.real_sym_sh_mrtrix">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">real_sym_sh_mrtrix</code><span class="sig-paren">(</span><em>sh_order</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.real_sym_sh_mrtrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute real spherical harmonics as in Tournier 2007 <a class="reference internal" href="#r220a2be8a767-2" id="id722">[2]</a>, where the real
harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Real(:math:`Y^m_n`)       if m &gt; 0
:math:`Y^0_n`             if m = 0
Imag(:math:`Y^|m|_n`)     if m &lt; 0
</pre></div>
</div>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The maximum degree or the spherical harmonic basis.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">real float</span></dt>
<dd><p class="first last">The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite> as
implemented in mrtrix. Warning: the basis is Tournier et al.
2007 <a class="reference internal" href="#r220a2be8a767-2" id="id723">[2]</a>; 2004 <a class="reference internal" href="#r220a2be8a767-1" id="id724">[1]</a> is slightly different.</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The order of the harmonics.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The degree of the harmonics.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r220a2be8a767-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id724">1</a>, <a class="fn-backref" href="#id725">2</a>)</em> Tournier J.D., Calamante F., Gadian D.G. and Connelly A.
Direct estimation of the fibre orientation density function from
diffusion-weighted MRI data using spherical deconvolution.
NeuroImage. 2004;23:1176-1185.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r220a2be8a767-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id55">1</a>, <a class="fn-backref" href="#id722">2</a>, <a class="fn-backref" href="#id723">3</a>, <a class="fn-backref" href="#id726">4</a>)</em> Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sf-to-sh">
<h3>sf_to_sh<a class="headerlink" href="#sf-to-sh" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sf_to_sh">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">sf_to_sh</code><span class="sig-paren">(</span><em>sf</em>, <em>sphere</em>, <em>sh_order=4</em>, <em>basis_type=None</em>, <em>smooth=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sf_to_sh" title="Permalink to this definition"></a></dt>
<dd><p>Spherical function to spherical harmonics (SH).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Values of a function on the given <cite>sphere</cite>.</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The points on which the sf is defined.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients (default 4).</p>
</dd>
<dt><strong>basis_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, tournier07, descoteaux07}</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="reference internal" href="#r52104e733a02-2" id="id727">[2]</a> basis, and
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="reference internal" href="#r52104e733a02-1" id="id728">[1]</a> basis
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>smooth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Lambda-regularization in the SH fit (default 0.0).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">SH coefficients representing the input function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r52104e733a02-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id728">1</a>, <a class="fn-backref" href="#id729">2</a>)</em> Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r52104e733a02-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id727">1</a>, <a class="fn-backref" href="#id730">2</a>)</em> Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id731">
<h3>sh_to_rh<a class="headerlink" href="#id731" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sh_to_rh">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">sh_to_rh</code><span class="sig-paren">(</span><em>r_sh</em>, <em>m</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sh_to_rh" title="Permalink to this definition"></a></dt>
<dd><p>Spherical harmonics (SH) to rotational harmonics (RH)</p>
<p>Calculate the rotational harmonic decomposition up to
harmonic order <cite>m</cite>, degree <cite>n</cite> for an axially and antipodally
symmetric function. Note that all <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">!=</span> <span class="pre">0</span></code> coefficients
will be ignored as axial symmetry is assumed. Hence, there
will be <code class="docutils literal notranslate"><span class="pre">(sh_order/2</span> <span class="pre">+</span> <span class="pre">1)</span></code> non-zero coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r_sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">ndarray of SH coefficients for the single fiber response function.
These coefficients must correspond to the real spherical harmonic
functions produced by <cite>shm.real_sph_harm</cite>.</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">The order of the spherical harmonic function associated with each
coefficient.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (N,)</span></dt>
<dd><p class="first last">The degree of the spherical harmonic function associated with each
coefficient.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r_rh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)*(sh_order</span> <span class="pre">+</span> <span class="pre">2)/2</span></code>,)</span></dt>
<dd><p class="first last">Rotational harmonics coefficients representing the input <cite>r_sh</cite></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sph_harm</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">shm.real_sym_sh_basis</span></code></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r31c920df34a3-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id732">[1]</a></td><td>Tournier, J.D., et al. NeuroImage 2007. Robust determination of the
fibre orientation distribution in diffusion MRI: Non-negativity
constrained super-resolved spherical deconvolution</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sh-to-sf">
<h3>sh_to_sf<a class="headerlink" href="#sh-to-sf" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sh_to_sf">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">sh_to_sf</code><span class="sig-paren">(</span><em>sh</em>, <em>sphere</em>, <em>sh_order</em>, <em>basis_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sh_to_sf" title="Permalink to this definition"></a></dt>
<dd><p>Spherical harmonics (SH) to spherical function (SF).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">SH coefficients representing a spherical function.</p>
</dd>
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The points on which to sample the spherical function.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients (default 4).</p>
</dd>
<dt><strong>basis_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, tournier07, descoteaux07}</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="reference internal" href="#rc2e19fb985c5-2" id="id733">[2]</a> basis, and
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="reference internal" href="#rc2e19fb985c5-1" id="id734">[1]</a> basis
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Spherical function values on the <cite>sphere</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rc2e19fb985c5-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id734">1</a>, <a class="fn-backref" href="#id735">2</a>)</em> Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rc2e19fb985c5-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id733">1</a>, <a class="fn-backref" href="#id736">2</a>)</em> Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id737">
<h3>sh_to_sf_matrix<a class="headerlink" href="#id737" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sh_to_sf_matrix">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">sh_to_sf_matrix</code><span class="sig-paren">(</span><em>sphere</em>, <em>sh_order</em>, <em>basis_type=None</em>, <em>return_inv=True</em>, <em>smooth=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sh_to_sf_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Matrix that transforms Spherical harmonics (SH) to spherical
function (SF).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Sphere</span></dt>
<dd><p class="first last">The points on which to sample the spherical function.</p>
</dd>
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be
<code class="docutils literal notranslate"><span class="pre">(sh_order</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(sh_order_2)</span> <span class="pre">/</span> <span class="pre">2</span></code> SH coefficients (default 4).</p>
</dd>
<dt><strong>basis_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, tournier07, descoteaux07}</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">None</span></code> for the default DIPY basis,
<code class="docutils literal notranslate"><span class="pre">tournier07</span></code> for the Tournier 2007 <a class="reference internal" href="#r8e8198e28e5b-2" id="id738">[2]</a> basis, and
<code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code> for the Descoteaux 2007 <a class="reference internal" href="#r8e8198e28e5b-1" id="id739">[1]</a> basis
(<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">descoteaux07</span></code>).</p>
</dd>
<dt><strong>return_inv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True then the inverse of the matrix is also returned</p>
</dd>
<dt><strong>smooth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Lambda-regularization in the SH fit (default 0.0).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Matrix that transforms spherical harmonics to spherical function
<code class="docutils literal notranslate"><span class="pre">sf</span> <span class="pre">=</span> <span class="pre">np.dot(sh,</span> <span class="pre">B)</span></code>.</p>
</dd>
<dt><strong>invB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Inverse of B.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r8e8198e28e5b-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id739">1</a>, <a class="fn-backref" href="#id740">2</a>)</em> Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.
Regularized, Fast, and Robust Analytical Q-ball Imaging.
Magn. Reson. Med. 2007;58:497-510.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r8e8198e28e5b-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id738">1</a>, <a class="fn-backref" href="#id741">2</a>)</em> Tournier J.D., Calamante F. and Connelly A. Robust determination
of the fibre orientation distribution in diffusion MRI:
Non-negativity constrained super-resolved spherical deconvolution.
NeuroImage. 2007;35(4):1459-1472.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="smooth-pinv">
<h3>smooth_pinv<a class="headerlink" href="#smooth-pinv" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.smooth_pinv">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">smooth_pinv</code><span class="sig-paren">(</span><em>B</em>, <em>L</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.smooth_pinv" title="Permalink to this definition"></a></dt>
<dd><p>Regularized pseudo-inverse</p>
<p>Computes a regularized least square inverse of B</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (n, m)</span></dt>
<dd><p class="first last">Matrix to be inverted</p>
</dd>
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (n,)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (m, n)</span></dt>
<dd><p class="first last">regularized least square inverse of B</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In the literature this inverse is often written <span class="math notranslate nohighlight">\((B^{T}B+L^{2})^{-1}B^{T}\)</span>.
However here this inverse is implemented using the pseudo-inverse because
it is more numerically stable than the direct implementation of the matrix
product.</p>
</dd></dl>

</div>
<div class="section" id="id742">
<h3>sph_harm_ind_list<a class="headerlink" href="#id742" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.sph_harm_ind_list">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">sph_harm_ind_list</code><span class="sig-paren">(</span><em>sh_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.sph_harm_ind_list" title="Permalink to this definition"></a></dt>
<dd><p>Returns the degree (n) and order (m) of all the symmetric spherical
harmonics of degree less then or equal to <cite>sh_order</cite>. The results, <cite>m_list</cite>
and <cite>n_list</cite> are kx1 arrays, where k depends on sh_order. They can be
passed to <a class="reference internal" href="#dipy.reconst.shm.real_sph_harm" title="dipy.reconst.shm.real_sph_harm"><code class="xref py py-func docutils literal notranslate"><span class="pre">real_sph_harm()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sh_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">even int &gt; 0, max degree to return</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>m_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">orders of even spherical harmonics</p>
</dd>
<dt><strong>n_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">degrees of even spherical harmonics</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dipy.reconst.shm.real_sph_harm" title="dipy.reconst.shm.real_sph_harm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real_sph_harm</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="spherical-harmonics">
<h3>spherical_harmonics<a class="headerlink" href="#spherical-harmonics" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.spherical_harmonics">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">spherical_harmonics</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.spherical_harmonics" title="Permalink to this definition"></a></dt>
<dd><p>Compute spherical harmonics</p>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code></span></dt>
<dd><p class="first last">The order of the harmonic.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt>
<dd><p class="first last">The degree of the harmonic.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex float</span></dt>
<dd><p class="first last">The harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is a faster implementation of scipy.special.sph_harm for
scipy version &lt; 0.15.0. For scipy 0.15 and onwards, we use the scipy
implementation of the function</p>
</dd></dl>

</div>
<div class="section" id="svd">
<h3>svd<a class="headerlink" href="#svd" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.svd">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">svd</code><span class="sig-paren">(</span><em>a</em>, <em>full_matrices=True</em>, <em>compute_uv=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.svd" title="Permalink to this definition"></a></dt>
<dd><p>Singular Value Decomposition.</p>
<p>When <cite>a</cite> is a 2D array, it is factorized as <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">&#64;</span> <span class="pre">np.diag(s)</span> <span class="pre">&#64;</span> <span class="pre">vh</span>
<span class="pre">=</span> <span class="pre">(u</span> <span class="pre">*</span> <span class="pre">s)</span> <span class="pre">&#64;</span> <span class="pre">vh</span></code>, where <cite>u</cite> and <cite>vh</cite> are 2D unitary arrays and <cite>s</cite> is a 1D
array of <cite>a</cite>s singular values. When <cite>a</cite> is higher-dimensional, SVD is
applied in stacked mode as explained below.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, M, N) array_like</span></dt>
<dd><p class="first last">A real or complex array with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>.</p>
</dd>
<dt><strong>full_matrices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True (default), <cite>u</cite> and <cite>vh</cite> have the shapes <code class="docutils literal notranslate"><span class="pre">(...,</span> <span class="pre">M,</span> <span class="pre">M)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(...,</span> <span class="pre">N,</span> <span class="pre">N)</span></code>, respectively.  Otherwise, the shapes are
<code class="docutils literal notranslate"><span class="pre">(...,</span> <span class="pre">M,</span> <span class="pre">K)</span></code> and <code class="docutils literal notranslate"><span class="pre">(...,</span> <span class="pre">K,</span> <span class="pre">N)</span></code>, respectively, where
<code class="docutils literal notranslate"><span class="pre">K</span> <span class="pre">=</span> <span class="pre">min(M,</span> <span class="pre">N)</span></code>.</p>
</dd>
<dt><strong>compute_uv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to compute <cite>u</cite> and <cite>vh</cite> in addition to <cite>s</cite>.  True
by default.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{ (, M, M), (, M, K) } array</span></dt>
<dd><p class="first last">Unitary array(s). The first <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">2</span></code> dimensions have the same
size as those of the input <cite>a</cite>. The size of the last two dimensions
depends on the value of <cite>full_matrices</cite>. Only returned when
<cite>compute_uv</cite> is True.</p>
</dd>
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(, K) array</span></dt>
<dd><p class="first last">Vector(s) with the singular values, within each vector sorted in
descending order. The first <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">2</span></code> dimensions have the same
size as those of the input <cite>a</cite>.</p>
</dd>
<dt><strong>vh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{ (, N, N), (, K, N) } array</span></dt>
<dd><p class="first last">Unitary array(s). The first <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">2</span></code> dimensions have the same
size as those of the input <cite>a</cite>. The size of the last two dimensions
depends on the value of <cite>full_matrices</cite>. Only returned when
<cite>compute_uv</cite> is True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>LinAlgError</strong></dt>
<dd><p class="first last">If SVD computation does not converge.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.8.0: </span>Broadcasting rules apply, see the <cite>numpy.linalg</cite> documentation for
details.</p>
</div>
<p>The decomposition is performed using LAPACK routine <code class="docutils literal notranslate"><span class="pre">_gesdd</span></code>.</p>
<p>SVD is usually described for the factorization of a 2D matrix <span class="math notranslate nohighlight">\(A\)</span>.
The higher-dimensional case will be discussed below. In the 2D case, SVD is
written as <span class="math notranslate nohighlight">\(A = U S V^H\)</span>, where <span class="math notranslate nohighlight">\(A = a\)</span>, <span class="math notranslate nohighlight">\(U= u\)</span>,
<span class="math notranslate nohighlight">\(S= \mathtt{np.diag}(s)\)</span> and <span class="math notranslate nohighlight">\(V^H = vh\)</span>. The 1D array <cite>s</cite>
contains the singular values of <cite>a</cite> and <cite>u</cite> and <cite>vh</cite> are unitary. The rows
of <cite>vh</cite> are the eigenvectors of <span class="math notranslate nohighlight">\(A^H A\)</span> and the columns of <cite>u</cite> are
the eigenvectors of <span class="math notranslate nohighlight">\(A A^H\)</span>. In both cases the corresponding
(possibly non-zero) eigenvalues are given by <code class="docutils literal notranslate"><span class="pre">s**2</span></code>.</p>
<p>If <cite>a</cite> has more than two dimensions, then broadcasting rules apply, as
explained in <span class="xref std std-ref">routines.linalg-broadcasting</span>. This means that SVD is
working in stacked mode: it iterates over all indices of the first
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">2</span></code> dimensions and for each combination SVD is applied to the
last two indices. The matrix <cite>a</cite> can be reconstructed from the
decomposition with either <code class="docutils literal notranslate"><span class="pre">(u</span> <span class="pre">*</span> <span class="pre">s[...,</span> <span class="pre">None,</span> <span class="pre">:])</span> <span class="pre">&#64;</span> <span class="pre">vh</span></code> or
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">&#64;</span> <span class="pre">(s[...,</span> <span class="pre">None]</span> <span class="pre">*</span> <span class="pre">vh)</span></code>. (The <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator can be replaced by the
function <code class="docutils literal notranslate"><span class="pre">np.matmul</span></code> for python versions below 3.5.)</p>
<p>If <cite>a</cite> is a <code class="docutils literal notranslate"><span class="pre">matrix</span></code> object (as opposed to an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>), then so are
all the return values.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Reconstruction based on full SVD, 2D case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">vh</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((9, 9), (6,), (6, 6))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smat</span><span class="p">[:</span><span class="mi">6</span><span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">smat</span><span class="p">,</span> <span class="n">vh</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Reconstruction based on reduced SVD, 2D case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">vh</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((9, 6), (6,), (6, 6))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">smat</span><span class="p">,</span> <span class="n">vh</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Reconstruction based on full SVD, 4D case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">vh</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">vh</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">vh</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Reconstruction based on reduced SVD, 4D case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">vh</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">vh</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">vh</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="unique">
<h3>unique<a class="headerlink" href="#unique" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shm.unique">
<code class="descclassname">dipy.reconst.shm.</code><code class="descname">unique</code><span class="sig-paren">(</span><em>ar</em>, <em>return_index=False</em>, <em>return_inverse=False</em>, <em>return_counts=False</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shm.unique" title="Permalink to this definition"></a></dt>
<dd><p>Find the unique elements of an array.</p>
<p>Returns the sorted unique elements of an array. There are three optional
outputs in addition to the unique elements:</p>
<ul class="simple">
<li>the indices of the input array that give the unique values</li>
<li>the indices of the unique array that reconstruct the input array</li>
<li>the number of times each unique value comes up in the input array</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Input array. Unless <cite>axis</cite> is specified, this will be flattened if it
is not already 1-D.</p>
</dd>
<dt><strong>return_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, also return the indices of <cite>ar</cite> (along the specified axis,
if provided, or in the flattened array) that result in the unique array.</p>
</dd>
<dt><strong>return_inverse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, also return the indices of the unique array (for the specified
axis, if provided) that can be used to reconstruct <cite>ar</cite>.</p>
</dd>
<dt><strong>return_counts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If True, also return the number of times each unique item appears
in <cite>ar</cite>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd><p class="first">The axis to operate on. If None, <cite>ar</cite> will be flattened. If an integer,
the subarrays indexed by the given axis will be flattened and treated
as the elements of a 1-D array with the dimension of the given axis,
see the notes for more details.  Object arrays or structured arrays
that contain objects are not supported if the <cite>axis</cite> kwarg is used. The
default is None.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.13.0.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>unique</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The sorted unique values.</p>
</dd>
<dt><strong>unique_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">The indices of the first occurrences of the unique values in the
original array. Only provided if <cite>return_index</cite> is True.</p>
</dd>
<dt><strong>unique_inverse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">The indices to reconstruct the original array from the
unique array. Only provided if <cite>return_inverse</cite> is True.</p>
</dd>
<dt><strong>unique_counts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first">The number of times each of the unique values comes up in the
original array. Only provided if <cite>return_counts</cite> is True.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.lib.arraysetops</span></code></dt>
<dd>Module with a number of other functions for performing set operations on arrays.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When an axis is specified the subarrays indexed by the axis are sorted.
This is done by making the specified axis the first dimension of the array
and then flattening the subarrays in C order. The flattened subarrays are
then viewed as a structured type with each element given a label, with the
effect that we end up with a 1-D array of structured types that can be
treated in the same way as any other 1-D array. The result is that the
flattened subarrays are sorted in lexicographic order starting with the
first element.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Return the unique rows of a 2D array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 0, 0], [2, 3, 4]])</span>
</pre></div>
</div>
<p>Return the indices of the original array that give the unique values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="go">       dtype=&#39;|S1&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>
<span class="go">array([0, 1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="go">       dtype=&#39;|S1&#39;)</span>
</pre></div>
</div>
<p>Reconstruct the input array from the unique values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([1, 2, 3, 4, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>
<span class="go">array([0, 1, 4, 3, 1, 2, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([1, 2, 6, 4, 2, 3, 2])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id743">
<h3><a class="reference internal" href="#dipy.reconst.shore.Cache" title="dipy.reconst.shore.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a><a class="headerlink" href="#id743" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shore.Cache">
<em class="property">class </em><code class="descclassname">dipy.reconst.shore.</code><code class="descname">Cache</code><a class="headerlink" href="#dipy.reconst.shore.Cache" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Cache values based on a key object (such as a sphere or gradient table).</p>
<p class="rubric">Notes</p>
<p>This class is meant to be used as a mix-in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">Cache</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyModelFit</span><span class="p">(</span><span class="n">Fit</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Inside a method on the fit, typical usage would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odf</span><span class="p">(</span><span class="n">sphere</span><span class="p">):</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_basis_matrix</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;odf_basis_matrix&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sphere</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.Cache.cache_clear" title="dipy.reconst.shore.Cache.cache_clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code></a>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.Cache.cache_get" title="dipy.reconst.shore.Cache.cache_get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code></a>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.Cache.cache_set" title="dipy.reconst.shore.Cache.cache_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code></a>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shore.Cache.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.Cache.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.Cache.cache_clear">
<code class="descname">cache_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.Cache.cache_clear" title="Permalink to this definition"></a></dt>
<dd><p>Clear the cache.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.Cache.cache_get">
<code class="descname">cache_get</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.Cache.cache_get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a value from the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>default</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value to be returned if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value from the cache associated with <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.  Returns
<cite>default</cite> if no cached entry is found.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.Cache.cache_set">
<code class="descname">cache_set</code><span class="sig-paren">(</span><em>tag</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.Cache.cache_set" title="Permalink to this definition"></a></dt>
<dd><p>Store a value in the cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Description of the cached value.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Key object used to look up the cached value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Value stored in the cache for each unique combination
of <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">key)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Imagine the following computation is very expensive</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">compute_expensive_matrix</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">cache_set</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">cache_get</span><span class="p">(</span><span class="s1">&#39;expensive_matrix&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="shorefit">
<h3><a class="reference internal" href="#dipy.reconst.shore.ShoreFit" title="dipy.reconst.shore.ShoreFit"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreFit</span></code></a><a class="headerlink" href="#shorefit" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shore.ShoreFit">
<em class="property">class </em><code class="descclassname">dipy.reconst.shore.</code><code class="descname">ShoreFit</code><span class="sig-paren">(</span><em>model</em>, <em>shore_coef</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.shore_coeff" title="dipy.reconst.shore.ShoreFit.shore_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shore_coeff</span></code></a></dt>
<dd><p class="first last">The SHORE coefficients</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.fitted_signal" title="dipy.reconst.shore.ShoreFit.fitted_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fitted_signal</span></code></a>()</td>
<td>The fitted signal.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.msd" title="dipy.reconst.shore.ShoreFit.msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msd</span></code></a>()</td>
<td>Calculates the analytical mean squared displacement (MSD) <a class="reference internal" href="#re8a75ace7245-1" id="id744">[1]</a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.odf" title="dipy.reconst.shore.ShoreFit.odf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf</span></code></a>(sphere)</td>
<td>Calculates the ODF for a given discrete sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.odf_sh" title="dipy.reconst.shore.ShoreFit.odf_sh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">odf_sh</span></code></a>()</td>
<td>Calculates the real analytical ODF in terms of Spherical Harmonics.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.pdf" title="dipy.reconst.shore.ShoreFit.pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf</span></code></a>(r_points)</td>
<td>Diffusion propagator on a given set of real points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.pdf_grid" title="dipy.reconst.shore.ShoreFit.pdf_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pdf_grid</span></code></a>(gridsize,&nbsp;radius_max)</td>
<td>Applies the analytical FFT on <span class="math notranslate nohighlight">\(S\)</span> to generate the diffusion propagator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.rtop_pdf" title="dipy.reconst.shore.ShoreFit.rtop_pdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_pdf</span></code></a>()</td>
<td>Calculates the analytical return to origin probability (RTOP) from the pdf <a class="reference internal" href="#rbef4711069fe-1" id="id745">[1]</a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreFit.rtop_signal" title="dipy.reconst.shore.ShoreFit.rtop_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtop_signal</span></code></a>()</td>
<td>Calculates the analytical return to origin probability (RTOP) from the signal <a class="reference internal" href="#rb9597cd2c627-1" id="id746">[1]</a>.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>model</em>, <em>shore_coef</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Calculates diffusion properties for a single voxel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object,</span></dt>
<dd><p class="first last">AnalyticalModel</p>
</dd>
<dt><strong>shore_coef</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d ndarray,</span></dt>
<dd><p class="first last">shore coefficients</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.fitted_signal">
<code class="descname">fitted_signal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.fitted_signal" title="Permalink to this definition"></a></dt>
<dd><p>The fitted signal.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.msd">
<code class="descname">msd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.msd" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical mean squared displacement (MSD) <a class="reference internal" href="#re8a75ace7245-1" id="id747">[1]</a></p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">MSD:{DSI}=int_{-infty}^{infty}int_{-infty}^{infty}
int_{-infty}^{infty} P(hat{mathbf{r}}) cdot
hat{mathbf{r}}^{2} dr_x dr_y dr_z</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\hat{\mathbf{r}}\)</span> is a point in the 3D propagator space (see Wu
et al. <a class="reference internal" href="#re8a75ace7245-1" id="id748">[1]</a>).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re8a75ace7245-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id744">1</a>, <a class="fn-backref" href="#id747">2</a>, <a class="fn-backref" href="#id748">3</a>, <a class="fn-backref" href="#id749">4</a>)</em> Wu Y. et al., Hybrid diffusion imaging, NeuroImage, vol 36,</td></tr>
</tbody>
</table>
<ol class="loweralpha simple" start="16">
<li>617-629, 2007.</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.odf">
<code class="descname">odf</code><span class="sig-paren">(</span><em>sphere</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.odf" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the ODF for a given discrete sphere.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.odf_sh">
<code class="descname">odf_sh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.odf_sh" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the real analytical ODF in terms of Spherical
Harmonics.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.pdf">
<code class="descname">pdf</code><span class="sig-paren">(</span><em>r_points</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.pdf" title="Permalink to this definition"></a></dt>
<dd><p>Diffusion propagator on a given set of real points.
if the array r_points is non writeable, then intermediate
results are cached for faster recalculation</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.pdf_grid">
<code class="descname">pdf_grid</code><span class="sig-paren">(</span><em>gridsize</em>, <em>radius_max</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.pdf_grid" title="Permalink to this definition"></a></dt>
<dd><p>Applies the analytical FFT on <span class="math notranslate nohighlight">\(S\)</span> to generate the diffusion
propagator. This is calculated on a discrete 3D grid in order to
obtain an EAP similar to that which is obtained with DSI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gridsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">dimension of the propagator grid</p>
</dd>
<dt><strong>radius_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximal radius in which to compute the propagator</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">the ensemble average propagator in the 3D grid</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.rtop_pdf">
<code class="descname">rtop_pdf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.rtop_pdf" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical return to origin probability (RTOP)
from the pdf <a class="reference internal" href="#rbef4711069fe-1" id="id750">[1]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rbef4711069fe-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id745">1</a>, <a class="fn-backref" href="#id750">2</a>, <a class="fn-backref" href="#id751">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreFit.rtop_signal">
<code class="descname">rtop_signal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.rtop_signal" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the analytical return to origin probability (RTOP)
from the signal <a class="reference internal" href="#rb9597cd2c627-1" id="id752">[1]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rb9597cd2c627-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id746">1</a>, <a class="fn-backref" href="#id752">2</a>, <a class="fn-backref" href="#id753">3</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel</td></tr>
</tbody>
</table>
<p>diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</p>
</dd></dl>

<dl class="attribute">
<dt id="dipy.reconst.shore.ShoreFit.shore_coeff">
<code class="descname">shore_coeff</code><a class="headerlink" href="#dipy.reconst.shore.ShoreFit.shore_coeff" title="Permalink to this definition"></a></dt>
<dd><p>The SHORE coefficients</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="shoremodel">
<h3><a class="reference internal" href="#dipy.reconst.shore.ShoreModel" title="dipy.reconst.shore.ShoreModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShoreModel</span></code></a><a class="headerlink" href="#shoremodel" title="Permalink to this headline"></a></h3>
<dl class="class">
<dt id="dipy.reconst.shore.ShoreModel">
<em class="property">class </em><code class="descclassname">dipy.reconst.shore.</code><code class="descname">ShoreModel</code><span class="sig-paren">(</span><em>gtab</em>, <em>radial_order=6</em>, <em>zeta=700</em>, <em>lambdaN=1e-08</em>, <em>lambdaL=1e-08</em>, <em>tau=0.025330295910584444</em>, <em>constrain_e0=False</em>, <em>positive_constraint=False</em>, <em>pos_grid=11</em>, <em>pos_radius=0.02</em>, <em>cvxpy_solver=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.reconst.cache.Cache" title="dipy.reconst.cache.Cache"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.reconst.cache.Cache</span></code></a></p>
<p>Simple Harmonic Oscillator based Reconstruction and Estimation
(SHORE) <a class="reference internal" href="#rd47fc6332129-1" id="id754">[1]</a> of the diffusion signal.</p>
<p>The main idea is to model the diffusion signal as a linear combination of
continuous functions <span class="math notranslate nohighlight">\(\phi_i\)</span>,</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">S(mathbf{q})= sum_{i=0}^I  c_{i} phi_{i}(mathbf{q}).</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> is the wave vector which corresponds to different
gradient directions. Numerous continuous functions <span class="math notranslate nohighlight">\(\phi_i\)</span> can be used to
model <span class="math notranslate nohighlight">\(S\)</span>. Some are presented in [2,3,4]_.</p>
<p>From the <span class="math notranslate nohighlight">\(c_i\)</span> coefficients, there exist analytical formulae to estimate
the ODF, the return to the origin probability (RTOP), the mean square
displacement (MSD), amongst others <a class="reference internal" href="#rd47fc6332129-5" id="id755">[5]</a>.</p>
<p class="rubric">Notes</p>
<p>The implementation of SHORE depends on CVXPY (<a class="reference external" href="http://www.cvxpy.org/">http://www.cvxpy.org/</a>).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd47fc6332129-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id56">1</a>, <a class="fn-backref" href="#id754">2</a>, <a class="fn-backref" href="#id756">3</a>)</em> Ozarslan E. et al., Simple harmonic oscillator based reconstruction
and estimation for one-dimensional q-space magnetic resonance
1D-SHORE), Proc Intl Soc Mag Reson Med, vol. 16, p. 35., 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rd47fc6332129-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id757">[2]</a></td><td>Merlet S. et al., Continuous diffusion signal, EAP and ODF
estimation via Compressive Sensing in diffusion MRI, Medical
Image Analysis, 2013.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rd47fc6332129-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id758">[3]</a></td><td>Rathi Y. et al., Sparse multi-shell diffusion imaging, MICCAI,
2011.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rd47fc6332129-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id759">[4]</a></td><td>Cheng J. et al., Theoretical Analysis and eapactical Insights on
EAP Estimation via a Unified HARDI Framework, MICCAI workshop on
Computational Diffusion MRI, 2011.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rd47fc6332129-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id755">1</a>, <a class="fn-backref" href="#id760">2</a>)</em> Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_clear</span></code>()</td>
<td>Clear the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_get</span></code>(tag,&nbsp;key[,&nbsp;default])</td>
<td>Retrieve a value from the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_set</span></code>(tag,&nbsp;key,&nbsp;value)</td>
<td>Store a value in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.reconst.shore.ShoreModel.fit" title="dipy.reconst.shore.ShoreModel.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data[,&nbsp;mask])</td>
<td>Fit method for every voxel in data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.reconst.shore.ShoreModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>gtab</em>, <em>radial_order=6</em>, <em>zeta=700</em>, <em>lambdaN=1e-08</em>, <em>lambdaL=1e-08</em>, <em>tau=0.025330295910584444</em>, <em>constrain_e0=False</em>, <em>positive_constraint=False</em>, <em>pos_grid=11</em>, <em>pos_radius=0.02</em>, <em>cvxpy_solver=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Analytical and continuous modeling of the diffusion signal with
respect to the SHORE basis [1,2]_.
This implementation is a modification of SHORE presented in <a class="reference internal" href="#r5adcf1d06c8e-1" id="id761">[1]</a>.
The modification was made to obtain the same ordering of the basis
presented in [2,3]_.</p>
<p>The main idea is to model the diffusion signal as a linear
combination of continuous functions <span class="math notranslate nohighlight">\(\phi_i\)</span>,</p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><p class="first last">S(mathbf{q})= sum_{i=0}^I  c_{i} phi_{i}(mathbf{q}).</p>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> is the wave vector which corresponds to different
gradient directions.</p>
<p>From the <span class="math notranslate nohighlight">\(c_i\)</span> coefficients, there exists an analytical formula to
estimate the ODF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable,</span></dt>
<dd><p class="first last">gradient directions and bvalues container class</p>
</dd>
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>zeta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">scale factor</p>
</dd>
<dt><strong>lambdaN</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">radial regularisation constant</p>
</dd>
<dt><strong>lambdaL</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">angular regularisation constant</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">diffusion time. By default the value that makes q equal to the
square root of the b-value.</p>
</dd>
<dt><strong>constrain_e0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool,</span></dt>
<dd><p class="first last">Constrain the optimization such that E(0) = 1.</p>
</dd>
<dt><strong>positive_constraint</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool,</span></dt>
<dd><p class="first last">Constrain the propagator to be positive.</p>
</dd>
<dt><strong>pos_grid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int,</span></dt>
<dd><p class="first last">Grid that define the points of the EAP in which we want to enforce
positivity.</p>
</dd>
<dt><strong>pos_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">Radius of the grid of the EAP in which enforce positivity in
millimeters. By default 20e-03 mm.</p>
</dd>
<dt><strong>cvxpy_solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">cvxpy solver name. Optionally optimize the positivity constraint
with a particular cvxpy solver. See <a class="reference external" href="http://www.cvxpy.org/">http://www.cvxpy.org/</a> for
details.
Default: None (cvxpy chooses its own solver)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r5adcf1d06c8e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id761">1</a>, <a class="fn-backref" href="#id762">2</a>)</em> Merlet S. et al., Continuous diffusion signal, EAP and</td></tr>
</tbody>
</table>
<p>ODF estimation via Compressive Sensing in diffusion MRI, Medical
Image Analysis, 2013.</p>
<table class="docutils citation" frame="void" id="r5adcf1d06c8e-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id763">[2]</a></td><td>Cheng J. et al., Theoretical Analysis and Practical Insights</td></tr>
</tbody>
</table>
<p>on EAP Estimation via a Unified HARDI Framework, MICCAI workshop on
Computational Diffusion MRI, 2011.</p>
<table class="docutils citation" frame="void" id="r5adcf1d06c8e-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id764">[3]</a></td><td>Ozarslan E. et al., Mean apparent propagator (MAP) MRI: A novel
diffusion imaging method for mapping tissue microstructure,
NeuroImage, 2013.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In this example, where the data, gradient table and sphere tessellation
used for reconstruction are provided, we model the diffusion signal
with respect to the SHORE basis and compute the real and analytical
ODF.</p>
<p>from dipy.data import get_fnames,get_sphere
sphere = get_sphere(symmetric724)
fimg, fbvals, fbvecs = get_fnames(ISBI_testing_2shells_table)
bvals, bvecs = read_bvals_bvecs(fbvals, fbvecs)
gtab = gradient_table(bvals, bvecs)
from dipy.sims.voxel import SticksAndBall
data, golden_directions = SticksAndBall(</p>
<blockquote>
<div>gtab, d=0.0015, S0=1., angles=[(0, 0), (90, 0)],
fractions=[50, 50], snr=None)</div></blockquote>
<p>from dipy.reconst.canal import ShoreModel
radial_order = 4
zeta = 700
asm = ShoreModel(gtab, radial_order=radial_order, zeta=zeta,</p>
<blockquote>
<div>lambdaN=1e-8, lambdaL=1e-8)</div></blockquote>
<p>asmfit = asm.fit(data)
odf= asmfit.odf(sphere)</p>
</dd></dl>

<dl class="method">
<dt id="dipy.reconst.shore.ShoreModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.ShoreModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit method for every voxel in data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id765">
<h3>cart2sphere<a class="headerlink" href="#id765" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.cart2sphere">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">cart2sphere</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.cart2sphere" title="Permalink to this definition"></a></dt>
<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>
<p>See doc for <code class="docutils literal notranslate"><span class="pre">sphere2cart</span></code> for angle conventions and derivation
of the formulae.</p>
<p><span class="math notranslate nohighlight">\(0\le\theta\mathrm{(theta)}\le\pi\)</span> and <span class="math notranslate nohighlight">\(-\pi\le\phi\mathrm{(phi)}\le\pi\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">x coordinate in Cartesian space</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">y coordinate in Cartesian space</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">z coordinate</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">radius</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">inclination (polar) angle</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">azimuth angle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id766">
<h3>create_rspace<a class="headerlink" href="#id766" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.create_rspace">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">create_rspace</code><span class="sig-paren">(</span><em>gridsize</em>, <em>radius_max</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.create_rspace" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>Create the real space table, that contains the points in which</dt>
<dd>to compute the pdf.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gridsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">dimension of the propagator grid</p>
</dd>
<dt><strong>radius_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximal radius in which compute the propagator</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">positions of the pdf points in a 3D matrix</p>
</dd>
<dt><strong>tab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">real space points in which calculates the pdf</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id767">
<h3>factorial<a class="headerlink" href="#id767" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.factorial">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">factorial</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; Integral<a class="headerlink" href="#dipy.reconst.shore.factorial" title="Permalink to this definition"></a></dt>
<dd><p>Find x!. Raise a ValueError if x is negative or non-integral.</p>
</dd></dl>

</div>
<div class="section" id="id768">
<h3>genlaguerre<a class="headerlink" href="#id768" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.genlaguerre">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">genlaguerre</code><span class="sig-paren">(</span><em>n</em>, <em>alpha</em>, <em>monic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.genlaguerre" title="Permalink to this definition"></a></dt>
<dd><p>Generalized (associated) Laguerre polynomial.</p>
<p>Defined to be the solution of</p>
<div class="math notranslate nohighlight">
\[x\frac{d^2}{dx^2}L_n^{(\alpha)}
  + (\alpha + 1 - x)\frac{d}{dx}L_n^{(\alpha)}
  + nL_n^{(\alpha)} = 0,\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha &gt; -1\)</span>; <span class="math notranslate nohighlight">\(L_n^{(\alpha)}\)</span> is a polynomial
of degree <span class="math notranslate nohighlight">\(n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Degree of the polynomial.</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Parameter, must be greater than -1.</p>
</dd>
<dt><strong>monic</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If <cite>True</cite>, scale the leading coefficient to be 1. Default is
<cite>False</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">orthopoly1d</span></dt>
<dd><p class="first last">Generalized Laguerre polynomial.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">laguerre</span></code></dt>
<dd>Laguerre polynomial.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For fixed <span class="math notranslate nohighlight">\(\alpha\)</span>, the polynomials <span class="math notranslate nohighlight">\(L_n^{(\alpha)}\)</span>
are orthogonal over <span class="math notranslate nohighlight">\([0, \infty)\)</span> with weight function
<span class="math notranslate nohighlight">\(e^{-x}x^\alpha\)</span>.</p>
<p>The Laguerre polynomials are the special case where <span class="math notranslate nohighlight">\(\alpha
= 0\)</span>.</p>
</dd></dl>

</div>
<div class="section" id="l-shore">
<h3>l_shore<a class="headerlink" href="#l-shore" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.l_shore">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">l_shore</code><span class="sig-paren">(</span><em>radial_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.l_shore" title="Permalink to this definition"></a></dt>
<dd><p>Returns the angular regularisation matrix for SHORE basis</p>
</dd></dl>

</div>
<div class="section" id="id769">
<h3>multi_voxel_fit<a class="headerlink" href="#id769" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.multi_voxel_fit">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">multi_voxel_fit</code><span class="sig-paren">(</span><em>single_voxel_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.multi_voxel_fit" title="Permalink to this definition"></a></dt>
<dd><p>Method decorator to turn a single voxel model fit
definition into a multi voxel model fit definition</p>
</dd></dl>

</div>
<div class="section" id="n-shore">
<h3>n_shore<a class="headerlink" href="#n-shore" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.n_shore">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">n_shore</code><span class="sig-paren">(</span><em>radial_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.n_shore" title="Permalink to this definition"></a></dt>
<dd><p>Returns the angular regularisation matrix for SHORE basis</p>
</dd></dl>

</div>
<div class="section" id="id770">
<h3>optional_package<a class="headerlink" href="#id770" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.optional_package">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">optional_package</code><span class="sig-paren">(</span><em>name</em>, <em>trip_msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.optional_package" title="Permalink to this definition"></a></dt>
<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">package name</p>
</dd>
<dt><strong>trip_msg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or str</span></dt>
<dd><p class="first last">message to give when someone tries to use the return package, but we
could not import it, and have returned a TripWire object instead.
Default message if None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pkg_like</strong> <span class="classifier-delimiter">:</span> <span class="classifier">module or <code class="docutils literal notranslate"><span class="pre">TripWire</span></code> instance</span></dt>
<dd><p class="first last">If we can import the package, return it.  Otherwise return an object
raising an error when accessed</p>
</dd>
<dt><strong>have_pkg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if import for package was successful, false otherwise</p>
</dd>
<dt><strong>module_setup</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">callable usually set as <code class="docutils literal notranslate"><span class="pre">setup_module</span></code> in calling namespace, to allow
skipping tests.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id771">
<h3>real_sph_harm<a class="headerlink" href="#id771" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.real_sph_harm">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">real_sph_harm</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.real_sph_harm" title="Permalink to this definition"></a></dt>
<dd><p>Compute real spherical harmonics.</p>
<p>Where the real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> is defined to be:</p>
<blockquote>
<div>Imag(<span class="math notranslate nohighlight">\(Y^m_n\)</span>) * sqrt(2)     if m &gt; 0
<span class="math notranslate nohighlight">\(Y^0_n\)</span>                     if m = 0
Real(<span class="math notranslate nohighlight">\(Y^|m|_n\)</span>) * sqrt(2)   if m &lt; 0</div></blockquote>
<p>This may take scalar or array arguments. The inputs will be broadcasted
against each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code></span></dt>
<dd><p class="first last">The order of the harmonic.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code></span></dt>
<dd><p class="first last">The degree of the harmonic.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, 2*pi]</span></dt>
<dd><p class="first last">The azimuthal (longitudinal) coordinate.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0, pi]</span></dt>
<dd><p class="first last">The polar (colatitudinal) coordinate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y_mn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">real float</span></dt>
<dd><p class="first last">The real harmonic <span class="math notranslate nohighlight">\(Y^m_n\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.special.sph_harm</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="shore-indices">
<h3>shore_indices<a class="headerlink" href="#shore-indices" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_indices">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">shore_indices</code><span class="sig-paren">(</span><em>radial_order</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_indices" title="Permalink to this definition"></a></dt>
<dd><p>Given the basis order and the index, return the shore indices n, l, m
for modified Merlets 3D-SHORE
..math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">:</span><span class="n">nowrap</span><span class="p">:</span>
    \<span class="n">begin</span><span class="p">{</span><span class="n">equation</span><span class="p">}</span>
        \<span class="n">textbf</span><span class="p">{</span><span class="n">E</span><span class="p">}(</span><span class="n">q</span>\<span class="n">textbf</span><span class="p">{</span><span class="n">u</span><span class="p">})</span><span class="o">=</span>\<span class="n">sum_</span><span class="p">{</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">even</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="n">N_</span><span class="p">{</span><span class="nb">max</span><span class="p">}}</span>
                                \<span class="n">sum_</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="n">l</span><span class="p">}</span><span class="o">^</span><span class="p">{(</span><span class="n">N_</span><span class="p">{</span><span class="nb">max</span><span class="p">}</span><span class="o">+</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">}</span>
                                \<span class="n">sum_</span><span class="p">{</span><span class="n">m</span><span class="o">=-</span><span class="n">l</span><span class="p">}</span><span class="o">^</span><span class="n">l</span> <span class="n">c_</span><span class="p">{</span><span class="n">nlm</span><span class="p">}</span>
                                \<span class="n">phi_</span><span class="p">{</span><span class="n">nlm</span><span class="p">}(</span><span class="n">q</span>\<span class="n">textbf</span><span class="p">{</span><span class="n">u</span><span class="p">})</span>
    \<span class="n">end</span><span class="p">{</span><span class="n">equation</span><span class="p">}</span>
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(\phi_{nlm}\)</span> is
..math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>:nowrap:
    \begin{equation}
        \phi_{nlm}^{SHORE}(q\textbf{u})=\Biggl[\dfrac{2(n-l)!}
            {\zeta^{3/2} \Gamma(n+3/2)} \Biggr]^{1/2}
            \Biggl(\dfrac{q^2}{\zeta}\Biggr)^{l/2}
            exp\Biggl(\dfrac{-q^2}{2\zeta}\Biggr)
            L^{l+1/2}_{n-l} \Biggl(\dfrac{q^2}{\zeta}\Biggr)
            Y_l^m(\textbf{u}).
    \end{equation}
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">an even integer that represent the maximal order of the basis</p>
</dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">index of the coefficients, start from 0</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">the index n of the modified shore basis</p>
</dd>
<dt><strong>l</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">the index l of the modified shore basis</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">the index m of the modified shore basis</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="shore-matrix">
<h3>shore_matrix<a class="headerlink" href="#shore-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_matrix">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">shore_matrix</code><span class="sig-paren">(</span><em>radial_order</em>, <em>zeta</em>, <em>gtab</em>, <em>tau=0.025330295910584444</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the SHORE matrix for modified Merlets 3D-SHORE <a class="reference internal" href="#r0425af01b43f-1" id="id772">[1]</a></p>
<dl class="docutils">
<dt>..math::</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">nowrap:</th><td class="field-body"><dl class="first docutils">
<dt>begin{equation}</dt>
<dd><dl class="first last docutils">
<dt>textbf{E}(qtextbf{u})=sum_{l=0, even}^{N_{max}}</dt>
<dd><p class="first last">sum_{n=l}^{(N_{max}+l)/2}
sum_{m=-l}^l c_{nlm}
phi_{nlm}(qtextbf{u})</p>
</dd>
</dl>
</dd>
</dl>
<p class="last">end{equation}</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>where <span class="math notranslate nohighlight">\(\phi_{nlm}\)</span> is
..math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>:nowrap:
    \begin{equation}
        \phi_{nlm}^{SHORE}(q\textbf{u})=\Biggl[\dfrac{2(n-l)!}
            {\zeta^{3/2} \Gamma(n+3/2)} \Biggr]^{1/2}
            \Biggl(\dfrac{q^2}{\zeta}\Biggr)^{l/2}
            exp\Biggl(\dfrac{-q^2}{2\zeta}\Biggr)
            L^{l+1/2}_{n-l} \Biggl(\dfrac{q^2}{\zeta}\Biggr)
            Y_l^m(\textbf{u}).
    \end{equation}
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>zeta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">scale factor</p>
</dd>
<dt><strong>gtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable,</span></dt>
<dd><p class="first last">gradient directions and bvalues container class</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float,</span></dt>
<dd><p class="first last">diffusion time. By default the value that makes q=sqrt(b).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r0425af01b43f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id57">1</a>, <a class="fn-backref" href="#id772">2</a>, <a class="fn-backref" href="#id773">3</a>)</em> Merlet S. et al., Continuous diffusion signal, EAP and</td></tr>
</tbody>
</table>
<p>ODF estimation via Compressive Sensing in diffusion MRI, Medical
Image Analysis, 2013.</p>
</dd></dl>

</div>
<div class="section" id="shore-matrix-odf">
<h3>shore_matrix_odf<a class="headerlink" href="#shore-matrix-odf" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_matrix_odf">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">shore_matrix_odf</code><span class="sig-paren">(</span><em>radial_order</em>, <em>zeta</em>, <em>sphere_vertices</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_matrix_odf" title="Permalink to this definition"></a></dt>
<dd><p>Compute the SHORE ODF matrix <a class="reference internal" href="#r0934fd177e35-1" id="id774">[1]</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>zeta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">scale factor</p>
</dd>
<dt><strong>sphere_vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">vertices of the odf sphere</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r0934fd177e35-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id58">1</a>, <a class="fn-backref" href="#id774">2</a>, <a class="fn-backref" href="#id775">3</a>)</em> Merlet S. et al., Continuous diffusion signal, EAP and</td></tr>
</tbody>
</table>
<p>ODF estimation via Compressive Sensing in diffusion MRI, Medical
Image Analysis, 2013.</p>
</dd></dl>

</div>
<div class="section" id="shore-matrix-pdf">
<h3>shore_matrix_pdf<a class="headerlink" href="#shore-matrix-pdf" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_matrix_pdf">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">shore_matrix_pdf</code><span class="sig-paren">(</span><em>radial_order</em>, <em>zeta</em>, <em>rtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_matrix_pdf" title="Permalink to this definition"></a></dt>
<dd><p>Compute the SHORE propagator matrix <a class="reference internal" href="#r5470c7e1e272-1" id="id776">[1]</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">an even integer that represent the order of the basis</p>
</dd>
<dt><strong>zeta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int,</span></dt>
<dd><p class="first last">scale factor</p>
</dd>
<dt><strong>rtab</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N,3)</span></dt>
<dd><p class="first last">real space points in which calculates the pdf</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r5470c7e1e272-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id59">1</a>, <a class="fn-backref" href="#id776">2</a>, <a class="fn-backref" href="#id777">3</a>)</em> Merlet S. et al., Continuous diffusion signal, EAP and</td></tr>
</tbody>
</table>
<p>ODF estimation via Compressive Sensing in diffusion MRI, Medical
Image Analysis, 2013.</p>
</dd></dl>

</div>
<div class="section" id="shore-order">
<h3>shore_order<a class="headerlink" href="#shore-order" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.shore_order">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">shore_order</code><span class="sig-paren">(</span><em>n</em>, <em>l</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.shore_order" title="Permalink to this definition"></a></dt>
<dd><p>Given the indices (n,l,m) of the basis, return the minimum order
for those indices and their index for modified Merlets 3D-SHORE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">the index n of the modified shore basis</p>
</dd>
<dt><strong>l</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">the index l of the modified shore basis</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">the index m of the modified shore basis</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radial_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">an even integer that represent the maximal order of the basis</p>
</dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">unsigned int</span></dt>
<dd><p class="first last">index of the coefficient correspondig to (n,l,m), start from 0</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id778">
<h3>warn<a class="headerlink" href="#id778" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.shore.warn">
<code class="descclassname">dipy.reconst.shore.</code><code class="descname">warn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.shore.warn" title="Permalink to this definition"></a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
<div class="section" id="dki-design-matrix">
<h3>dki_design_matrix<a class="headerlink" href="#dki-design-matrix" title="Permalink to this headline"></a></h3>
<dl class="function">
<dt id="dipy.reconst.utils.dki_design_matrix">
<code class="descclassname">dipy.reconst.utils.</code><code class="descname">dki_design_matrix</code><span class="sig-paren">(</span><em>gtab</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.reconst.utils.dki_design_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Constructs B design matrix for DKI</p>
<dl class="docutils">
<dt>gtab <span class="classifier-delimiter">:</span> <span class="classifier">GradientTable</span></dt>
<dd>Measurement directions.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (N, 22)</span></dt>
<dd><p class="first">Design matrix or B matrix for the DKI model
B[j, :] = (Bxx, Bxy, Bzz, Bxz, Byz, Bzz,</p>
<blockquote class="last">
<div><p>Bxxxx, Byyyy, Bzzzz, Bxxxy, Bxxxz,
Bxyyy, Byyyz, Bxzzz, Byzzz, Bxxyy,
Bxxzz, Byyzz, Bxxyz, Bxyyz, Bxyzz,
BlogS0)</p>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >API Reference</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2019, dipy developers &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
  </body>
</html>