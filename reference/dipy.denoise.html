
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DIPY &#8212; dipy 0.15.0dev documentation</title>
    <link rel="stylesheet" href="../_static/dipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="direction" href="dipy.direction.html" />
  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head><body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../index.html">
  <img src="../_static/dipy-banner.png" alt="DIPY logo"  border="0" />
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.direction.html" title="direction"
             accesskey="N">next</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">API Reference</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Site Navigation </h4>
  <ul>
    <li><a href="../documentation.html">Documentation</a></li>
    <li><a href="../devel/index.html">Development</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.org/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.org/">NIPY Projects</a></li>
    <li><a class="reference external"
	href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing List</a></li>
    <li><a class="reference external"
	href="http://nipy.org/nipy/license.html">License</a></li>
  </ul>


  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">denoise</span></code></a><ul>
<li><a class="reference internal" href="#module-dipy.denoise.adaptive_soft_matching">Module: <code class="docutils literal notranslate"><span class="pre">denoise.adaptive_soft_matching</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.denoise.localpca">Module: <code class="docutils literal notranslate"><span class="pre">denoise.localpca</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.denoise.nlmeans">Module: <code class="docutils literal notranslate"><span class="pre">denoise.nlmeans</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.denoise.noise_estimate">Module: <code class="docutils literal notranslate"><span class="pre">denoise.noise_estimate</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.denoise.non_local_means">Module: <code class="docutils literal notranslate"><span class="pre">denoise.non_local_means</span></code></a><ul>
<li><a class="reference internal" href="#bench">bench</a></li>
<li><a class="reference internal" href="#test">test</a></li>
<li><a class="reference internal" href="#adaptive-soft-matching">adaptive_soft_matching</a></li>
<li><a class="reference internal" href="#eigh">eigh</a></li>
<li><a class="reference internal" href="#localpca">localpca</a></li>
<li><a class="reference internal" href="#nlmeans">nlmeans</a></li>
<li><a class="reference internal" href="#nlmeans-3d">nlmeans_3d</a></li>
<li><a class="reference internal" href="#convolve">convolve</a></li>
<li><a class="reference internal" href="#estimate-sigma">estimate_sigma</a></li>
<li><a class="reference internal" href="#piesno">piesno</a></li>
<li><a class="reference internal" href="#nlmeans-block">nlmeans_block</a></li>
<li><a class="reference internal" href="#non-local-means">non_local_means</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Next topic</h4>
  <p class="topless"><a href="dipy.direction.html"
                        title="next chapter"><code class="docutils literal notranslate"><span class="pre">direction</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/dipy.denoise.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dipy.denoise">
<span id="denoise"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">denoise</span></code><a class="headerlink" href="#module-dipy.denoise" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.denoise.bench" title="dipy.denoise.bench"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bench</span></code></a></td>
<td>Run benchmarks for module using nose.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.denoise.test" title="dipy.denoise.test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test</span></code></a></td>
<td>Run tests for module using nose.</td>
</tr>
</tbody>
</table>
<div class="section" id="module-dipy.denoise.adaptive_soft_matching">
<span id="module-denoise-adaptive-soft-matching"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">denoise.adaptive_soft_matching</span></code><a class="headerlink" href="#module-dipy.denoise.adaptive_soft_matching" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.denoise.adaptive_soft_matching.adaptive_soft_matching" title="dipy.denoise.adaptive_soft_matching.adaptive_soft_matching"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive_soft_matching</span></code></a>(ima,&nbsp;fimau,&nbsp;fimao,&nbsp;sigma)</td>
<td>Adaptive Soft Coefficient Matching</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.denoise.localpca">
<span id="module-denoise-localpca"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">denoise.localpca</span></code><a class="headerlink" href="#module-dipy.denoise.localpca" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.denoise.localpca.eigh" title="dipy.denoise.localpca.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a>(a[,&nbsp;b,&nbsp;lower,&nbsp;eigvals_only,&nbsp;…])</td>
<td>Solve an ordinary or generalized eigenvalue problem for a complex Hermitian or real symmetric matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.denoise.localpca.localpca" title="dipy.denoise.localpca.localpca"><code class="xref py py-obj docutils literal notranslate"><span class="pre">localpca</span></code></a>(arr,&nbsp;sigma[,&nbsp;mask,&nbsp;pca_method,&nbsp;…])</td>
<td>Local PCA-based denoising of diffusion datasets.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.denoise.nlmeans">
<span id="module-denoise-nlmeans"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">denoise.nlmeans</span></code><a class="headerlink" href="#module-dipy.denoise.nlmeans" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.denoise.nlmeans.nlmeans" title="dipy.denoise.nlmeans.nlmeans"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlmeans</span></code></a>(arr,&nbsp;sigma[,&nbsp;mask,&nbsp;patch_radius,&nbsp;…])</td>
<td>Non-local means for denoising 3D and 4D images</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.denoise.nlmeans.nlmeans_3d" title="dipy.denoise.nlmeans.nlmeans_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlmeans_3d</span></code></a></td>
<td>Non-local means for denoising 3D images</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.denoise.noise_estimate">
<span id="module-denoise-noise-estimate"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">denoise.noise_estimate</span></code><a class="headerlink" href="#module-dipy.denoise.noise_estimate" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.denoise.noise_estimate.convolve" title="dipy.denoise.noise_estimate.convolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve</span></code></a>(input,&nbsp;weights[,&nbsp;output,&nbsp;mode,&nbsp;…])</td>
<td>Multidimensional convolution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.denoise.noise_estimate.estimate_sigma" title="dipy.denoise.noise_estimate.estimate_sigma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_sigma</span></code></a>(arr[,&nbsp;…])</td>
<td>Standard deviation estimation from local patches</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dipy.denoise.noise_estimate.piesno" title="dipy.denoise.noise_estimate.piesno"><code class="xref py py-obj docutils literal notranslate"><span class="pre">piesno</span></code></a>(data,&nbsp;N[,&nbsp;alpha,&nbsp;l,&nbsp;itermax,&nbsp;eps,&nbsp;…])</td>
<td>Probabilistic Identification and Estimation of Noise (PIESNO).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.denoise.non_local_means">
<span id="module-denoise-non-local-means"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">denoise.non_local_means</span></code><a class="headerlink" href="#module-dipy.denoise.non_local_means" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dipy.denoise.non_local_means.nlmeans_block" title="dipy.denoise.non_local_means.nlmeans_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlmeans_block</span></code></a></td>
<td>Non-Local Means Denoising Using Blockwise Averaging</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dipy.denoise.non_local_means.non_local_means" title="dipy.denoise.non_local_means.non_local_means"><code class="xref py py-obj docutils literal notranslate"><span class="pre">non_local_means</span></code></a>(arr,&nbsp;sigma[,&nbsp;mask,&nbsp;…])</td>
<td>Non-local means for denoising 3D and 4D images, using</td>
</tr>
</tbody>
</table>
<div class="section" id="bench">
<h3>bench<a class="headerlink" href="#bench" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.bench">
<code class="descclassname">dipy.denoise.</code><code class="descname">bench</code><span class="sig-paren">(</span><em>label='fast'</em>, <em>verbose=1</em>, <em>extra_argv=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.bench" title="Permalink to this definition">¶</a></dt>
<dd><p>Run benchmarks for module using nose.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘fast’, ‘full’, ‘’, attribute identifier}, optional</span></dt>
<dd><p class="first">Identifies the benchmarks to run. This can be a string to pass to
the nosetests executable with the ‘-A’ option, or one of several
special values.  Special values are:
* ‘fast’ - the default - which corresponds to the <code class="docutils literal notranslate"><span class="pre">nosetests</span> <span class="pre">-A</span></code></p>
<blockquote>
<div><p>option of ‘not slow’.</p>
</div></blockquote>
<ul class="simple">
<li>‘full’ - fast (as above) and slow benchmarks as in the
‘no -A’ option to nosetests - this is the same as ‘’.</li>
<li>None or ‘’ - run all tests.</li>
</ul>
<p class="last">attribute_identifier - string passed directly to nosetests as ‘-A’.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Verbosity value for benchmark outputs, in the range 1-10. Default is 1.</p>
</dd>
<dt><strong>extra_argv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last">List with any extra arguments to pass to nosetests.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Returns True if running the benchmarks works, False if an error
occurred.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Benchmarks are like tests, but have names starting with “bench” instead
of “test”, and can be found under the “benchmarks” sub-directory of the
module.</p>
<p>Each NumPy module exposes <cite>bench</cite> in its namespace to run all benchmarks
for it.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">success</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">bench</span><span class="p">()</span> 
<span class="go">Running benchmarks for numpy.lib</span>
<span class="gp">...</span>
<span class="go">using 562341 items:</span>
<span class="go">unique:</span>
<span class="go">0.11</span>
<span class="go">unique1d:</span>
<span class="go">0.11</span>
<span class="go">ratio: 1.0</span>
<span class="go">nUnique: 56230 == 56230</span>
<span class="gp">...</span>
<span class="go">OK</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">success</span> 
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="test">
<h3>test<a class="headerlink" href="#test" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.test">
<code class="descclassname">dipy.denoise.</code><code class="descname">test</code><span class="sig-paren">(</span><em>label='fast'</em>, <em>verbose=1</em>, <em>extra_argv=None</em>, <em>doctests=False</em>, <em>coverage=False</em>, <em>raise_warnings=None</em>, <em>timer=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Run tests for module using nose.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘fast’, ‘full’, ‘’, attribute identifier}, optional</span></dt>
<dd><p class="first">Identifies the tests to run. This can be a string to pass to
the nosetests executable with the ‘-A’ option, or one of several
special values.  Special values are:
* ‘fast’ - the default - which corresponds to the <code class="docutils literal notranslate"><span class="pre">nosetests</span> <span class="pre">-A</span></code></p>
<blockquote>
<div><p>option of ‘not slow’.</p>
</div></blockquote>
<ul class="simple">
<li>‘full’ - fast (as above) and slow tests as in the
‘no -A’ option to nosetests - this is the same as ‘’.</li>
<li>None or ‘’ - run all tests.</li>
</ul>
<p class="last">attribute_identifier - string passed directly to nosetests as ‘-A’.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Verbosity value for test outputs, in the range 1-10. Default is 1.</p>
</dd>
<dt><strong>extra_argv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last">List with any extra arguments to pass to nosetests.</p>
</dd>
<dt><strong>doctests</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, run doctests in module. Default is False.</p>
</dd>
<dt><strong>coverage</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If True, report coverage of NumPy code. Default is False.
(This requires the <a href="#id1"><span class="problematic" id="id2">`</span></a>coverage module:</p>
<blockquote class="last">
<div><p>&lt;<a class="reference external" href="http://nedbatchelder.com/code/modules/coverage.html">http://nedbatchelder.com/code/modules/coverage.html</a>&gt;`_).</p>
</div></blockquote>
</dd>
<dt><strong>raise_warnings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None, str or sequence of warnings, optional</span></dt>
<dd><p class="first">This specifies which warnings to configure as ‘raise’ instead
of being shown once during the test execution.  Valid strings are:</p>
<blockquote>
<div><ul class="simple">
<li>“develop” : equals <code class="docutils literal notranslate"><span class="pre">(Warning,)</span></code></li>
<li>“release” : equals <code class="docutils literal notranslate"><span class="pre">()</span></code>, don’t raise on any warnings.</li>
</ul>
</div></blockquote>
<p class="last">The default is to use the class initialization value.</p>
</dd>
<dt><strong>timer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool or int, optional</span></dt>
<dd><p class="first last">Timing of individual tests with <code class="docutils literal notranslate"><span class="pre">nose-timer</span></code> (which needs to be
installed).  If True, time tests and report on all of them.
If an integer (say <code class="docutils literal notranslate"><span class="pre">N</span></code>), report timing results for <code class="docutils literal notranslate"><span class="pre">N</span></code> slowest
tests.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns the result of running the tests as a
<code class="docutils literal notranslate"><span class="pre">nose.result.TextTestResult</span></code> object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Each NumPy module exposes <cite>test</cite> in its namespace to run all tests for it.
For example, to run all tests for numpy.lib:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">test</span><span class="p">()</span> 
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">test</span><span class="p">()</span> 
<span class="go">Running unit tests for numpy.lib</span>
<span class="gp">...</span>
<span class="go">Ran 976 tests in 3.933s</span>
</pre></div>
</div>
<p>OK</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">errors</span> 
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">knownfail</span> 
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="adaptive-soft-matching">
<h3>adaptive_soft_matching<a class="headerlink" href="#adaptive-soft-matching" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.adaptive_soft_matching.adaptive_soft_matching">
<code class="descclassname">dipy.denoise.adaptive_soft_matching.</code><code class="descname">adaptive_soft_matching</code><span class="sig-paren">(</span><em>ima</em>, <em>fimau</em>, <em>fimao</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.adaptive_soft_matching.adaptive_soft_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive Soft Coefficient Matching</p>
<p>Combines two filtered 3D-images at different resolutions and the orginal
image. Returns the resulting combined image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ima</strong> <span class="classifier-delimiter">:</span> <span class="classifier">the original (not filtered) image</span></dt>
<dd></dd>
<dt><strong>fimau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D double array,</span></dt>
<dd><p class="first last">filtered image with optimized non-local means using a small block
(suggested:3x3), which corresponds to a “high resolution” filter.</p>
</dd>
<dt><strong>fimao</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D double array,</span></dt>
<dd><p class="first last">filtered image with optimized non-local means using a small block
(suggested:5x5), which corresponds to a “low resolution” filter.</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">the estimated standard deviation of the Gaussian random variables</span></dt>
<dd><p class="first last">that explain the rician noise. Note: In P. Coupe et al. the
rician noise was simulated as sqrt((f+x)^2 + (y)^2) where f is
the pixel value and x and y are independent realizations of a
random variable with Normal distribution, with mean=0 and
standard deviation=h</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fima</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D double array</span></dt>
<dd><p class="first last">output denoised array which is of the same shape as that of
the input</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="refa1efa84d4b-coupe11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Coupe11]</a></td><td>Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.
“Multiresolution Non-Local Means Filter for 3D MR Image
Denoising” IET Image Processing, Institution of Engineering
and Technology,
2011</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="eigh">
<h3>eigh<a class="headerlink" href="#eigh" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.localpca.eigh">
<code class="descclassname">dipy.denoise.localpca.</code><code class="descname">eigh</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em>, <em>lower=True</em>, <em>eigvals_only=False</em>, <em>overwrite_a=False</em>, <em>overwrite_b=False</em>, <em>turbo=True</em>, <em>eigvals=None</em>, <em>type=1</em>, <em>check_finite=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.localpca.eigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues w and optionally eigenvectors v of matrix <cite>a</cite>, where
<cite>b</cite> is positive definite:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>              <span class="n">a</span> <span class="n">v</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">b</span> <span class="n">v</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
<span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="n">a</span> <span class="n">v</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="n">b</span> <span class="n">v</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, M) array_like</span></dt>
<dd><p class="first last">A complex Hermitian or real symmetric matrix whose eigenvalues and
eigenvectors will be computed.</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, M) array_like, optional</span></dt>
<dd><p class="first last">A complex Hermitian or real symmetric definite positive matrix in.
If omitted, identity matrix is assumed.</p>
</dd>
<dt><strong>lower</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether the pertinent array data is taken from the lower or upper
triangle of <cite>a</cite>. (Default: lower)</p>
</dd>
<dt><strong>eigvals_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to calculate only eigenvalues and no eigenvectors.
(Default: both are calculated)</p>
</dd>
<dt><strong>turbo</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Use divide and conquer algorithm (faster but expensive in memory,
only for generalized eigenvalue problem and if eigvals=None)</p>
</dd>
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple (lo, hi), optional</span></dt>
<dd><p class="first last">Indexes of the smallest and largest (in ascending order) eigenvalues
and corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.
If omitted, all eigenvalues and eigenvectors are returned.</p>
</dd>
<dt><strong>type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first">Specifies the problem type to be solved:</p>
<blockquote class="last">
<div><p>type = 1: a   v[:,i] = w[i] b v[:,i]</p>
<p>type = 2: a b v[:,i] = w[i]   v[:,i]</p>
<p>type = 3: b a v[:,i] = w[i]   v[:,i]</p>
</div></blockquote>
</dd>
<dt><strong>overwrite_a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to overwrite data in <cite>a</cite> (may improve performance)</p>
</dd>
<dt><strong>overwrite_b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to overwrite data in <cite>b</cite> (may improve performance)</p>
</dd>
<dt><strong>check_finite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>w</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) float ndarray</span></dt>
<dd><p class="first last">The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
repeated according to its multiplicity.</p>
</dd>
<dt><strong>v</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, N) complex ndarray</span></dt>
<dd><p class="first">(if eigvals_only == False)</p>
<p>The normalized selected eigenvector corresponding to the
eigenvalue w[i] is the column v[:,i].</p>
<p>Normalization:</p>
<blockquote class="last">
<div><p>type 1 and 3: v.conj() a      v  = w</p>
<p>type 2: inv(v).conj() a  inv(v) = w</p>
<p>type = 1 or 2: v.conj() b      v  = I</p>
<p>type = 3: v.conj() inv(b) v  = I</p>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>LinAlgError</strong></dt>
<dd><p class="first last">If eigenvalue computation does not converge,
an error occurred, or b matrix is not definite positive. Note that
if input matrices are not symmetric or hermitian, no error is reported
but results will be wrong.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigvalsh</span></code></dt>
<dd>eigenvalues of symmetric or Hermitian arrays</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">eig</span></code></dt>
<dd>eigenvalues and right eigenvectors for non-symmetric arrays</dd>
<dt><a class="reference internal" href="#dipy.denoise.localpca.eigh" title="dipy.denoise.localpca.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a></dt>
<dd>eigenvalues and right eigenvectors for symmetric/Hermitian arrays</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh_tridiagonal</span></code></dt>
<dd>eigenvalues and right eiegenvectors for symmetric/Hermitian tridiagonal matrices</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">eigh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="localpca">
<h3>localpca<a class="headerlink" href="#localpca" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.localpca.localpca">
<code class="descclassname">dipy.denoise.localpca.</code><code class="descname">localpca</code><span class="sig-paren">(</span><em>arr</em>, <em>sigma</em>, <em>mask=None</em>, <em>pca_method='eig'</em>, <em>patch_radius=2</em>, <em>tau_factor=2.3</em>, <em>out_dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.localpca.localpca" title="Permalink to this definition">¶</a></dt>
<dd><p>Local PCA-based denoising of diffusion datasets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">4D array</span></dt>
<dd><p class="first last">Array of data to be denoised. The dimensions are (X, Y, Z, N), where N
are the diffusion gradient directions.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D boolean array</span></dt>
<dd><p class="first last">A mask with voxels that are true inside the brain and false outside of
it. The function denoises within the true part and returns zeros
outside of those voxels.</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or 3D array</span></dt>
<dd><p class="first last">Standard deviation of the noise estimated from the data.</p>
</dd>
<dt><strong>pca_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘eig’ or ‘svd’</span></dt>
<dd><p class="first last">Use either eigenvalue decomposition (eig) or singular value
decomposition (svd) for principal component analysis. The default
method is ‘eig’ which is faster. However, occasionally ‘svd’ might be
more accurate.</p>
</dd>
<dt><strong>patch_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The radius of the local patch to be taken around each voxel (in
voxels). Default: 2 (denoise in blocks of 5x5x5 voxels).</p>
</dd>
<dt><strong>tau_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first">Thresholding of PCA eigenvalues is done by nulling out eigenvalues that
are smaller than:</p>
<div class="math notranslate nohighlight">
\[\tau = (\tau_{factor} \sigma)^2\]</div>
<p class="last">Default: 2.3, based on the results described in <a class="reference internal" href="#rc1f8d7038c98-manjon13" id="id4">[Manjon13]</a>.</p>
</dd>
<dt><strong>out_dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or dtype, optional</span></dt>
<dd><p class="first last">The dtype for the output array. Default: output has the same dtype as
the input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>denoised_arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">4D array</span></dt>
<dd><p class="first last">This is the denoised array of the same size as that of the input data,
clipped to non-negative values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rc1f8d7038c98-manjon13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Manjon13]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Manjon JV, Coupe P, Concha L, Buades A, Collins DL (2013)
Diffusion Weighted Image Denoising Using Overcomplete Local
PCA. PLoS ONE 8(9): e73021.
<a class="reference external" href="https://doi.org/10.1371/journal.pone.0073021">https://doi.org/10.1371/journal.pone.0073021</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="nlmeans">
<h3>nlmeans<a class="headerlink" href="#nlmeans" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.nlmeans.nlmeans">
<code class="descclassname">dipy.denoise.nlmeans.</code><code class="descname">nlmeans</code><span class="sig-paren">(</span><em>arr</em>, <em>sigma</em>, <em>mask=None</em>, <em>patch_radius=1</em>, <em>block_radius=5</em>, <em>rician=True</em>, <em>num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.nlmeans.nlmeans" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-local means for denoising 3D and 4D images</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D or 4D ndarray</span></dt>
<dd><p class="first last">The array to be denoised</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D ndarray</span></dt>
<dd></dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or 3D array</span></dt>
<dd><p class="first last">standard deviation of the noise estimated from the data</p>
</dd>
<dt><strong>patch_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">patch size is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">patch_radius</span> <span class="pre">+</span> <span class="pre">1</span></code>. Default is 1.</p>
</dd>
<dt><strong>block_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">block size is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">block_radius</span> <span class="pre">+</span> <span class="pre">1</span></code>. Default is 5.</p>
</dd>
<dt><strong>rician</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True the noise is estimated as Rician, otherwise Gaussian noise
is assumed.</p>
</dd>
<dt><strong>num_threads</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of threads. If None (default) then all available threads
will be used (all CPU cores).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>denoised_arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">the denoised <code class="docutils literal notranslate"><span class="pre">arr</span></code> which has the same shape as <code class="docutils literal notranslate"><span class="pre">arr</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r764c162eb15f-descoteaux08" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[Descoteaux08]</a></td><td>Descoteaux, Maxim and Wiest-Daessle`, Nicolas and Prima,
Sylvain and Barillot, Christian and Deriche, Rachid
Impact of Rician Adapted Non-Local Means Filtering on
HARDI, MICCAI 2008</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="nlmeans-3d">
<h3>nlmeans_3d<a class="headerlink" href="#nlmeans-3d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.nlmeans.nlmeans_3d">
<code class="descclassname">dipy.denoise.nlmeans.</code><code class="descname">nlmeans_3d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.nlmeans.nlmeans_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-local means for denoising 3D images</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D ndarray</span></dt>
<dd><p class="first last">The array to be denoised</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D ndarray</span></dt>
<dd></dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or 3D array</span></dt>
<dd><p class="first last">standard deviation of the noise estimated from the data</p>
</dd>
<dt><strong>patch_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">patch size is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">patch_radius</span> <span class="pre">+</span> <span class="pre">1</span></code>. Default is 1.</p>
</dd>
<dt><strong>block_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">block size is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">block_radius</span> <span class="pre">+</span> <span class="pre">1</span></code>. Default is 5.</p>
</dd>
<dt><strong>rician</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True the noise is estimated as Rician, otherwise Gaussian noise
is assumed.</p>
</dd>
<dt><strong>num_threads</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of threads. If None (default) then all available threads
will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>denoised_arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">the denoised <code class="docutils literal notranslate"><span class="pre">arr</span></code> which has the same shape as <code class="docutils literal notranslate"><span class="pre">arr</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="convolve">
<h3>convolve<a class="headerlink" href="#convolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.noise_estimate.convolve">
<code class="descclassname">dipy.denoise.noise_estimate.</code><code class="descname">convolve</code><span class="sig-paren">(</span><em>input</em>, <em>weights</em>, <em>output=None</em>, <em>mode='reflect'</em>, <em>cval=0.0</em>, <em>origin=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.noise_estimate.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Multidimensional convolution.</p>
<p>The array is convolved with the given kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>input</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">The input array.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Array of weights, same number of dimensions as input</p>
</dd>
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or dtype, optional</span></dt>
<dd><p class="first last">The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or sequence, optional</span></dt>
<dd><p class="first">The <cite>mode</cite> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
‘reflect’. The valid values and their behavior is as follows:</p>
<dl class="last docutils">
<dt>‘reflect’ (<cite>d c b a | a b c d | d c b a</cite>)</dt>
<dd><p class="first last">The input is extended by reflecting about the edge of the last
pixel.</p>
</dd>
<dt>‘constant’ (<cite>k k k k | a b c d | k k k k</cite>)</dt>
<dd><p class="first last">The input is extended by filling all values beyond the edge with
the same constant value, defined by the <cite>cval</cite> parameter.</p>
</dd>
<dt>‘nearest’ (<cite>a a a a | a b c d | d d d d</cite>)</dt>
<dd><p class="first last">The input is extended by replicating the last pixel.</p>
</dd>
<dt>‘mirror’ (<cite>d c b | a b c d | c b a</cite>)</dt>
<dd><p class="first last">The input is extended by reflecting about the center of the last
pixel.</p>
</dd>
<dt>‘wrap’ (<cite>a b c d | a b c d | a b c d</cite>)</dt>
<dd><p class="first last">The input is extended by wrapping around to the opposite edge.</p>
</dd>
</dl>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first last">Value to fill past edges of input if <cite>mode</cite> is ‘constant’. Default
is 0.0</p>
</dd>
<dt><strong>origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence, optional</span></dt>
<dd><p class="first last">Controls the placement of the filter on the input array’s pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The result of convolution of <cite>input</cite> with <cite>weights</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlate</span></code></dt>
<dd>Correlate an image with a kernel.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Each value in result is <span class="math notranslate nohighlight">\(C_i = \sum_j{I_{i+k-j} W_j}\)</span>, where
W is the <cite>weights</cite> kernel,
j is the n-D spatial index over <span class="math notranslate nohighlight">\(W\)</span>,
I is the <cite>input</cite> and k is the coordinate of the center of
W, specified by <cite>origin</cite> in the input parameters.</p>
<p class="rubric">Examples</p>
<p>Perhaps the simplest case to understand is <code class="docutils literal notranslate"><span class="pre">mode='constant',</span> <span class="pre">cval=0.0</span></code>,
because in this case borders (i.e. where the <cite>weights</cite> kernel, centered
on any one value, extends beyond an edge of <cite>input</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="go">array([[11, 10,  7,  4],</span>
<span class="go">       [10,  3, 11, 11],</span>
<span class="go">       [15, 12, 14,  7],</span>
<span class="go">       [12,  3,  7,  0]])</span>
</pre></div>
</div>
<p>Setting <code class="docutils literal notranslate"><span class="pre">cval=1.0</span></code> is equivalent to padding the outer edge of <cite>input</cite>
with 1.0’s (and then extracting only the original region of the result).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="go">array([[13, 11,  8,  7],</span>
<span class="go">       [11,  3, 11, 14],</span>
<span class="go">       [16, 12, 14, 10],</span>
<span class="go">       [15,  6, 10,  5]])</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">mode='reflect'</span></code> (the default), outer values are reflected at the
edge of <cite>input</cite> to fill in missing values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">)</span>
<span class="go">array([[5, 0, 0],</span>
<span class="go">       [3, 0, 0],</span>
<span class="go">       [1, 0, 0]])</span>
</pre></div>
</div>
<p>This includes diagonally at the corners.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
<span class="go">array([[4, 2, 0],</span>
<span class="go">       [3, 2, 0],</span>
<span class="go">       [1, 1, 0]])</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">mode='nearest'</span></code>, the single nearest value in to an edge in
<cite>input</cite> is repeated as many times as needed to match the overlapping
<cite>weights</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
<span class="go">array([[7, 0, 3],</span>
<span class="go">       [5, 0, 2],</span>
<span class="go">       [3, 0, 1]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="estimate-sigma">
<h3>estimate_sigma<a class="headerlink" href="#estimate-sigma" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.noise_estimate.estimate_sigma">
<code class="descclassname">dipy.denoise.noise_estimate.</code><code class="descname">estimate_sigma</code><span class="sig-paren">(</span><em>arr</em>, <em>disable_background_masking=False</em>, <em>N=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.noise_estimate.estimate_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard deviation estimation from local patches</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D or 4D ndarray</span></dt>
<dd><p class="first last">The array to be estimated</p>
</dd>
<dt><strong>disable_background_masking</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">If True, uses all voxels for the estimation, otherwise, only non-zeros
voxels are used. Useful if the background is masked by the scanner.</p>
</dd>
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default 0</span></dt>
<dd><p class="first last">Number of coils of the receiver array. Use N = 1 in case of a SENSE
reconstruction (Philips scanners) or the number of coils for a GRAPPA
reconstruction (Siemens and GE). Use 0 to disable the correction factor,
as for example if the noise is Gaussian distributed. See [1] for more
information.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">standard deviation of the noise, one estimation per volume.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="piesno">
<h3>piesno<a class="headerlink" href="#piesno" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.noise_estimate.piesno">
<code class="descclassname">dipy.denoise.noise_estimate.</code><code class="descname">piesno</code><span class="sig-paren">(</span><em>data</em>, <em>N</em>, <em>alpha=0.01</em>, <em>l=100</em>, <em>itermax=100</em>, <em>eps=1e-05</em>, <em>return_mask=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.noise_estimate.piesno" title="Permalink to this definition">¶</a></dt>
<dd><p>Probabilistic Identification and Estimation of Noise (PIESNO).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The magnitude signals to analyse. The last dimension must contain the
same realisation of the volume, such as dMRI or fMRI data.</p>
</dd>
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of phase array coils of the MRI scanner.
If your scanner does a SENSE reconstruction, ALWAYS use N=1, as the
noise profile is always Rician.
If your scanner does a GRAPPA reconstruction, set N as the number
of phase array coils.</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Probabilistic estimation threshold for the gamma function.</p>
</dd>
<dt><strong>l</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of initial estimates for sigma to try.</p>
</dd>
<dt><strong>itermax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations to execute if convergence
is not reached.</p>
</dd>
<dt><strong>eps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance for the convergence criterion. Convergence is
reached if two subsequent estimates are smaller than eps.</p>
</dd>
<dt><strong>return_mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, return a mask identyfing all the pure noise voxel
that were found.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The estimated standard deviation of the gaussian noise.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (optional)</span></dt>
<dd><p class="first last">A boolean mask indicating the voxels identified as pure noise.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rc7d3e0e673f9-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[1]</a></td><td>Koay CG, Ozarslan E and Pierpaoli C.</td></tr>
</tbody>
</table>
<p>“Probabilistic Identification and Estimation of Noise (PIESNO):
A self-consistent approach and its applications in MRI.”
Journal of Magnetic Resonance 2009; 199: 94-103.</p>
<table class="docutils citation" frame="void" id="rc7d3e0e673f9-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[2]</a></td><td>Koay CG, Ozarslan E and Basser PJ.</td></tr>
</tbody>
</table>
<p>“A signal transformational framework for breaking the noise floor
and its applications in MRI.”
Journal of Magnetic Resonance 2009; 197: 108-119.</p>
</dd></dl>

</div>
<div class="section" id="nlmeans-block">
<h3>nlmeans_block<a class="headerlink" href="#nlmeans-block" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.non_local_means.nlmeans_block">
<code class="descclassname">dipy.denoise.non_local_means.</code><code class="descname">nlmeans_block</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.non_local_means.nlmeans_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-Local Means Denoising Using Blockwise Averaging</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D array of doubles</span></dt>
<dd><p class="first last">the input image, corrupted with rician noise</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D array of doubles</span></dt>
<dd><p class="first last">the input mask</p>
</dd>
<dt><strong>patch_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">similar patches in the non-local means are searched for locally,
inside a cube of side 2*v+1 centered at each voxel of interest.</p>
</dd>
<dt><strong>block_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">the size of the block to be used (2*f+1)x(2*f+1)x(2*f+1) in the
blockwise non-local means implementation (the Coupe’s proposal).</p>
</dd>
<dt><strong>h</strong> <span class="classifier-delimiter">:</span> <span class="classifier">double</span></dt>
<dd><p class="first last">the estimated amount of rician noise in the input image: in P.
Coupe et al. the rician noise was simulated as
sqrt((f+x)^2 + (y)^2) where f is the pixel value and x and y are
independent realizations of a random variable with Normal
distribution, with mean=0 and standard deviation=h</p>
</dd>
<dt><strong>rician</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True the noise is estimated as Rician, otherwise Gaussian noise
is assumed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fima: 3D double array</strong></dt>
<dd><p class="first last">the denoised output which has the same shape as input image.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<dl class="docutils">
<dt>[1] P. Coupe, P. Yger, S. Prima, P. Hellier, C. Kervrann, C. Barillot,</dt>
<dd>“An Optimized Blockwise Non Local Means Denoising Filter for 3D Magnetic
Resonance Images”
IEEE Transactions on Medical Imaging, 27(4):425-441, 2008</dd>
<dt>[2] Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.</dt>
<dd>“Multiresolution Non-Local Means Filter for 3D MR Image Denoising”
IET Image Processing, Institution of Engineering and Technology, 2011</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="non-local-means">
<h3>non_local_means<a class="headerlink" href="#non-local-means" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.denoise.non_local_means.non_local_means">
<code class="descclassname">dipy.denoise.non_local_means.</code><code class="descname">non_local_means</code><span class="sig-paren">(</span><em>arr</em>, <em>sigma</em>, <em>mask=None</em>, <em>patch_radius=1</em>, <em>block_radius=5</em>, <em>rician=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.denoise.non_local_means.non_local_means" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Non-local means for denoising 3D and 4D images, using</dt>
<dd>blockwise averaging approach</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D or 4D ndarray</span></dt>
<dd><p class="first last">The array to be denoised</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D ndarray</span></dt>
<dd></dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">standard deviation of the noise estimated from the data</p>
</dd>
<dt><strong>patch_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">patch size is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">patch_radius</span> <span class="pre">+</span> <span class="pre">1</span></code>. Default is 1.</p>
</dd>
<dt><strong>block_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">block size is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">block_radius</span> <span class="pre">+</span> <span class="pre">1</span></code>. Default is 5.</p>
</dd>
<dt><strong>rician</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True the noise is estimated as Rician, otherwise Gaussian noise
is assumed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>denoised_arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">the denoised <code class="docutils literal notranslate"><span class="pre">arr</span></code> which has the same shape as <code class="docutils literal notranslate"><span class="pre">arr</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rad5f4d89a56a-coupe08" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[Coupe08]</a></td><td>P. Coupe, P. Yger, S. Prima, P. Hellier, C. Kervrann, C.
Barillot, An Optimized Blockwise Non Local Means Denoising
Filter for 3D Magnetic Resonance Images, IEEE Transactions on
Medical Imaging, 27(4):425-441, 2008</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rad5f4d89a56a-coupe11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[Coupe11]</a></td><td>Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.
Adaptive Multiresolution Non-Local Means Filter for 3D MR Image
Denoising IET Image Processing, Institution of Engineering and
Technology, 2011</td></tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.direction.html" title="direction"
             >next</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >API Reference</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2019, dipy developers &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
  </body>
</html>